import {
  BoundingInfo,
  SubMesh
} from "./chunk-AZ7ITQQF.js";
import {
  extractMinAndMax
} from "./chunk-QZDP5VDB.js";
import {
  PickingInfo
} from "./chunk-E4RC5JBY.js";
import {
  VertexBuffer
} from "./chunk-SGWWALOD.js";
import {
  Axis
} from "./chunk-QHH6DDKY.js";
import {
  UniformBuffer
} from "./chunk-HWNH73LD.js";
import {
  Node
} from "./chunk-TBN5BH3M.js";
import {
  SerializationHelper
} from "./chunk-HLXCXV77.js";
import {
  __decorate,
  nativeOverride,
  serialize,
  serializeAsQuaternion,
  serializeAsVector3
} from "./chunk-S2HVPJYT.js";
import {
  ErrorCodes,
  RuntimeError
} from "./chunk-NDLZWJHM.js";
import {
  AbstractEngine
} from "./chunk-VFWUTG4V.js";
import {
  _WarnImport
} from "./chunk-4GUORC2E.js";
import {
  Logger
} from "./chunk-OJJXGLTO.js";
import {
  Color3,
  Color4
} from "./chunk-U2XMHILU.js";
import {
  Matrix,
  Quaternion,
  TmpVectors,
  Vector3,
  Vector4
} from "./chunk-4FZTLWAK.js";
import {
  Observable
} from "./chunk-GWFZRJMO.js";
import {
  Epsilon
} from "./chunk-AQLPQ2Z4.js";
import {
  GetClass,
  RegisterClass
} from "./chunk-LMH7SWDS.js";

// node_modules/@babylonjs/core/Misc/coroutine.js
function inlineScheduler(coroutine, onStep, onError) {
  try {
    const step = coroutine.next();
    if (step.done) {
      onStep(step);
    } else if (!step.value) {
      onStep(step);
    } else {
      step.value.then(() => {
        step.value = void 0;
        onStep(step);
      }, onError);
    }
  } catch (error) {
    onError(error);
  }
}
function createYieldingScheduler(yieldAfterMS = 25) {
  let startTime;
  return (coroutine, onStep, onError) => {
    const currentTime = performance.now();
    if (startTime === void 0 || currentTime - startTime > yieldAfterMS) {
      startTime = currentTime;
      setTimeout(() => {
        inlineScheduler(coroutine, onStep, onError);
      }, 0);
    } else {
      inlineScheduler(coroutine, onStep, onError);
    }
  };
}
function runCoroutine(coroutine, scheduler, onSuccess, onError, abortSignal) {
  const resume = () => {
    let reschedule;
    const onStep = (stepResult) => {
      if (stepResult.done) {
        onSuccess(stepResult.value);
      } else {
        if (reschedule === void 0) {
          reschedule = true;
        } else {
          resume();
        }
      }
    };
    do {
      reschedule = void 0;
      if (!abortSignal || !abortSignal.aborted) {
        scheduler(coroutine, onStep, onError);
      } else {
        onError(new Error("Aborted"));
      }
      if (reschedule === void 0) {
        reschedule = false;
      }
    } while (reschedule);
  };
  resume();
}
function runCoroutineSync(coroutine, abortSignal) {
  let result;
  runCoroutine(coroutine, inlineScheduler, (r) => result = r, (e) => {
    throw e;
  }, abortSignal);
  return result;
}
function runCoroutineAsync(coroutine, scheduler, abortSignal) {
  return new Promise((resolve, reject) => {
    runCoroutine(coroutine, scheduler, resolve, reject, abortSignal);
  });
}
function makeSyncFunction(coroutineFactory, abortSignal) {
  return (...params) => {
    return runCoroutineSync(coroutineFactory(...params), abortSignal);
  };
}
function makeAsyncFunction(coroutineFactory, scheduler, abortSignal) {
  return (...params) => {
    return runCoroutineAsync(coroutineFactory(...params), scheduler, abortSignal);
  };
}

// node_modules/@babylonjs/core/Meshes/mesh.vertexData.js
var VertexDataMaterialInfo = class {
};
var VertexData = class _VertexData {
  /**
   * Creates a new VertexData
   */
  constructor() {
    this.uniqueId = 0;
    this.metadata = {};
    this._applyTo = makeSyncFunction(this._applyToCoroutine.bind(this));
    this.uniqueId = _VertexData._UniqueIDGenerator;
    _VertexData._UniqueIDGenerator++;
  }
  /**
   * Uses the passed data array to set the set the values for the specified kind of data
   * @param data a linear array of floating numbers
   * @param kind the type of data that is being set, eg positions, colors etc
   */
  set(data, kind) {
    if (!data.length) {
      Logger.Warn(`Setting vertex data kind '${kind}' with an empty array`);
    }
    switch (kind) {
      case VertexBuffer.PositionKind:
        this.positions = data;
        break;
      case VertexBuffer.NormalKind:
        this.normals = data;
        break;
      case VertexBuffer.TangentKind:
        this.tangents = data;
        break;
      case VertexBuffer.UVKind:
        this.uvs = data;
        break;
      case VertexBuffer.UV2Kind:
        this.uvs2 = data;
        break;
      case VertexBuffer.UV3Kind:
        this.uvs3 = data;
        break;
      case VertexBuffer.UV4Kind:
        this.uvs4 = data;
        break;
      case VertexBuffer.UV5Kind:
        this.uvs5 = data;
        break;
      case VertexBuffer.UV6Kind:
        this.uvs6 = data;
        break;
      case VertexBuffer.ColorKind:
        this.colors = data;
        break;
      case VertexBuffer.MatricesIndicesKind:
        this.matricesIndices = data;
        break;
      case VertexBuffer.MatricesWeightsKind:
        this.matricesWeights = data;
        break;
      case VertexBuffer.MatricesIndicesExtraKind:
        this.matricesIndicesExtra = data;
        break;
      case VertexBuffer.MatricesWeightsExtraKind:
        this.matricesWeightsExtra = data;
        break;
    }
  }
  /**
   * Associates the vertexData to the passed Mesh.
   * Sets it as updatable or not (default `false`)
   * @param mesh the mesh the vertexData is applied to
   * @param updatable when used and having the value true allows new data to update the vertexData
   * @returns the VertexData
   */
  applyToMesh(mesh, updatable) {
    this._applyTo(mesh, updatable, false);
    return this;
  }
  /**
   * Associates the vertexData to the passed Geometry.
   * Sets it as updatable or not (default `false`)
   * @param geometry the geometry the vertexData is applied to
   * @param updatable when used and having the value true allows new data to update the vertexData
   * @returns VertexData
   */
  applyToGeometry(geometry, updatable) {
    this._applyTo(geometry, updatable, false);
    return this;
  }
  /**
   * Updates the associated mesh
   * @param mesh the mesh to be updated
   * @returns VertexData
   */
  updateMesh(mesh) {
    this._update(mesh);
    return this;
  }
  /**
   * Updates the associated geometry
   * @param geometry the geometry to be updated
   * @returns VertexData.
   */
  updateGeometry(geometry) {
    this._update(geometry);
    return this;
  }
  /**
   * @internal
   */
  *_applyToCoroutine(meshOrGeometry, updatable = false, isAsync) {
    if (this.positions) {
      meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.normals) {
      meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.tangents) {
      meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.uvs) {
      meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.uvs2) {
      meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.uvs3) {
      meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.uvs4) {
      meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.uvs5) {
      meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.uvs6) {
      meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.colors) {
      const stride = this.positions && this.colors.length === this.positions.length ? 3 : 4;
      meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable, stride);
      if (this.hasVertexAlpha && meshOrGeometry.hasVertexAlpha !== void 0) {
        meshOrGeometry.hasVertexAlpha = true;
      }
      if (isAsync) {
        yield;
      }
    }
    if (this.matricesIndices) {
      meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.matricesWeights) {
      meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.matricesIndicesExtra) {
      meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.matricesWeightsExtra) {
      meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);
      if (isAsync) {
        yield;
      }
    }
    if (this.indices) {
      meshOrGeometry.setIndices(this.indices, null, updatable);
      if (isAsync) {
        yield;
      }
    } else {
      meshOrGeometry.setIndices([], null);
    }
    if (meshOrGeometry.subMeshes && this.materialInfos && this.materialInfos.length > 1) {
      const mesh = meshOrGeometry;
      mesh.subMeshes = [];
      for (const matInfo of this.materialInfos) {
        new SubMesh(matInfo.materialIndex, matInfo.verticesStart, matInfo.verticesCount, matInfo.indexStart, matInfo.indexCount, mesh);
      }
    }
    return this;
  }
  _update(meshOrGeometry, updateExtends, makeItUnique) {
    if (this.positions) {
      meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);
    }
    if (this.normals) {
      meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);
    }
    if (this.tangents) {
      meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);
    }
    if (this.uvs) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);
    }
    if (this.uvs2) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);
    }
    if (this.uvs3) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);
    }
    if (this.uvs4) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);
    }
    if (this.uvs5) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);
    }
    if (this.uvs6) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);
    }
    if (this.colors) {
      meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);
    }
    if (this.matricesIndices) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);
    }
    if (this.matricesWeights) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);
    }
    if (this.matricesIndicesExtra) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);
    }
    if (this.matricesWeightsExtra) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);
    }
    if (this.indices) {
      meshOrGeometry.setIndices(this.indices, null);
    }
    return this;
  }
  static _TransformVector3Coordinates(coordinates, transformation, offset = 0, length = coordinates.length) {
    const coordinate = TmpVectors.Vector3[0];
    const transformedCoordinate = TmpVectors.Vector3[1];
    for (let index = offset; index < offset + length; index += 3) {
      Vector3.FromArrayToRef(coordinates, index, coordinate);
      Vector3.TransformCoordinatesToRef(coordinate, transformation, transformedCoordinate);
      coordinates[index] = transformedCoordinate.x;
      coordinates[index + 1] = transformedCoordinate.y;
      coordinates[index + 2] = transformedCoordinate.z;
    }
  }
  static _TransformVector3Normals(normals, transformation, offset = 0, length = normals.length) {
    const normal = TmpVectors.Vector3[0];
    const transformedNormal = TmpVectors.Vector3[1];
    for (let index = offset; index < offset + length; index += 3) {
      Vector3.FromArrayToRef(normals, index, normal);
      Vector3.TransformNormalToRef(normal, transformation, transformedNormal);
      normals[index] = transformedNormal.x;
      normals[index + 1] = transformedNormal.y;
      normals[index + 2] = transformedNormal.z;
    }
  }
  static _TransformVector4Normals(normals, transformation, offset = 0, length = normals.length) {
    const normal = TmpVectors.Vector4[0];
    const transformedNormal = TmpVectors.Vector4[1];
    for (let index = offset; index < offset + length; index += 4) {
      Vector4.FromArrayToRef(normals, index, normal);
      Vector4.TransformNormalToRef(normal, transformation, transformedNormal);
      normals[index] = transformedNormal.x;
      normals[index + 1] = transformedNormal.y;
      normals[index + 2] = transformedNormal.z;
      normals[index + 3] = transformedNormal.w;
    }
  }
  static _FlipFaces(indices, offset = 0, length = indices.length) {
    for (let index = offset; index < offset + length; index += 3) {
      const tmp = indices[index + 1];
      indices[index + 1] = indices[index + 2];
      indices[index + 2] = tmp;
    }
  }
  /**
   * Transforms each position and each normal of the vertexData according to the passed Matrix
   * @param matrix the transforming matrix
   * @returns the VertexData
   */
  transform(matrix) {
    const flip = matrix.determinant() < 0;
    if (this.positions) {
      _VertexData._TransformVector3Coordinates(this.positions, matrix);
    }
    if (this.normals) {
      _VertexData._TransformVector3Normals(this.normals, matrix);
    }
    if (this.tangents) {
      _VertexData._TransformVector4Normals(this.tangents, matrix);
    }
    if (flip && this.indices) {
      _VertexData._FlipFaces(this.indices);
    }
    return this;
  }
  /**
   * Generates an array of vertex data where each vertex data only has one material info
   * @returns An array of VertexData
   */
  splitBasedOnMaterialID() {
    if (!this.materialInfos || this.materialInfos.length < 2) {
      return [this];
    }
    const result = [];
    for (const materialInfo of this.materialInfos) {
      const vertexData = new _VertexData();
      if (this.positions) {
        vertexData.positions = this.positions.slice(materialInfo.verticesStart * 3, (materialInfo.verticesCount + materialInfo.verticesStart) * 3);
      }
      if (this.normals) {
        vertexData.normals = this.normals.slice(materialInfo.verticesStart * 3, (materialInfo.verticesCount + materialInfo.verticesStart) * 3);
      }
      if (this.tangents) {
        vertexData.tangents = this.tangents.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);
      }
      if (this.colors) {
        vertexData.colors = this.colors.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);
      }
      if (this.uvs) {
        vertexData.uvs = this.uvs.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);
      }
      if (this.uvs2) {
        vertexData.uvs2 = this.uvs2.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);
      }
      if (this.uvs3) {
        vertexData.uvs3 = this.uvs3.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);
      }
      if (this.uvs4) {
        vertexData.uvs4 = this.uvs4.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);
      }
      if (this.uvs5) {
        vertexData.uvs5 = this.uvs5.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);
      }
      if (this.uvs6) {
        vertexData.uvs6 = this.uvs6.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);
      }
      if (this.matricesIndices) {
        vertexData.matricesIndices = this.matricesIndices.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);
      }
      if (this.matricesIndicesExtra) {
        vertexData.matricesIndicesExtra = this.matricesIndicesExtra.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);
      }
      if (this.matricesWeights) {
        vertexData.matricesWeights = this.matricesWeights.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);
      }
      if (this.matricesWeightsExtra) {
        vertexData.matricesWeightsExtra = this.matricesWeightsExtra.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);
      }
      if (this.indices) {
        vertexData.indices = [];
        for (let index = materialInfo.indexStart; index < materialInfo.indexStart + materialInfo.indexCount; index++) {
          vertexData.indices.push(this.indices[index] - materialInfo.verticesStart);
        }
      }
      const newMaterialInfo = new VertexDataMaterialInfo();
      newMaterialInfo.indexStart = 0;
      newMaterialInfo.indexCount = vertexData.indices ? vertexData.indices.length : 0;
      newMaterialInfo.materialIndex = materialInfo.materialIndex;
      newMaterialInfo.verticesStart = 0;
      newMaterialInfo.verticesCount = (vertexData.positions ? vertexData.positions.length : 0) / 3;
      vertexData.materialInfos = [newMaterialInfo];
      result.push(vertexData);
    }
    return result;
  }
  /**
   * Merges the passed VertexData into the current one
   * @param others the VertexData to be merged into the current one
   * @param use32BitsIndices defines a boolean indicating if indices must be store in a 32 bits array
   * @param forceCloneIndices defines a boolean indicating if indices are forced to be cloned
   * @param mergeMaterialIds defines a boolean indicating if we need to merge the material infos
   * @param enableCompletion defines a boolean indicating if the vertex data should be completed to be compatible
   * @returns the modified VertexData
   */
  merge(others, use32BitsIndices = false, forceCloneIndices = false, mergeMaterialIds = false, enableCompletion = false) {
    const vertexDatas = Array.isArray(others) ? others.map((other) => {
      return { vertexData: other };
    }) : [{ vertexData: others }];
    return runCoroutineSync(this._mergeCoroutine(void 0, vertexDatas, use32BitsIndices, false, forceCloneIndices, mergeMaterialIds, enableCompletion));
  }
  /**
   * @internal
   */
  *_mergeCoroutine(transform, vertexDatas, use32BitsIndices = false, isAsync, forceCloneIndices, mergeMaterialIds = false, enableCompletion = false) {
    var _a, _b;
    this._validate();
    let others = vertexDatas.map((vertexData) => vertexData.vertexData);
    let root = this;
    if (enableCompletion) {
      for (const other of others) {
        if (!other) {
          continue;
        }
        other._validate();
        if (!this.normals && other.normals) {
          this.normals = new Float32Array(this.positions.length);
        }
        if (!this.tangents && other.tangents) {
          this.tangents = new Float32Array(this.positions.length / 3 * 4);
        }
        if (!this.uvs && other.uvs) {
          this.uvs = new Float32Array(this.positions.length / 3 * 2);
        }
        if (!this.uvs2 && other.uvs2) {
          this.uvs2 = new Float32Array(this.positions.length / 3 * 2);
        }
        if (!this.uvs3 && other.uvs3) {
          this.uvs3 = new Float32Array(this.positions.length / 3 * 2);
        }
        if (!this.uvs4 && other.uvs4) {
          this.uvs4 = new Float32Array(this.positions.length / 3 * 2);
        }
        if (!this.uvs5 && other.uvs5) {
          this.uvs5 = new Float32Array(this.positions.length / 3 * 2);
        }
        if (!this.uvs6 && other.uvs6) {
          this.uvs6 = new Float32Array(this.positions.length / 3 * 2);
        }
        if (!this.colors && other.colors) {
          this.colors = new Float32Array(this.positions.length / 3 * 4);
          this.colors.fill(1);
        }
        if (!this.matricesIndices && other.matricesIndices) {
          this.matricesIndices = new Float32Array(this.positions.length / 3 * 4);
        }
        if (!this.matricesWeights && other.matricesWeights) {
          this.matricesWeights = new Float32Array(this.positions.length / 3 * 4);
        }
        if (!this.matricesIndicesExtra && other.matricesIndicesExtra) {
          this.matricesIndicesExtra = new Float32Array(this.positions.length / 3 * 4);
        }
        if (!this.matricesWeightsExtra && other.matricesWeightsExtra) {
          this.matricesWeightsExtra = new Float32Array(this.positions.length / 3 * 4);
        }
      }
    }
    for (const other of others) {
      if (!other) {
        continue;
      }
      if (!enableCompletion) {
        other._validate();
        if (!this.normals !== !other.normals || !this.tangents !== !other.tangents || !this.uvs !== !other.uvs || !this.uvs2 !== !other.uvs2 || !this.uvs3 !== !other.uvs3 || !this.uvs4 !== !other.uvs4 || !this.uvs5 !== !other.uvs5 || !this.uvs6 !== !other.uvs6 || !this.colors !== !other.colors || !this.matricesIndices !== !other.matricesIndices || !this.matricesWeights !== !other.matricesWeights || !this.matricesIndicesExtra !== !other.matricesIndicesExtra || !this.matricesWeightsExtra !== !other.matricesWeightsExtra) {
          throw new Error("Cannot merge vertex data that do not have the same set of attributes");
        }
      } else {
        if (this.normals && !other.normals) {
          other.normals = new Float32Array(other.positions.length);
        }
        if (this.tangents && !other.tangents) {
          other.tangents = new Float32Array(other.positions.length / 3 * 4);
        }
        if (this.uvs && !other.uvs) {
          other.uvs = new Float32Array(other.positions.length / 3 * 2);
        }
        if (this.uvs2 && !other.uvs2) {
          other.uvs2 = new Float32Array(other.positions.length / 3 * 2);
        }
        if (this.uvs3 && !other.uvs3) {
          other.uvs3 = new Float32Array(other.positions.length / 3 * 2);
        }
        if (this.uvs4 && !other.uvs4) {
          other.uvs4 = new Float32Array(other.positions.length / 3 * 2);
        }
        if (this.uvs5 && !other.uvs5) {
          other.uvs5 = new Float32Array(other.positions.length / 3 * 2);
        }
        if (this.uvs6 && !other.uvs6) {
          other.uvs6 = new Float32Array(other.positions.length / 3 * 2);
        }
        if (this.colors && !other.colors) {
          other.colors = new Float32Array(other.positions.length / 3 * 4);
          other.colors.fill(1);
        }
        if (this.matricesIndices && !other.matricesIndices) {
          other.matricesIndices = new Float32Array(other.positions.length / 3 * 4);
        }
        if (this.matricesWeights && !other.matricesWeights) {
          other.matricesWeights = new Float32Array(other.positions.length / 3 * 4);
        }
        if (this.matricesIndicesExtra && !other.matricesIndicesExtra) {
          other.matricesIndicesExtra = new Float32Array(other.positions.length / 3 * 4);
        }
        if (this.matricesWeightsExtra && !other.matricesWeightsExtra) {
          other.matricesWeightsExtra = new Float32Array(other.positions.length / 3 * 4);
        }
      }
    }
    if (mergeMaterialIds) {
      let materialIndex = 0;
      let indexOffset = 0;
      let vertexOffset = 0;
      const materialInfos = [];
      let currentMaterialInfo = null;
      const vertexDataList = [];
      for (const split of this.splitBasedOnMaterialID()) {
        vertexDataList.push({ vertexData: split, transform });
      }
      for (const data of vertexDatas) {
        if (!data.vertexData) {
          continue;
        }
        for (const split of data.vertexData.splitBasedOnMaterialID()) {
          vertexDataList.push({ vertexData: split, transform: data.transform });
        }
      }
      vertexDataList.sort((a, b) => {
        const matInfoA = a.vertexData.materialInfos ? a.vertexData.materialInfos[0].materialIndex : 0;
        const matInfoB = b.vertexData.materialInfos ? b.vertexData.materialInfos[0].materialIndex : 0;
        if (matInfoA > matInfoB) {
          return 1;
        }
        if (matInfoA === matInfoB) {
          return 0;
        }
        return -1;
      });
      for (const vertexDataSource of vertexDataList) {
        const vertexData = vertexDataSource.vertexData;
        if (vertexData.materialInfos) {
          materialIndex = vertexData.materialInfos[0].materialIndex;
        } else {
          materialIndex = 0;
        }
        if (currentMaterialInfo && currentMaterialInfo.materialIndex === materialIndex) {
          currentMaterialInfo.indexCount += vertexData.indices.length;
          currentMaterialInfo.verticesCount += vertexData.positions.length / 3;
        } else {
          const materialInfo = new VertexDataMaterialInfo();
          materialInfo.materialIndex = materialIndex;
          materialInfo.indexStart = indexOffset;
          materialInfo.indexCount = vertexData.indices.length;
          materialInfo.verticesStart = vertexOffset;
          materialInfo.verticesCount = vertexData.positions.length / 3;
          materialInfos.push(materialInfo);
          currentMaterialInfo = materialInfo;
        }
        indexOffset += vertexData.indices.length;
        vertexOffset += vertexData.positions.length / 3;
      }
      const first = vertexDataList.splice(0, 1)[0];
      root = first.vertexData;
      transform = first.transform;
      others = vertexDataList.map((v) => v.vertexData);
      vertexDatas = vertexDataList;
      this.materialInfos = materialInfos;
    }
    const totalIndices = others.reduce((indexSum, vertexData) => {
      var _a2;
      return indexSum + (((_a2 = vertexData.indices) == null ? void 0 : _a2.length) ?? 0);
    }, ((_a = root.indices) == null ? void 0 : _a.length) ?? 0);
    const sliceIndices = forceCloneIndices || others.some((vertexData) => vertexData.indices === root.indices);
    let indices = sliceIndices ? (_b = root.indices) == null ? void 0 : _b.slice() : root.indices;
    if (totalIndices > 0) {
      let indicesOffset = (indices == null ? void 0 : indices.length) ?? 0;
      if (!indices) {
        indices = new Array(totalIndices);
      }
      if (indices.length !== totalIndices) {
        if (Array.isArray(indices)) {
          indices.length = totalIndices;
        } else {
          const temp = use32BitsIndices || indices instanceof Uint32Array ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices);
          temp.set(indices);
          indices = temp;
        }
        if (transform && transform.determinant() < 0) {
          _VertexData._FlipFaces(indices, 0, indicesOffset);
        }
      }
      let positionsOffset = root.positions ? root.positions.length / 3 : 0;
      for (const { vertexData: other, transform: transform2 } of vertexDatas) {
        if (other.indices) {
          for (let index = 0; index < other.indices.length; index++) {
            indices[indicesOffset + index] = other.indices[index] + positionsOffset;
          }
          if (transform2 && transform2.determinant() < 0) {
            _VertexData._FlipFaces(indices, indicesOffset, other.indices.length);
          }
          positionsOffset += other.positions.length / 3;
          indicesOffset += other.indices.length;
          if (isAsync) {
            yield;
          }
        }
      }
    }
    this.indices = indices;
    this.positions = _VertexData._MergeElement(VertexBuffer.PositionKind, root.positions, transform, vertexDatas.map((other) => [other.vertexData.positions, other.transform]));
    if (isAsync) {
      yield;
    }
    if (root.normals) {
      this.normals = _VertexData._MergeElement(VertexBuffer.NormalKind, root.normals, transform, vertexDatas.map((other) => [other.vertexData.normals, other.transform]));
      if (isAsync) {
        yield;
      }
    }
    if (root.tangents) {
      this.tangents = _VertexData._MergeElement(VertexBuffer.TangentKind, root.tangents, transform, vertexDatas.map((other) => [other.vertexData.tangents, other.transform]));
      if (isAsync) {
        yield;
      }
    }
    if (root.uvs) {
      this.uvs = _VertexData._MergeElement(VertexBuffer.UVKind, root.uvs, transform, vertexDatas.map((other) => [other.vertexData.uvs, other.transform]));
      if (isAsync) {
        yield;
      }
    }
    if (root.uvs2) {
      this.uvs2 = _VertexData._MergeElement(VertexBuffer.UV2Kind, root.uvs2, transform, vertexDatas.map((other) => [other.vertexData.uvs2, other.transform]));
      if (isAsync) {
        yield;
      }
    }
    if (root.uvs3) {
      this.uvs3 = _VertexData._MergeElement(VertexBuffer.UV3Kind, root.uvs3, transform, vertexDatas.map((other) => [other.vertexData.uvs3, other.transform]));
      if (isAsync) {
        yield;
      }
    }
    if (root.uvs4) {
      this.uvs4 = _VertexData._MergeElement(VertexBuffer.UV4Kind, root.uvs4, transform, vertexDatas.map((other) => [other.vertexData.uvs4, other.transform]));
      if (isAsync) {
        yield;
      }
    }
    if (root.uvs5) {
      this.uvs5 = _VertexData._MergeElement(VertexBuffer.UV5Kind, root.uvs5, transform, vertexDatas.map((other) => [other.vertexData.uvs5, other.transform]));
      if (isAsync) {
        yield;
      }
    }
    if (root.uvs6) {
      this.uvs6 = _VertexData._MergeElement(VertexBuffer.UV6Kind, root.uvs6, transform, vertexDatas.map((other) => [other.vertexData.uvs6, other.transform]));
      if (isAsync) {
        yield;
      }
    }
    if (root.colors) {
      this.colors = _VertexData._MergeElement(VertexBuffer.ColorKind, root.colors, transform, vertexDatas.map((other) => [other.vertexData.colors, other.transform]));
      if (root.hasVertexAlpha !== void 0 || vertexDatas.some((other) => other.vertexData.hasVertexAlpha !== void 0)) {
        this.hasVertexAlpha = root.hasVertexAlpha || vertexDatas.some((other) => other.vertexData.hasVertexAlpha);
      }
      if (isAsync) {
        yield;
      }
    }
    if (root.matricesIndices) {
      this.matricesIndices = _VertexData._MergeElement(VertexBuffer.MatricesIndicesKind, root.matricesIndices, transform, vertexDatas.map((other) => [other.vertexData.matricesIndices, other.transform]));
      if (isAsync) {
        yield;
      }
    }
    if (root.matricesWeights) {
      this.matricesWeights = _VertexData._MergeElement(VertexBuffer.MatricesWeightsKind, root.matricesWeights, transform, vertexDatas.map((other) => [other.vertexData.matricesWeights, other.transform]));
      if (isAsync) {
        yield;
      }
    }
    if (root.matricesIndicesExtra) {
      this.matricesIndicesExtra = _VertexData._MergeElement(VertexBuffer.MatricesIndicesExtraKind, root.matricesIndicesExtra, transform, vertexDatas.map((other) => [other.vertexData.matricesIndicesExtra, other.transform]));
      if (isAsync) {
        yield;
      }
    }
    if (root.matricesWeightsExtra) {
      this.matricesWeightsExtra = _VertexData._MergeElement(VertexBuffer.MatricesWeightsExtraKind, root.matricesWeightsExtra, transform, vertexDatas.map((other) => [other.vertexData.matricesWeightsExtra, other.transform]));
    }
    return this;
  }
  static _MergeElement(kind, source, transform, others) {
    const nonNullOthers = others.filter((other) => other[0] !== null && other[0] !== void 0);
    if (!source && nonNullOthers.length == 0) {
      return source;
    }
    if (!source) {
      return this._MergeElement(kind, nonNullOthers[0][0], nonNullOthers[0][1], nonNullOthers.slice(1));
    }
    const len = nonNullOthers.reduce((sumLen, elements) => sumLen + elements[0].length, source.length);
    const transformRange = kind === VertexBuffer.PositionKind ? _VertexData._TransformVector3Coordinates : kind === VertexBuffer.NormalKind ? _VertexData._TransformVector3Normals : kind === VertexBuffer.TangentKind ? _VertexData._TransformVector4Normals : () => {
    };
    if (source instanceof Float32Array) {
      const ret32 = new Float32Array(len);
      ret32.set(source);
      transform && transformRange(ret32, transform, 0, source.length);
      let offset = source.length;
      for (const [vertexData, transform2] of nonNullOthers) {
        ret32.set(vertexData, offset);
        transform2 && transformRange(ret32, transform2, offset, vertexData.length);
        offset += vertexData.length;
      }
      return ret32;
    } else {
      const ret = new Array(len);
      for (let i = 0; i < source.length; i++) {
        ret[i] = source[i];
      }
      transform && transformRange(ret, transform, 0, source.length);
      let offset = source.length;
      for (const [vertexData, transform2] of nonNullOthers) {
        for (let i = 0; i < vertexData.length; i++) {
          ret[offset + i] = vertexData[i];
        }
        transform2 && transformRange(ret, transform2, offset, vertexData.length);
        offset += vertexData.length;
      }
      return ret;
    }
  }
  _validate() {
    if (!this.positions) {
      throw new RuntimeError("Positions are required", ErrorCodes.MeshInvalidPositionsError);
    }
    const getElementCount = (kind, values) => {
      const stride = VertexBuffer.DeduceStride(kind);
      if (values.length % stride !== 0) {
        throw new Error("The " + kind + "s array count must be a multiple of " + stride);
      }
      return values.length / stride;
    };
    const positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);
    const validateElementCount = (kind, values) => {
      const elementCount = getElementCount(kind, values);
      if (elementCount !== positionsElementCount) {
        throw new Error("The " + kind + "s element count (" + elementCount + ") does not match the positions count (" + positionsElementCount + ")");
      }
    };
    if (this.normals) {
      validateElementCount(VertexBuffer.NormalKind, this.normals);
    }
    if (this.tangents) {
      validateElementCount(VertexBuffer.TangentKind, this.tangents);
    }
    if (this.uvs) {
      validateElementCount(VertexBuffer.UVKind, this.uvs);
    }
    if (this.uvs2) {
      validateElementCount(VertexBuffer.UV2Kind, this.uvs2);
    }
    if (this.uvs3) {
      validateElementCount(VertexBuffer.UV3Kind, this.uvs3);
    }
    if (this.uvs4) {
      validateElementCount(VertexBuffer.UV4Kind, this.uvs4);
    }
    if (this.uvs5) {
      validateElementCount(VertexBuffer.UV5Kind, this.uvs5);
    }
    if (this.uvs6) {
      validateElementCount(VertexBuffer.UV6Kind, this.uvs6);
    }
    if (this.colors) {
      validateElementCount(VertexBuffer.ColorKind, this.colors);
    }
    if (this.matricesIndices) {
      validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices);
    }
    if (this.matricesWeights) {
      validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights);
    }
    if (this.matricesIndicesExtra) {
      validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra);
    }
    if (this.matricesWeightsExtra) {
      validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra);
    }
  }
  /**
   * Clone the current vertex data
   * @returns a copy of the current data
   */
  clone() {
    const serializationObject = this.serialize();
    return _VertexData.Parse(serializationObject);
  }
  /**
   * Serializes the VertexData
   * @returns a serialized object
   */
  serialize() {
    const serializationObject = {};
    if (this.positions) {
      serializationObject.positions = Array.from(this.positions);
    }
    if (this.normals) {
      serializationObject.normals = Array.from(this.normals);
    }
    if (this.tangents) {
      serializationObject.tangents = Array.from(this.tangents);
    }
    if (this.uvs) {
      serializationObject.uvs = Array.from(this.uvs);
    }
    if (this.uvs2) {
      serializationObject.uvs2 = Array.from(this.uvs2);
    }
    if (this.uvs3) {
      serializationObject.uvs3 = Array.from(this.uvs3);
    }
    if (this.uvs4) {
      serializationObject.uvs4 = Array.from(this.uvs4);
    }
    if (this.uvs5) {
      serializationObject.uvs5 = Array.from(this.uvs5);
    }
    if (this.uvs6) {
      serializationObject.uvs6 = Array.from(this.uvs6);
    }
    if (this.colors) {
      serializationObject.colors = Array.from(this.colors);
      serializationObject.hasVertexAlpha = this.hasVertexAlpha;
    }
    if (this.matricesIndices) {
      serializationObject.matricesIndices = Array.from(this.matricesIndices);
      serializationObject.matricesIndices._isExpanded = true;
    }
    if (this.matricesWeights) {
      serializationObject.matricesWeights = Array.from(this.matricesWeights);
    }
    if (this.matricesIndicesExtra) {
      serializationObject.matricesIndicesExtra = Array.from(this.matricesIndicesExtra);
      serializationObject.matricesIndicesExtra._isExpanded = true;
    }
    if (this.matricesWeightsExtra) {
      serializationObject.matricesWeightsExtra = Array.from(this.matricesWeightsExtra);
    }
    serializationObject.indices = this.indices ? Array.from(this.indices) : [];
    if (this.materialInfos) {
      serializationObject.materialInfos = [];
      for (const materialInfo of this.materialInfos) {
        const materialInfoSerializationObject = {
          indexStart: materialInfo.indexStart,
          indexCount: materialInfo.indexCount,
          materialIndex: materialInfo.materialIndex,
          verticesStart: materialInfo.verticesStart,
          verticesCount: materialInfo.verticesCount
        };
        serializationObject.materialInfos.push(materialInfoSerializationObject);
      }
    }
    return serializationObject;
  }
  // Statics
  /**
   * Extracts the vertexData from a mesh
   * @param mesh the mesh from which to extract the VertexData
   * @param copyWhenShared defines if the VertexData must be cloned when shared between multiple meshes, optional, default false
   * @param forceCopy indicating that the VertexData must be cloned, optional, default false
   * @returns the object VertexData associated to the passed mesh
   */
  static ExtractFromMesh(mesh, copyWhenShared, forceCopy) {
    return _VertexData._ExtractFrom(mesh, copyWhenShared, forceCopy);
  }
  /**
   * Extracts the vertexData from the geometry
   * @param geometry the geometry from which to extract the VertexData
   * @param copyWhenShared defines if the VertexData must be cloned when the geometry is shared between multiple meshes, optional, default false
   * @param forceCopy indicating that the VertexData must be cloned, optional, default false
   * @returns the object VertexData associated to the passed mesh
   */
  static ExtractFromGeometry(geometry, copyWhenShared, forceCopy) {
    return _VertexData._ExtractFrom(geometry, copyWhenShared, forceCopy);
  }
  static _ExtractFrom(meshOrGeometry, copyWhenShared, forceCopy) {
    const result = new _VertexData();
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {
      result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {
      result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {
      result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
      result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {
      result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {
      result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {
      result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {
      result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {
      const geometry = meshOrGeometry.geometry || meshOrGeometry;
      const vertexBuffer = geometry.getVertexBuffer(VertexBuffer.ColorKind);
      const colors = geometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy);
      if (vertexBuffer.getSize() === 3) {
        const newColors = new Float32Array(colors.length * 4 / 3);
        for (let i = 0, j = 0; i < colors.length; i += 3, j += 4) {
          newColors[j] = colors[i];
          newColors[j + 1] = colors[i + 1];
          newColors[j + 2] = colors[i + 2];
          newColors[j + 3] = 1;
        }
        result.colors = newColors;
      } else if (vertexBuffer.getSize() === 4) {
        result.colors = colors;
      } else {
        throw new Error(`Unexpected number of color components: ${vertexBuffer.getSize()}`);
      }
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {
      result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
      result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {
      result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {
      result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);
    }
    result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);
    return result;
  }
  /**
   * Creates the VertexData for a Ribbon
   * @param options an object used to set the following optional parameters for the ribbon, required but can be empty
   * * pathArray array of paths, each of which an array of successive Vector3
   * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false
   * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false
   * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false
   * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional
   * * colors a linear array, of length 4 * number of vertices, of custom color values, optional
   * @returns the VertexData of the ribbon
   * @deprecated use CreateRibbonVertexData instead
   */
  static CreateRibbon(options) {
    throw _WarnImport("ribbonBuilder");
  }
  /**
   * Creates the VertexData for a box
   * @param options an object used to set the following optional parameters for the box, required but can be empty
   * * size sets the width, height and depth of the box to the value of size, optional default 1
   * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size
   * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size
   * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size
   * * faceUV an array of 6 Vector4 elements used to set different images to each box side
   * * faceColors an array of 6 Color3 elements used to set different colors to each box side
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * @returns the VertexData of the box
   * @deprecated Please use CreateBoxVertexData from the BoxBuilder file instead
   */
  static CreateBox(options) {
    throw _WarnImport("boxBuilder");
  }
  /**
   * Creates the VertexData for a tiled box
   * @param options an object used to set the following optional parameters for the box, required but can be empty
   * * faceTiles sets the pattern, tile size and number of tiles for a face
   * * faceUV an array of 6 Vector4 elements used to set different images to each box side
   * * faceColors an array of 6 Color3 elements used to set different colors to each box side
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * @param options.pattern
   * @param options.width
   * @param options.height
   * @param options.depth
   * @param options.tileSize
   * @param options.tileWidth
   * @param options.tileHeight
   * @param options.alignHorizontal
   * @param options.alignVertical
   * @param options.faceUV
   * @param options.faceColors
   * @param options.sideOrientation
   * @returns the VertexData of the box
   * @deprecated Please use CreateTiledBoxVertexData instead
   */
  static CreateTiledBox(options) {
    throw _WarnImport("tiledBoxBuilder");
  }
  /**
   * Creates the VertexData for a tiled plane
   * @param options an object used to set the following optional parameters for the box, required but can be empty
   * * pattern a limited pattern arrangement depending on the number
   * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1
   * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size
   * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * @returns the VertexData of the tiled plane
   * @deprecated use CreateTiledPlaneVertexData instead
   */
  static CreateTiledPlane(options) {
    throw _WarnImport("tiledPlaneBuilder");
  }
  /**
   * Creates the VertexData for an ellipsoid, defaults to a sphere
   * @param options an object used to set the following optional parameters for the box, required but can be empty
   * * segments sets the number of horizontal strips optional, default 32
   * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1
   * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter
   * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter
   * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter
   * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1
   * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * @returns the VertexData of the ellipsoid
   * @deprecated use CreateSphereVertexData instead
   */
  static CreateSphere(options) {
    throw _WarnImport("sphereBuilder");
  }
  /**
   * Creates the VertexData for a cylinder, cone or prism
   * @param options an object used to set the following optional parameters for the box, required but can be empty
   * * height sets the height (y direction) of the cylinder, optional, default 2
   * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter
   * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter
   * * diameter sets the diameter of the top and bottom of the cone, optional default 1
   * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24
   * * subdivisions` the number of rings along the cylinder height, optional, default 1
   * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1
   * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively
   * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively
   * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false
   * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * @returns the VertexData of the cylinder, cone or prism
   * @deprecated please use CreateCylinderVertexData instead
   */
  static CreateCylinder(options) {
    throw _WarnImport("cylinderBuilder");
  }
  /**
   * Creates the VertexData for a torus
   * @param options an object used to set the following optional parameters for the box, required but can be empty
   * * diameter the diameter of the torus, optional default 1
   * * thickness the diameter of the tube forming the torus, optional default 0.5
   * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * @returns the VertexData of the torus
   * @deprecated use CreateTorusVertexData instead
   */
  static CreateTorus(options) {
    throw _WarnImport("torusBuilder");
  }
  /**
   * Creates the VertexData of the LineSystem
   * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty
   *  - lines an array of lines, each line being an array of successive Vector3
   *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point
   * @returns the VertexData of the LineSystem
   * @deprecated use CreateLineSystemVertexData instead
   */
  static CreateLineSystem(options) {
    throw _WarnImport("linesBuilder");
  }
  /**
   * Create the VertexData for a DashedLines
   * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty
   *  - points an array successive Vector3
   *  - dashSize the size of the dashes relative to the dash number, optional, default 3
   *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1
   *  - dashNb the intended total number of dashes, optional, default 200
   * @returns the VertexData for the DashedLines
   * @deprecated use CreateDashedLinesVertexData instead
   */
  static CreateDashedLines(options) {
    throw _WarnImport("linesBuilder");
  }
  /**
   * Creates the VertexData for a Ground
   * @param options an object used to set the following optional parameters for the Ground, required but can be empty
   *  - width the width (x direction) of the ground, optional, default 1
   *  - height the height (z direction) of the ground, optional, default 1
   *  - subdivisions the number of subdivisions per side, optional, default 1
   * @returns the VertexData of the Ground
   * @deprecated Please use CreateGroundVertexData instead
   */
  static CreateGround(options) {
    throw _WarnImport("groundBuilder");
  }
  /**
   * Creates the VertexData for a TiledGround by subdividing the ground into tiles
   * @param options an object used to set the following optional parameters for the Ground, required but can be empty
   * * xmin the ground minimum X coordinate, optional, default -1
   * * zmin the ground minimum Z coordinate, optional, default -1
   * * xmax the ground maximum X coordinate, optional, default 1
   * * zmax the ground maximum Z coordinate, optional, default 1
   * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}
   * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}
   * @returns the VertexData of the TiledGround
   * @deprecated use CreateTiledGroundVertexData instead
   */
  static CreateTiledGround(options) {
    throw _WarnImport("groundBuilder");
  }
  /**
   * Creates the VertexData of the Ground designed from a heightmap
   * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap
   * * width the width (x direction) of the ground
   * * height the height (z direction) of the ground
   * * subdivisions the number of subdivisions per side
   * * minHeight the minimum altitude on the ground, optional, default 0
   * * maxHeight the maximum altitude on the ground, optional default 1
   * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)
   * * buffer the array holding the image color data
   * * bufferWidth the width of image
   * * bufferHeight the height of image
   * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)
   * @returns the VertexData of the Ground designed from a heightmap
   * @deprecated use CreateGroundFromHeightMapVertexData instead
   */
  static CreateGroundFromHeightMap(options) {
    throw _WarnImport("groundBuilder");
  }
  /**
   * Creates the VertexData for a Plane
   * @param options an object used to set the following optional parameters for the plane, required but can be empty
   * * size sets the width and height of the plane to the value of size, optional default 1
   * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size
   * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * @returns the VertexData of the box
   * @deprecated use CreatePlaneVertexData instead
   */
  static CreatePlane(options) {
    throw _WarnImport("planeBuilder");
  }
  /**
   * Creates the VertexData of the Disc or regular Polygon
   * @param options an object used to set the following optional parameters for the disc, required but can be empty
   * * radius the radius of the disc, optional default 0.5
   * * tessellation the number of polygon sides, optional, default 64
   * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * @returns the VertexData of the box
   * @deprecated use CreateDiscVertexData instead
   */
  static CreateDisc(options) {
    throw _WarnImport("discBuilder");
  }
  /**
   * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()
   * All parameters are provided by CreatePolygon as needed
   * @param polygon a mesh built from polygonTriangulation.build()
   * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively
   * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively
   * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * @param wrap a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side
   * @returns the VertexData of the Polygon
   * @deprecated use CreatePolygonVertexData instead
   */
  static CreatePolygon(polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrap) {
    throw _WarnImport("polygonBuilder");
  }
  /**
   * Creates the VertexData of the IcoSphere
   * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty
   * * radius the radius of the IcoSphere, optional default 1
   * * radiusX allows stretching in the x direction, optional, default radius
   * * radiusY allows stretching in the y direction, optional, default radius
   * * radiusZ allows stretching in the z direction, optional, default radius
   * * flat when true creates a flat shaded mesh, optional, default true
   * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * @returns the VertexData of the IcoSphere
   * @deprecated use CreateIcoSphereVertexData instead
   */
  static CreateIcoSphere(options) {
    throw _WarnImport("icoSphereBuilder");
  }
  // inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html
  /**
   * Creates the VertexData for a Polyhedron
   * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty
   * * type provided types are:
   *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)
   *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)
   * * size the size of the IcoSphere, optional default 1
   * * sizeX allows stretching in the x direction, optional, default size
   * * sizeY allows stretching in the y direction, optional, default size
   * * sizeZ allows stretching in the z direction, optional, default size
   * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor
   * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively
   * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively
   * * flat when true creates a flat shaded mesh, optional, default true
   * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * @returns the VertexData of the Polyhedron
   * @deprecated use CreatePolyhedronVertexData instead
   */
  static CreatePolyhedron(options) {
    throw _WarnImport("polyhedronBuilder");
  }
  /**
   * Creates the VertexData for a Capsule, inspired from https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js
   * @param options an object used to set the following optional parameters for the capsule, required but can be empty
   * @returns the VertexData of the Capsule
   * @deprecated Please use CreateCapsuleVertexData from the capsuleBuilder file instead
   */
  static CreateCapsule(options = {
    orientation: Vector3.Up(),
    subdivisions: 2,
    tessellation: 16,
    height: 1,
    radius: 0.25,
    capSubdivisions: 6
  }) {
    throw _WarnImport("capsuleBuilder");
  }
  // based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
  /**
   * Creates the VertexData for a TorusKnot
   * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty
   * * radius the radius of the torus knot, optional, default 2
   * * tube the thickness of the tube, optional, default 0.5
   * * radialSegments the number of sides on each tube segments, optional, default 32
   * * tubularSegments the number of tubes to decompose the knot into, optional, default 32
   * * p the number of windings around the z axis, optional,  default 2
   * * q the number of windings around the x axis, optional,  default 3
   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
   * @returns the VertexData of the Torus Knot
   * @deprecated use CreateTorusKnotVertexData instead
   */
  static CreateTorusKnot(options) {
    throw _WarnImport("torusKnotBuilder");
  }
  // Tools
  /**
   * Compute normals for given positions and indices
   * @param positions an array of vertex positions, [...., x, y, z, ......]
   * @param indices an array of indices in groups of three for each triangular facet, [...., i, j, k, ......]
   * @param normals an array of vertex normals, [...., x, y, z, ......]
   * @param options an object used to set the following optional parameters for the TorusKnot, optional
   * * facetNormals : optional array of facet normals (vector3)
   * * facetPositions : optional array of facet positions (vector3)
   * * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation
   * * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation
   * * bInfo : optional bounding info, required for facetPartitioning computation
   * * bbSize : optional bounding box size data, required for facetPartitioning computation
   * * subDiv : optional partitioning data about subdivisions on  each axis (int), required for facetPartitioning computation
   * * useRightHandedSystem: optional boolean to for right handed system computation
   * * depthSort : optional boolean to enable the facet depth sort computation
   * * distanceTo : optional Vector3 to compute the facet depth from this location
   * * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location
   */
  static ComputeNormals(positions, indices, normals, options) {
    let index = 0;
    let p1p2x = 0;
    let p1p2y = 0;
    let p1p2z = 0;
    let p3p2x = 0;
    let p3p2y = 0;
    let p3p2z = 0;
    let faceNormalx = 0;
    let faceNormaly = 0;
    let faceNormalz = 0;
    let length = 0;
    let v1x = 0;
    let v1y = 0;
    let v1z = 0;
    let v2x = 0;
    let v2y = 0;
    let v2z = 0;
    let v3x = 0;
    let v3y = 0;
    let v3z = 0;
    let computeFacetNormals = false;
    let computeFacetPositions = false;
    let computeFacetPartitioning = false;
    let computeDepthSort = false;
    let faceNormalSign = 1;
    let ratio = 0;
    let distanceTo = null;
    if (options) {
      computeFacetNormals = options.facetNormals ? true : false;
      computeFacetPositions = options.facetPositions ? true : false;
      computeFacetPartitioning = options.facetPartitioning ? true : false;
      faceNormalSign = options.useRightHandedSystem === true ? -1 : 1;
      ratio = options.ratio || 0;
      computeDepthSort = options.depthSort ? true : false;
      distanceTo = options.distanceTo;
      if (computeDepthSort) {
        if (distanceTo === void 0) {
          distanceTo = Vector3.Zero();
        }
      }
    }
    let xSubRatio = 0;
    let ySubRatio = 0;
    let zSubRatio = 0;
    let subSq = 0;
    if (computeFacetPartitioning && options && options.bbSize) {
      xSubRatio = options.subDiv.X * ratio / options.bbSize.x;
      ySubRatio = options.subDiv.Y * ratio / options.bbSize.y;
      zSubRatio = options.subDiv.Z * ratio / options.bbSize.z;
      subSq = options.subDiv.max * options.subDiv.max;
      options.facetPartitioning.length = 0;
    }
    for (index = 0; index < positions.length; index++) {
      normals[index] = 0;
    }
    const nbFaces = indices.length / 3 | 0;
    for (index = 0; index < nbFaces; index++) {
      v1x = indices[index * 3] * 3;
      v1y = v1x + 1;
      v1z = v1x + 2;
      v2x = indices[index * 3 + 1] * 3;
      v2y = v2x + 1;
      v2z = v2x + 2;
      v3x = indices[index * 3 + 2] * 3;
      v3y = v3x + 1;
      v3z = v3x + 2;
      p1p2x = positions[v1x] - positions[v2x];
      p1p2y = positions[v1y] - positions[v2y];
      p1p2z = positions[v1z] - positions[v2z];
      p3p2x = positions[v3x] - positions[v2x];
      p3p2y = positions[v3y] - positions[v2y];
      p3p2z = positions[v3z] - positions[v2z];
      faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);
      faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);
      faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x);
      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);
      length = length === 0 ? 1 : length;
      faceNormalx /= length;
      faceNormaly /= length;
      faceNormalz /= length;
      if (computeFacetNormals && options) {
        options.facetNormals[index].x = faceNormalx;
        options.facetNormals[index].y = faceNormaly;
        options.facetNormals[index].z = faceNormalz;
      }
      if (computeFacetPositions && options) {
        options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3;
        options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3;
        options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3;
      }
      if (computeFacetPartitioning && options) {
        const ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);
        const oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);
        const oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);
        const b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);
        const b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);
        const b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);
        const b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);
        const b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);
        const b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);
        const b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);
        const b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);
        const b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);
        const block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;
        const block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;
        const block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;
        const block_idx_o = ox + options.subDiv.max * oy + subSq * oz;
        options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();
        options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();
        options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();
        options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array();
        options.facetPartitioning[block_idx_v1].push(index);
        if (block_idx_v2 != block_idx_v1) {
          options.facetPartitioning[block_idx_v2].push(index);
        }
        if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {
          options.facetPartitioning[block_idx_v3].push(index);
        }
        if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {
          options.facetPartitioning[block_idx_o].push(index);
        }
      }
      if (computeDepthSort && options && options.facetPositions) {
        const dsf = options.depthSortedFacets[index];
        dsf.ind = index * 3;
        dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo);
      }
      normals[v1x] += faceNormalx;
      normals[v1y] += faceNormaly;
      normals[v1z] += faceNormalz;
      normals[v2x] += faceNormalx;
      normals[v2y] += faceNormaly;
      normals[v2z] += faceNormalz;
      normals[v3x] += faceNormalx;
      normals[v3y] += faceNormaly;
      normals[v3z] += faceNormalz;
    }
    for (index = 0; index < normals.length / 3; index++) {
      faceNormalx = normals[index * 3];
      faceNormaly = normals[index * 3 + 1];
      faceNormalz = normals[index * 3 + 2];
      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);
      length = length === 0 ? 1 : length;
      faceNormalx /= length;
      faceNormaly /= length;
      faceNormalz /= length;
      normals[index * 3] = faceNormalx;
      normals[index * 3 + 1] = faceNormaly;
      normals[index * 3 + 2] = faceNormalz;
    }
  }
  /**
   * @internal
   */
  static _ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs) {
    const li = indices.length;
    const ln = normals.length;
    let i;
    let n;
    sideOrientation = sideOrientation || _VertexData.DEFAULTSIDE;
    switch (sideOrientation) {
      case _VertexData.FRONTSIDE:
        break;
      case _VertexData.BACKSIDE:
        for (i = 0; i < li; i += 3) {
          const tmp = indices[i];
          indices[i] = indices[i + 2];
          indices[i + 2] = tmp;
        }
        for (n = 0; n < ln; n++) {
          normals[n] = -normals[n];
        }
        break;
      case _VertexData.DOUBLESIDE: {
        const lp = positions.length;
        const l = lp / 3;
        for (let p = 0; p < lp; p++) {
          positions[lp + p] = positions[p];
        }
        for (i = 0; i < li; i += 3) {
          indices[i + li] = indices[i + 2] + l;
          indices[i + 1 + li] = indices[i + 1] + l;
          indices[i + 2 + li] = indices[i] + l;
        }
        for (n = 0; n < ln; n++) {
          normals[ln + n] = -normals[n];
        }
        const lu = uvs.length;
        let u = 0;
        for (u = 0; u < lu; u++) {
          uvs[u + lu] = uvs[u];
        }
        frontUVs = frontUVs ? frontUVs : new Vector4(0, 0, 1, 1);
        backUVs = backUVs ? backUVs : new Vector4(0, 0, 1, 1);
        u = 0;
        for (i = 0; i < lu / 2; i++) {
          uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];
          uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];
          uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];
          uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];
          u += 2;
        }
        break;
      }
    }
  }
  /**
   * Creates a VertexData from serialized data
   * @param parsedVertexData the parsed data from an imported file
   * @returns a VertexData
   */
  static Parse(parsedVertexData) {
    const vertexData = new _VertexData();
    const positions = parsedVertexData.positions;
    if (positions) {
      vertexData.set(positions, VertexBuffer.PositionKind);
    }
    const normals = parsedVertexData.normals;
    if (normals) {
      vertexData.set(normals, VertexBuffer.NormalKind);
    }
    const tangents = parsedVertexData.tangents;
    if (tangents) {
      vertexData.set(tangents, VertexBuffer.TangentKind);
    }
    const uvs = parsedVertexData.uvs;
    if (uvs) {
      vertexData.set(uvs, VertexBuffer.UVKind);
    }
    const uvs2 = parsedVertexData.uvs2;
    if (uvs2) {
      vertexData.set(uvs2, VertexBuffer.UV2Kind);
    }
    const uvs3 = parsedVertexData.uvs3;
    if (uvs3) {
      vertexData.set(uvs3, VertexBuffer.UV3Kind);
    }
    const uvs4 = parsedVertexData.uvs4;
    if (uvs4) {
      vertexData.set(uvs4, VertexBuffer.UV4Kind);
    }
    const uvs5 = parsedVertexData.uvs5;
    if (uvs5) {
      vertexData.set(uvs5, VertexBuffer.UV5Kind);
    }
    const uvs6 = parsedVertexData.uvs6;
    if (uvs6) {
      vertexData.set(uvs6, VertexBuffer.UV6Kind);
    }
    const colors = parsedVertexData.colors;
    if (colors) {
      vertexData.set(Color4.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);
      if (parsedVertexData.hasVertexAlpha !== void 0) {
        vertexData.hasVertexAlpha = parsedVertexData.hasVertexAlpha;
      }
    }
    const matricesIndices = parsedVertexData.matricesIndices;
    if (matricesIndices) {
      vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);
    }
    const matricesWeights = parsedVertexData.matricesWeights;
    if (matricesWeights) {
      vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);
    }
    const indices = parsedVertexData.indices;
    if (indices) {
      vertexData.indices = indices;
    }
    const materialInfos = parsedVertexData.materialInfos;
    if (materialInfos) {
      vertexData.materialInfos = [];
      for (const materialInfoFromJSON of materialInfos) {
        const materialInfo = new VertexDataMaterialInfo();
        materialInfo.indexCount = materialInfoFromJSON.indexCount;
        materialInfo.indexStart = materialInfoFromJSON.indexStart;
        materialInfo.verticesCount = materialInfoFromJSON.verticesCount;
        materialInfo.verticesStart = materialInfoFromJSON.verticesStart;
        materialInfo.materialIndex = materialInfoFromJSON.materialIndex;
        vertexData.materialInfos.push(materialInfo);
      }
    }
    return vertexData;
  }
  /**
   * Applies VertexData created from the imported parameters to the geometry
   * @param parsedVertexData the parsed data from an imported file
   * @param geometry the geometry to apply the VertexData to
   */
  static ImportVertexData(parsedVertexData, geometry) {
    const vertexData = _VertexData.Parse(parsedVertexData);
    geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);
  }
};
VertexData.FRONTSIDE = 0;
VertexData.BACKSIDE = 1;
VertexData.DOUBLESIDE = 2;
VertexData.DEFAULTSIDE = 0;
VertexData._UniqueIDGenerator = 0;
__decorate([
  nativeOverride.filter((...[coordinates]) => !Array.isArray(coordinates))
], VertexData, "_TransformVector3Coordinates", null);
__decorate([
  nativeOverride.filter((...[normals]) => !Array.isArray(normals))
], VertexData, "_TransformVector3Normals", null);
__decorate([
  nativeOverride.filter((...[normals]) => !Array.isArray(normals))
], VertexData, "_TransformVector4Normals", null);
__decorate([
  nativeOverride.filter((...[indices]) => !Array.isArray(indices))
], VertexData, "_FlipFaces", null);

// node_modules/@babylonjs/core/Meshes/transformNode.js
var convertRHSToLHS = Matrix.Compose(Vector3.One(), Quaternion.FromEulerAngles(0, Math.PI, 0), Vector3.Zero());
var TransformNode = class _TransformNode extends Node {
  /**
   * Gets or sets the billboard mode. Default is 0.
   *
   * | Value | Type | Description |
   * | --- | --- | --- |
   * | 0 | BILLBOARDMODE_NONE |  |
   * | 1 | BILLBOARDMODE_X |  |
   * | 2 | BILLBOARDMODE_Y |  |
   * | 4 | BILLBOARDMODE_Z |  |
   * | 7 | BILLBOARDMODE_ALL |  |
   *
   */
  get billboardMode() {
    return this._billboardMode;
  }
  set billboardMode(value) {
    if (this._billboardMode === value) {
      return;
    }
    this._billboardMode = value;
    this._cache.useBillboardPosition = (this._billboardMode & _TransformNode.BILLBOARDMODE_USE_POSITION) !== 0;
    this._computeUseBillboardPath();
  }
  /**
   * Gets or sets a boolean indicating that parent rotation should be preserved when using billboards.
   * This could be useful for glTF objects where parent rotation helps converting from right handed to left handed
   */
  get preserveParentRotationForBillboard() {
    return this._preserveParentRotationForBillboard;
  }
  set preserveParentRotationForBillboard(value) {
    if (value === this._preserveParentRotationForBillboard) {
      return;
    }
    this._preserveParentRotationForBillboard = value;
    this._computeUseBillboardPath();
  }
  _computeUseBillboardPath() {
    this._cache.useBillboardPath = this._billboardMode !== _TransformNode.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard;
  }
  /**
   * Gets or sets the distance of the object to max, often used by skybox
   */
  get infiniteDistance() {
    return this._infiniteDistance;
  }
  set infiniteDistance(value) {
    if (this._infiniteDistance === value) {
      return;
    }
    this._infiniteDistance = value;
  }
  constructor(name, scene = null, isPure = true) {
    super(name, scene, false);
    this._forward = new Vector3(0, 0, 1);
    this._up = new Vector3(0, 1, 0);
    this._right = new Vector3(1, 0, 0);
    this._position = Vector3.Zero();
    this._rotation = Vector3.Zero();
    this._rotationQuaternion = null;
    this._scaling = Vector3.One();
    this._transformToBoneReferal = null;
    this._isAbsoluteSynced = false;
    this._billboardMode = _TransformNode.BILLBOARDMODE_NONE;
    this._preserveParentRotationForBillboard = false;
    this.scalingDeterminant = 1;
    this._infiniteDistance = false;
    this.ignoreNonUniformScaling = false;
    this.reIntegrateRotationIntoRotationQuaternion = false;
    this._poseMatrix = null;
    this._localMatrix = Matrix.Zero();
    this._usePivotMatrix = false;
    this._absolutePosition = Vector3.Zero();
    this._absoluteScaling = Vector3.Zero();
    this._absoluteRotationQuaternion = Quaternion.Identity();
    this._pivotMatrix = Matrix.Identity();
    this._postMultiplyPivotMatrix = false;
    this._isWorldMatrixFrozen = false;
    this._indexInSceneTransformNodesArray = -1;
    this.onAfterWorldMatrixUpdateObservable = new Observable();
    this._nonUniformScaling = false;
    if (isPure) {
      this.getScene().addTransformNode(this);
    }
  }
  /**
   * Gets a string identifying the name of the class
   * @returns "TransformNode" string
   */
  getClassName() {
    return "TransformNode";
  }
  /**
   * Gets or set the node position (default is (0.0, 0.0, 0.0))
   */
  get position() {
    return this._position;
  }
  set position(newPosition) {
    this._position = newPosition;
    this._markAsDirtyInternal();
  }
  /**
   * return true if a pivot has been set
   * @returns true if a pivot matrix is used
   */
  isUsingPivotMatrix() {
    return this._usePivotMatrix;
  }
  /**
   * @returns true if pivot matrix must be cancelled in the world matrix. When this parameter is set to true (default), the inverse of the pivot matrix is also applied at the end to cancel the transformation effect.
   */
  isUsingPostMultiplyPivotMatrix() {
    return this._postMultiplyPivotMatrix;
  }
  /**
   * Gets or sets the rotation property : a Vector3 defining the rotation value in radians around each local axis X, Y, Z  (default is (0.0, 0.0, 0.0)).
   * If rotation quaternion is set, this Vector3 will be ignored and copy from the quaternion
   */
  get rotation() {
    return this._rotation;
  }
  set rotation(newRotation) {
    this._rotation = newRotation;
    this._rotationQuaternion = null;
    this._markAsDirtyInternal();
  }
  /**
   * Gets or sets the scaling property : a Vector3 defining the node scaling along each local axis X, Y, Z (default is (1.0, 1.0, 1.0)).
   */
  get scaling() {
    return this._scaling;
  }
  set scaling(newScaling) {
    this._scaling = newScaling;
    this._markAsDirtyInternal();
  }
  /**
   * Gets or sets the rotation Quaternion property : this a Quaternion object defining the node rotation by using a unit quaternion (undefined by default, but can be null).
   * If set, only the rotationQuaternion is then used to compute the node rotation (ie. node.rotation will be ignored)
   */
  get rotationQuaternion() {
    return this._rotationQuaternion;
  }
  set rotationQuaternion(quaternion) {
    this._rotationQuaternion = quaternion;
    if (quaternion) {
      this._rotation.setAll(0);
    }
    this._markAsDirtyInternal();
  }
  _markAsDirtyInternal() {
    if (this._isDirty) {
      return;
    }
    this._isDirty = true;
    if (this.customMarkAsDirty) {
      this.customMarkAsDirty();
    }
  }
  /**
   * The forward direction of that transform in world space.
   */
  get forward() {
    Vector3.TransformNormalFromFloatsToRef(0, 0, this.getScene().useRightHandedSystem ? -1 : 1, this.getWorldMatrix(), this._forward);
    return this._forward.normalize();
  }
  /**
   * The up direction of that transform in world space.
   */
  get up() {
    Vector3.TransformNormalFromFloatsToRef(0, 1, 0, this.getWorldMatrix(), this._up);
    return this._up.normalize();
  }
  /**
   * The right direction of that transform in world space.
   */
  get right() {
    Vector3.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem ? -1 : 1, 0, 0, this.getWorldMatrix(), this._right);
    return this._right.normalize();
  }
  /**
   * Copies the parameter passed Matrix into the mesh Pose matrix.
   * @param matrix the matrix to copy the pose from
   * @returns this TransformNode.
   */
  updatePoseMatrix(matrix) {
    if (!this._poseMatrix) {
      this._poseMatrix = matrix.clone();
      return this;
    }
    this._poseMatrix.copyFrom(matrix);
    return this;
  }
  /**
   * Returns the mesh Pose matrix.
   * @returns the pose matrix
   */
  getPoseMatrix() {
    if (!this._poseMatrix) {
      this._poseMatrix = Matrix.Identity();
    }
    return this._poseMatrix;
  }
  /** @internal */
  _isSynchronized() {
    const cache = this._cache;
    if (this._billboardMode !== cache.billboardMode || this._billboardMode !== _TransformNode.BILLBOARDMODE_NONE) {
      return false;
    }
    if (cache.pivotMatrixUpdated) {
      return false;
    }
    if (this._infiniteDistance) {
      return false;
    }
    if (this._position._isDirty) {
      return false;
    }
    if (this._scaling._isDirty) {
      return false;
    }
    if (this._rotationQuaternion && this._rotationQuaternion._isDirty || this._rotation._isDirty) {
      return false;
    }
    return true;
  }
  /** @internal */
  _initCache() {
    super._initCache();
    const cache = this._cache;
    cache.localMatrixUpdated = false;
    cache.billboardMode = -1;
    cache.infiniteDistance = false;
    cache.useBillboardPosition = false;
    cache.useBillboardPath = false;
  }
  /**
   * Returns the current mesh absolute position.
   * Returns a Vector3.
   */
  get absolutePosition() {
    return this.getAbsolutePosition();
  }
  /**
   * Returns the current mesh absolute scaling.
   * Returns a Vector3.
   */
  get absoluteScaling() {
    this._syncAbsoluteScalingAndRotation();
    return this._absoluteScaling;
  }
  /**
   * Returns the current mesh absolute rotation.
   * Returns a Quaternion.
   */
  get absoluteRotationQuaternion() {
    this._syncAbsoluteScalingAndRotation();
    return this._absoluteRotationQuaternion;
  }
  /**
   * Sets a new matrix to apply before all other transformation
   * @param matrix defines the transform matrix
   * @returns the current TransformNode
   */
  setPreTransformMatrix(matrix) {
    return this.setPivotMatrix(matrix, false);
  }
  /**
   * Sets a new pivot matrix to the current node
   * @param matrix defines the new pivot matrix to use
   * @param postMultiplyPivotMatrix defines if the pivot matrix must be cancelled in the world matrix. When this parameter is set to true (default), the inverse of the pivot matrix is also applied at the end to cancel the transformation effect
   * @returns the current TransformNode
   */
  setPivotMatrix(matrix, postMultiplyPivotMatrix = true) {
    this._pivotMatrix.copyFrom(matrix);
    this._usePivotMatrix = !this._pivotMatrix.isIdentity();
    this._cache.pivotMatrixUpdated = true;
    this._postMultiplyPivotMatrix = postMultiplyPivotMatrix;
    if (this._postMultiplyPivotMatrix) {
      if (!this._pivotMatrixInverse) {
        this._pivotMatrixInverse = Matrix.Invert(this._pivotMatrix);
      } else {
        this._pivotMatrix.invertToRef(this._pivotMatrixInverse);
      }
    }
    return this;
  }
  /**
   * Returns the mesh pivot matrix.
   * Default : Identity.
   * @returns the matrix
   */
  getPivotMatrix() {
    return this._pivotMatrix;
  }
  /**
   * Instantiate (when possible) or clone that node with its hierarchy
   * @param newParent defines the new parent to use for the instance (or clone)
   * @param options defines options to configure how copy is done
   * @param options.doNotInstantiate defines if the model must be instantiated or just cloned
   * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created
   * @returns an instance (or a clone) of the current node with its hierarchy
   */
  instantiateHierarchy(newParent = null, options, onNewNodeCreated) {
    const clone = this.clone("Clone of " + (this.name || this.id), newParent || this.parent, true);
    if (clone) {
      if (onNewNodeCreated) {
        onNewNodeCreated(this, clone);
      }
    }
    for (const child of this.getChildTransformNodes(true)) {
      child.instantiateHierarchy(clone, options, onNewNodeCreated);
    }
    return clone;
  }
  /**
   * Prevents the World matrix to be computed any longer
   * @param newWorldMatrix defines an optional matrix to use as world matrix
   * @param decompose defines whether to decompose the given newWorldMatrix or directly assign
   * @returns the TransformNode.
   */
  freezeWorldMatrix(newWorldMatrix = null, decompose = false) {
    if (newWorldMatrix) {
      if (decompose) {
        this._rotation.setAll(0);
        this._rotationQuaternion = this._rotationQuaternion || Quaternion.Identity();
        newWorldMatrix.decompose(this._scaling, this._rotationQuaternion, this._position);
        this.computeWorldMatrix(true);
      } else {
        this._worldMatrix = newWorldMatrix;
        this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);
        this._afterComputeWorldMatrix();
      }
    } else {
      this._isWorldMatrixFrozen = false;
      this.computeWorldMatrix(true);
    }
    this._isDirty = false;
    this._isWorldMatrixFrozen = true;
    return this;
  }
  /**
   * Allows back the World matrix computation.
   * @returns the TransformNode.
   */
  unfreezeWorldMatrix() {
    this._isWorldMatrixFrozen = false;
    this.computeWorldMatrix(true);
    return this;
  }
  /**
   * True if the World matrix has been frozen.
   */
  get isWorldMatrixFrozen() {
    return this._isWorldMatrixFrozen;
  }
  /**
   * Returns the mesh absolute position in the World.
   * @returns a Vector3.
   */
  getAbsolutePosition() {
    this.computeWorldMatrix();
    return this._absolutePosition;
  }
  /**
   * Sets the mesh absolute position in the World from a Vector3 or an Array(3).
   * @param absolutePosition the absolute position to set
   * @returns the TransformNode.
   */
  setAbsolutePosition(absolutePosition) {
    if (!absolutePosition) {
      return this;
    }
    let absolutePositionX;
    let absolutePositionY;
    let absolutePositionZ;
    if (absolutePosition.x === void 0) {
      if (arguments.length < 3) {
        return this;
      }
      absolutePositionX = arguments[0];
      absolutePositionY = arguments[1];
      absolutePositionZ = arguments[2];
    } else {
      absolutePositionX = absolutePosition.x;
      absolutePositionY = absolutePosition.y;
      absolutePositionZ = absolutePosition.z;
    }
    if (this.parent) {
      const invertParentWorldMatrix = TmpVectors.Matrix[0];
      this.parent.getWorldMatrix().invertToRef(invertParentWorldMatrix);
      Vector3.TransformCoordinatesFromFloatsToRef(absolutePositionX, absolutePositionY, absolutePositionZ, invertParentWorldMatrix, this.position);
    } else {
      this.position.x = absolutePositionX;
      this.position.y = absolutePositionY;
      this.position.z = absolutePositionZ;
    }
    this._absolutePosition.copyFrom(absolutePosition);
    return this;
  }
  /**
   * Sets the mesh position in its local space.
   * @param vector3 the position to set in localspace
   * @returns the TransformNode.
   */
  setPositionWithLocalVector(vector3) {
    this.computeWorldMatrix();
    this.position = Vector3.TransformNormal(vector3, this._localMatrix);
    return this;
  }
  /**
   * Returns the mesh position in the local space from the current World matrix values.
   * @returns a new Vector3.
   */
  getPositionExpressedInLocalSpace() {
    this.computeWorldMatrix();
    const invLocalWorldMatrix = TmpVectors.Matrix[0];
    this._localMatrix.invertToRef(invLocalWorldMatrix);
    return Vector3.TransformNormal(this.position, invLocalWorldMatrix);
  }
  /**
   * Translates the mesh along the passed Vector3 in its local space.
   * @param vector3 the distance to translate in localspace
   * @returns the TransformNode.
   */
  locallyTranslate(vector3) {
    this.computeWorldMatrix(true);
    this.position = Vector3.TransformCoordinates(vector3, this._localMatrix);
    return this;
  }
  /**
   * Orients a mesh towards a target point. Mesh must be drawn facing user.
   * @param targetPoint the position (must be in same space as current mesh) to look at
   * @param yawCor optional yaw (y-axis) correction in radians
   * @param pitchCor optional pitch (x-axis) correction in radians
   * @param rollCor optional roll (z-axis) correction in radians
   * @param space the chosen space of the target
   * @returns the TransformNode.
   */
  lookAt(targetPoint, yawCor = 0, pitchCor = 0, rollCor = 0, space = 0) {
    const dv = _TransformNode._LookAtVectorCache;
    const pos = space === 0 ? this.position : this.getAbsolutePosition();
    targetPoint.subtractToRef(pos, dv);
    this.setDirection(dv, yawCor, pitchCor, rollCor);
    if (space === 1 && this.parent) {
      if (this.rotationQuaternion) {
        const rotationMatrix = TmpVectors.Matrix[0];
        this.rotationQuaternion.toRotationMatrix(rotationMatrix);
        const parentRotationMatrix = TmpVectors.Matrix[1];
        this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);
        parentRotationMatrix.invert();
        rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);
        this.rotationQuaternion.fromRotationMatrix(rotationMatrix);
      } else {
        const quaternionRotation = TmpVectors.Quaternion[0];
        Quaternion.FromEulerVectorToRef(this.rotation, quaternionRotation);
        const rotationMatrix = TmpVectors.Matrix[0];
        quaternionRotation.toRotationMatrix(rotationMatrix);
        const parentRotationMatrix = TmpVectors.Matrix[1];
        this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);
        parentRotationMatrix.invert();
        rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);
        quaternionRotation.fromRotationMatrix(rotationMatrix);
        quaternionRotation.toEulerAnglesToRef(this.rotation);
      }
    }
    return this;
  }
  /**
   * Returns a new Vector3 that is the localAxis, expressed in the mesh local space, rotated like the mesh.
   * This Vector3 is expressed in the World space.
   * @param localAxis axis to rotate
   * @returns a new Vector3 that is the localAxis, expressed in the mesh local space, rotated like the mesh.
   */
  getDirection(localAxis) {
    const result = Vector3.Zero();
    this.getDirectionToRef(localAxis, result);
    return result;
  }
  /**
   * Sets the Vector3 "result" as the rotated Vector3 "localAxis" in the same rotation than the mesh.
   * localAxis is expressed in the mesh local space.
   * result is computed in the World space from the mesh World matrix.
   * @param localAxis axis to rotate
   * @param result the resulting transformnode
   * @returns this TransformNode.
   */
  getDirectionToRef(localAxis, result) {
    Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);
    return this;
  }
  /**
   * Sets this transform node rotation to the given local axis.
   * @param localAxis the axis in local space
   * @param yawCor optional yaw (y-axis) correction in radians
   * @param pitchCor optional pitch (x-axis) correction in radians
   * @param rollCor optional roll (z-axis) correction in radians
   * @returns this TransformNode
   */
  setDirection(localAxis, yawCor = 0, pitchCor = 0, rollCor = 0) {
    const yaw = -Math.atan2(localAxis.z, localAxis.x) + Math.PI / 2;
    const len = Math.sqrt(localAxis.x * localAxis.x + localAxis.z * localAxis.z);
    const pitch = -Math.atan2(localAxis.y, len);
    if (this.rotationQuaternion) {
      Quaternion.RotationYawPitchRollToRef(yaw + yawCor, pitch + pitchCor, rollCor, this.rotationQuaternion);
    } else {
      this.rotation.x = pitch + pitchCor;
      this.rotation.y = yaw + yawCor;
      this.rotation.z = rollCor;
    }
    return this;
  }
  /**
   * Sets a new pivot point to the current node
   * @param point defines the new pivot point to use
   * @param space defines if the point is in world or local space (local by default)
   * @returns the current TransformNode
   */
  setPivotPoint(point, space = 0) {
    if (this.getScene().getRenderId() == 0) {
      this.computeWorldMatrix(true);
    }
    const wm = this.getWorldMatrix();
    if (space == 1) {
      const tmat = TmpVectors.Matrix[0];
      wm.invertToRef(tmat);
      point = Vector3.TransformCoordinates(point, tmat);
    }
    return this.setPivotMatrix(Matrix.Translation(-point.x, -point.y, -point.z), true);
  }
  /**
   * Returns a new Vector3 set with the mesh pivot point coordinates in the local space.
   * @returns the pivot point
   */
  getPivotPoint() {
    const point = Vector3.Zero();
    this.getPivotPointToRef(point);
    return point;
  }
  /**
   * Sets the passed Vector3 "result" with the coordinates of the mesh pivot point in the local space.
   * @param result the vector3 to store the result
   * @returns this TransformNode.
   */
  getPivotPointToRef(result) {
    result.x = -this._pivotMatrix.m[12];
    result.y = -this._pivotMatrix.m[13];
    result.z = -this._pivotMatrix.m[14];
    return this;
  }
  /**
   * Returns a new Vector3 set with the mesh pivot point World coordinates.
   * @returns a new Vector3 set with the mesh pivot point World coordinates.
   */
  getAbsolutePivotPoint() {
    const point = Vector3.Zero();
    this.getAbsolutePivotPointToRef(point);
    return point;
  }
  /**
   * Sets the Vector3 "result" coordinates with the mesh pivot point World coordinates.
   * @param result vector3 to store the result
   * @returns this TransformNode.
   */
  getAbsolutePivotPointToRef(result) {
    this.getPivotPointToRef(result);
    Vector3.TransformCoordinatesToRef(result, this.getWorldMatrix(), result);
    return this;
  }
  /**
   * Flag the transform node as dirty (Forcing it to update everything)
   * @param property if set to "rotation" the objects rotationQuaternion will be set to null
   * @returns this  node
   */
  markAsDirty(property) {
    if (this._isDirty) {
      return this;
    }
    if (this._children) {
      for (const child of this._children) {
        child.markAsDirty(property);
      }
    }
    return super.markAsDirty(property);
  }
  /**
   * Defines the passed node as the parent of the current node.
   * The node will remain exactly where it is and its position / rotation will be updated accordingly.
   * If you don't want to preserve the current rotation / position, assign the parent through parent accessor.
   * Note that if the mesh has a pivot matrix / point defined it will be applied after the parent was updated.
   * In that case the node will not remain in the same space as it is, as the pivot will be applied.
   * To avoid this, you can set updatePivot to true and the pivot will be updated to identity
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/parent_pivot/parent
   * @param node the node ot set as the parent
   * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.
   * @param updatePivot if true, update the pivot matrix to keep the node in the same space as before
   * @returns this TransformNode.
   */
  setParent(node, preserveScalingSign = false, updatePivot = false) {
    if (!node && !this.parent) {
      return this;
    }
    const quatRotation = TmpVectors.Quaternion[0];
    const position = TmpVectors.Vector3[0];
    const scale = TmpVectors.Vector3[1];
    const invParentMatrix = TmpVectors.Matrix[1];
    Matrix.IdentityToRef(invParentMatrix);
    const composedMatrix = TmpVectors.Matrix[0];
    this.computeWorldMatrix(true);
    let currentRotation = this.rotationQuaternion;
    if (!currentRotation) {
      currentRotation = _TransformNode._TmpRotation;
      Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, currentRotation);
    }
    Matrix.ComposeToRef(this.scaling, currentRotation, this.position, composedMatrix);
    if (this.parent) {
      composedMatrix.multiplyToRef(this.parent.computeWorldMatrix(true), composedMatrix);
    }
    if (node) {
      node.computeWorldMatrix(true).invertToRef(invParentMatrix);
      composedMatrix.multiplyToRef(invParentMatrix, composedMatrix);
    }
    composedMatrix.decompose(scale, quatRotation, position, preserveScalingSign ? this : void 0);
    if (this.rotationQuaternion) {
      this.rotationQuaternion.copyFrom(quatRotation);
    } else {
      quatRotation.toEulerAnglesToRef(this.rotation);
    }
    this.scaling.copyFrom(scale);
    this.position.copyFrom(position);
    this.parent = node;
    if (updatePivot) {
      this.setPivotMatrix(Matrix.Identity());
    }
    return this;
  }
  /**
   * Adds the passed mesh as a child to the current mesh.
   * The node will remain exactly where it is and its position / rotation will be updated accordingly.
   * This method is equivalent to calling setParent().
   * @param mesh defines the child mesh
   * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.
   * @returns the current mesh
   */
  addChild(mesh, preserveScalingSign = false) {
    mesh.setParent(this, preserveScalingSign);
    return this;
  }
  /**
   * Removes the passed mesh from the current mesh children list
   * @param mesh defines the child mesh
   * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.
   * @returns the current mesh
   */
  removeChild(mesh, preserveScalingSign = false) {
    if (mesh.parent !== this)
      return this;
    mesh.setParent(null, preserveScalingSign);
    return this;
  }
  /**
   * True if the scaling property of this object is non uniform eg. (1,2,1)
   */
  get nonUniformScaling() {
    return this._nonUniformScaling;
  }
  /**
   * @internal
   */
  _updateNonUniformScalingState(value) {
    if (this._nonUniformScaling === value) {
      return false;
    }
    this._nonUniformScaling = value;
    return true;
  }
  /**
   * Attach the current TransformNode to another TransformNode associated with a bone
   * @param bone Bone affecting the TransformNode
   * @param affectedTransformNode TransformNode associated with the bone
   * @returns this object
   */
  attachToBone(bone, affectedTransformNode) {
    this._currentParentWhenAttachingToBone = this.parent;
    this._transformToBoneReferal = affectedTransformNode;
    this.parent = bone;
    bone.getSkeleton().prepare(true);
    if (bone.getFinalMatrix().determinant() < 0) {
      this.scalingDeterminant *= -1;
    }
    return this;
  }
  /**
   * Detach the transform node if its associated with a bone
   * @param resetToPreviousParent Indicates if the parent that was in effect when attachToBone was called should be set back or if we should set parent to null instead (defaults to the latter)
   * @returns this object
   */
  detachFromBone(resetToPreviousParent = false) {
    if (!this.parent) {
      if (resetToPreviousParent) {
        this.parent = this._currentParentWhenAttachingToBone;
      }
      return this;
    }
    if (this.parent.getWorldMatrix().determinant() < 0) {
      this.scalingDeterminant *= -1;
    }
    this._transformToBoneReferal = null;
    if (resetToPreviousParent) {
      this.parent = this._currentParentWhenAttachingToBone;
    } else {
      this.parent = null;
    }
    return this;
  }
  /**
   * Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in the given space.
   * space (default LOCAL) can be either Space.LOCAL, either Space.WORLD.
   * Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.
   * The passed axis is also normalized.
   * @param axis the axis to rotate around
   * @param amount the amount to rotate in radians
   * @param space Space to rotate in (Default: local)
   * @returns the TransformNode.
   */
  rotate(axis, amount, space) {
    axis.normalize();
    if (!this.rotationQuaternion) {
      this.rotationQuaternion = this.rotation.toQuaternion();
      this.rotation.setAll(0);
    }
    let rotationQuaternion;
    if (!space || space === 0) {
      rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, _TransformNode._RotationAxisCache);
      this.rotationQuaternion.multiplyToRef(rotationQuaternion, this.rotationQuaternion);
    } else {
      if (this.parent) {
        const parentWorldMatrix = this.parent.getWorldMatrix();
        const invertParentWorldMatrix = TmpVectors.Matrix[0];
        parentWorldMatrix.invertToRef(invertParentWorldMatrix);
        axis = Vector3.TransformNormal(axis, invertParentWorldMatrix);
        if (parentWorldMatrix.determinant() < 0) {
          amount *= -1;
        }
      }
      rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, _TransformNode._RotationAxisCache);
      rotationQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
    }
    return this;
  }
  /**
   * Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in world space.
   * Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.
   * The passed axis is also normalized. .
   * Method is based on http://www.euclideanspace.com/maths/geometry/affine/aroundPoint/index.htm
   * @param point the point to rotate around
   * @param axis the axis to rotate around
   * @param amount the amount to rotate in radians
   * @returns the TransformNode
   */
  rotateAround(point, axis, amount) {
    axis.normalize();
    if (!this.rotationQuaternion) {
      this.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);
      this.rotation.setAll(0);
    }
    const tmpVector = TmpVectors.Vector3[0];
    const finalScale = TmpVectors.Vector3[1];
    const finalTranslation = TmpVectors.Vector3[2];
    const finalRotation = TmpVectors.Quaternion[0];
    const translationMatrix = TmpVectors.Matrix[0];
    const translationMatrixInv = TmpVectors.Matrix[1];
    const rotationMatrix = TmpVectors.Matrix[2];
    const finalMatrix = TmpVectors.Matrix[3];
    point.subtractToRef(this.position, tmpVector);
    Matrix.TranslationToRef(tmpVector.x, tmpVector.y, tmpVector.z, translationMatrix);
    Matrix.TranslationToRef(-tmpVector.x, -tmpVector.y, -tmpVector.z, translationMatrixInv);
    Matrix.RotationAxisToRef(axis, amount, rotationMatrix);
    translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix);
    finalMatrix.multiplyToRef(translationMatrix, finalMatrix);
    finalMatrix.decompose(finalScale, finalRotation, finalTranslation);
    this.position.addInPlace(finalTranslation);
    finalRotation.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
    return this;
  }
  /**
   * Translates the mesh along the axis vector for the passed distance in the given space.
   * space (default LOCAL) can be either Space.LOCAL, either Space.WORLD.
   * @param axis the axis to translate in
   * @param distance the distance to translate
   * @param space Space to rotate in (Default: local)
   * @returns the TransformNode.
   */
  translate(axis, distance, space) {
    const displacementVector = axis.scale(distance);
    if (!space || space === 0) {
      const tempV3 = this.getPositionExpressedInLocalSpace().add(displacementVector);
      this.setPositionWithLocalVector(tempV3);
    } else {
      this.setAbsolutePosition(this.getAbsolutePosition().add(displacementVector));
    }
    return this;
  }
  /**
   * Adds a rotation step to the mesh current rotation.
   * x, y, z are Euler angles expressed in radians.
   * This methods updates the current mesh rotation, either mesh.rotation, either mesh.rotationQuaternion if it's set.
   * This means this rotation is made in the mesh local space only.
   * It's useful to set a custom rotation order different from the BJS standard one YXZ.
   * Example : this rotates the mesh first around its local X axis, then around its local Z axis, finally around its local Y axis.
   * ```javascript
   * mesh.addRotation(x1, 0, 0).addRotation(0, 0, z2).addRotation(0, 0, y3);
   * ```
   * Note that `addRotation()` accumulates the passed rotation values to the current ones and computes the .rotation or .rotationQuaternion updated values.
   * Under the hood, only quaternions are used. So it's a little faster is you use .rotationQuaternion because it doesn't need to translate them back to Euler angles.
   * @param x Rotation to add
   * @param y Rotation to add
   * @param z Rotation to add
   * @returns the TransformNode.
   */
  addRotation(x, y, z) {
    let rotationQuaternion;
    if (this.rotationQuaternion) {
      rotationQuaternion = this.rotationQuaternion;
    } else {
      rotationQuaternion = TmpVectors.Quaternion[1];
      Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, rotationQuaternion);
    }
    const accumulation = TmpVectors.Quaternion[0];
    Quaternion.RotationYawPitchRollToRef(y, x, z, accumulation);
    rotationQuaternion.multiplyInPlace(accumulation);
    if (!this.rotationQuaternion) {
      rotationQuaternion.toEulerAnglesToRef(this.rotation);
    }
    return this;
  }
  /**
   * @internal
   */
  _getEffectiveParent() {
    return this.parent;
  }
  /**
   * Returns whether the transform node world matrix computation needs the camera information to be computed.
   * This is the case when the node is a billboard or has an infinite distance for instance.
   * @returns true if the world matrix computation needs the camera information to be computed
   */
  isWorldMatrixCameraDependent() {
    return this._infiniteDistance && !this.parent || this._billboardMode !== _TransformNode.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard;
  }
  /**
   * Computes the world matrix of the node
   * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch
   * @param camera defines the camera used if different from the scene active camera (This is used with modes like Billboard or infinite distance)
   * @returns the world matrix
   */
  computeWorldMatrix(force = false, camera = null) {
    if (this._isWorldMatrixFrozen && !this._isDirty) {
      return this._worldMatrix;
    }
    const currentRenderId = this.getScene().getRenderId();
    if (!this._isDirty && !force && (this._currentRenderId === currentRenderId || this.isSynchronized())) {
      this._currentRenderId = currentRenderId;
      return this._worldMatrix;
    }
    camera = camera || this.getScene().activeCamera;
    this._updateCache();
    const cache = this._cache;
    cache.pivotMatrixUpdated = false;
    cache.billboardMode = this.billboardMode;
    cache.infiniteDistance = this.infiniteDistance;
    cache.parent = this._parentNode;
    this._currentRenderId = currentRenderId;
    this._childUpdateId += 1;
    this._isDirty = false;
    this._position._isDirty = false;
    this._rotation._isDirty = false;
    this._scaling._isDirty = false;
    const parent = this._getEffectiveParent();
    const scaling = _TransformNode._TmpScaling;
    let translation = this._position;
    if (this._infiniteDistance) {
      if (!this.parent && camera) {
        const cameraWorldMatrix = camera.getWorldMatrix();
        const cameraGlobalPosition = new Vector3(cameraWorldMatrix.m[12], cameraWorldMatrix.m[13], cameraWorldMatrix.m[14]);
        translation = _TransformNode._TmpTranslation;
        translation.copyFromFloats(this._position.x + cameraGlobalPosition.x, this._position.y + cameraGlobalPosition.y, this._position.z + cameraGlobalPosition.z);
      }
    }
    scaling.copyFromFloats(this._scaling.x * this.scalingDeterminant, this._scaling.y * this.scalingDeterminant, this._scaling.z * this.scalingDeterminant);
    let rotation;
    if (this._rotationQuaternion) {
      this._rotationQuaternion._isDirty = false;
      rotation = this._rotationQuaternion;
      if (this.reIntegrateRotationIntoRotationQuaternion) {
        const len = this.rotation.lengthSquared();
        if (len) {
          this._rotationQuaternion.multiplyInPlace(Quaternion.RotationYawPitchRoll(this._rotation.y, this._rotation.x, this._rotation.z));
          this._rotation.copyFromFloats(0, 0, 0);
        }
      }
    } else {
      rotation = _TransformNode._TmpRotation;
      Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, rotation);
    }
    if (this._usePivotMatrix) {
      const scaleMatrix = TmpVectors.Matrix[1];
      Matrix.ScalingToRef(scaling.x, scaling.y, scaling.z, scaleMatrix);
      const rotationMatrix = TmpVectors.Matrix[0];
      rotation.toRotationMatrix(rotationMatrix);
      this._pivotMatrix.multiplyToRef(scaleMatrix, TmpVectors.Matrix[4]);
      TmpVectors.Matrix[4].multiplyToRef(rotationMatrix, this._localMatrix);
      if (this._postMultiplyPivotMatrix) {
        this._localMatrix.multiplyToRef(this._pivotMatrixInverse, this._localMatrix);
      }
      this._localMatrix.addTranslationFromFloats(translation.x, translation.y, translation.z);
    } else {
      Matrix.ComposeToRef(scaling, rotation, translation, this._localMatrix);
    }
    if (parent && parent.getWorldMatrix) {
      if (force) {
        parent.computeWorldMatrix(force);
      }
      if (cache.useBillboardPath) {
        if (this._transformToBoneReferal) {
          const bone = this.parent;
          bone.getSkeleton().prepare();
          bone.getFinalMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), TmpVectors.Matrix[7]);
        } else {
          TmpVectors.Matrix[7].copyFrom(parent.getWorldMatrix());
        }
        const translation2 = TmpVectors.Vector3[5];
        const scale = TmpVectors.Vector3[6];
        const orientation = TmpVectors.Quaternion[0];
        TmpVectors.Matrix[7].decompose(scale, orientation, translation2);
        Matrix.ScalingToRef(scale.x, scale.y, scale.z, TmpVectors.Matrix[7]);
        TmpVectors.Matrix[7].setTranslation(translation2);
        if (_TransformNode.BillboardUseParentOrientation) {
          this._position.applyRotationQuaternionToRef(orientation, translation2);
          this._localMatrix.setTranslation(translation2);
        }
        this._localMatrix.multiplyToRef(TmpVectors.Matrix[7], this._worldMatrix);
      } else {
        if (this._transformToBoneReferal) {
          const bone = this.parent;
          bone.getSkeleton().prepare();
          this._localMatrix.multiplyToRef(bone.getFinalMatrix(), TmpVectors.Matrix[6]);
          TmpVectors.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), this._worldMatrix);
        } else {
          this._localMatrix.multiplyToRef(parent.getWorldMatrix(), this._worldMatrix);
        }
      }
      this._markSyncedWithParent();
    } else {
      this._worldMatrix.copyFrom(this._localMatrix);
    }
    if (cache.useBillboardPath && camera && this.billboardMode && !cache.useBillboardPosition) {
      const storedTranslation = TmpVectors.Vector3[0];
      this._worldMatrix.getTranslationToRef(storedTranslation);
      TmpVectors.Matrix[1].copyFrom(camera.getViewMatrix());
      if (this._scene.useRightHandedSystem) {
        TmpVectors.Matrix[1].multiplyToRef(convertRHSToLHS, TmpVectors.Matrix[1]);
      }
      TmpVectors.Matrix[1].setTranslationFromFloats(0, 0, 0);
      TmpVectors.Matrix[1].invertToRef(TmpVectors.Matrix[0]);
      if ((this.billboardMode & _TransformNode.BILLBOARDMODE_ALL) !== _TransformNode.BILLBOARDMODE_ALL) {
        TmpVectors.Matrix[0].decompose(void 0, TmpVectors.Quaternion[0], void 0);
        const eulerAngles = TmpVectors.Vector3[1];
        TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);
        if ((this.billboardMode & _TransformNode.BILLBOARDMODE_X) !== _TransformNode.BILLBOARDMODE_X) {
          eulerAngles.x = 0;
        }
        if ((this.billboardMode & _TransformNode.BILLBOARDMODE_Y) !== _TransformNode.BILLBOARDMODE_Y) {
          eulerAngles.y = 0;
        }
        if ((this.billboardMode & _TransformNode.BILLBOARDMODE_Z) !== _TransformNode.BILLBOARDMODE_Z) {
          eulerAngles.z = 0;
        }
        Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);
      }
      this._worldMatrix.setTranslationFromFloats(0, 0, 0);
      this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix);
      this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);
    } else if (cache.useBillboardPath && camera && cache.useBillboardPosition) {
      const storedTranslation = TmpVectors.Vector3[0];
      this._worldMatrix.getTranslationToRef(storedTranslation);
      const cameraPosition = camera.globalPosition;
      this._worldMatrix.invertToRef(TmpVectors.Matrix[1]);
      const camInObjSpace = TmpVectors.Vector3[1];
      Vector3.TransformCoordinatesToRef(cameraPosition, TmpVectors.Matrix[1], camInObjSpace);
      camInObjSpace.normalize();
      const yaw = -Math.atan2(camInObjSpace.z, camInObjSpace.x) + Math.PI / 2;
      const len = Math.sqrt(camInObjSpace.x * camInObjSpace.x + camInObjSpace.z * camInObjSpace.z);
      const pitch = -Math.atan2(camInObjSpace.y, len);
      Quaternion.RotationYawPitchRollToRef(yaw, pitch, 0, TmpVectors.Quaternion[0]);
      if ((this.billboardMode & _TransformNode.BILLBOARDMODE_ALL) !== _TransformNode.BILLBOARDMODE_ALL) {
        const eulerAngles = TmpVectors.Vector3[1];
        TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);
        if ((this.billboardMode & _TransformNode.BILLBOARDMODE_X) !== _TransformNode.BILLBOARDMODE_X) {
          eulerAngles.x = 0;
        }
        if ((this.billboardMode & _TransformNode.BILLBOARDMODE_Y) !== _TransformNode.BILLBOARDMODE_Y) {
          eulerAngles.y = 0;
        }
        if ((this.billboardMode & _TransformNode.BILLBOARDMODE_Z) !== _TransformNode.BILLBOARDMODE_Z) {
          eulerAngles.z = 0;
        }
        Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);
      } else {
        Matrix.FromQuaternionToRef(TmpVectors.Quaternion[0], TmpVectors.Matrix[0]);
      }
      this._worldMatrix.setTranslationFromFloats(0, 0, 0);
      this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix);
      this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);
    }
    if (!this.ignoreNonUniformScaling) {
      if (this._scaling.isNonUniformWithinEpsilon(1e-6)) {
        this._updateNonUniformScalingState(true);
      } else if (parent && parent._nonUniformScaling) {
        this._updateNonUniformScalingState(parent._nonUniformScaling);
      } else {
        this._updateNonUniformScalingState(false);
      }
    } else {
      this._updateNonUniformScalingState(false);
    }
    this._afterComputeWorldMatrix();
    this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);
    this._isAbsoluteSynced = false;
    this.onAfterWorldMatrixUpdateObservable.notifyObservers(this);
    if (!this._poseMatrix) {
      this._poseMatrix = Matrix.Invert(this._worldMatrix);
    }
    this._worldMatrixDeterminantIsDirty = true;
    return this._worldMatrix;
  }
  /**
   * Resets this nodeTransform's local matrix to Matrix.Identity().
   * @param independentOfChildren indicates if all child nodeTransform's world-space transform should be preserved.
   */
  resetLocalMatrix(independentOfChildren = true) {
    this.computeWorldMatrix();
    if (independentOfChildren) {
      const children = this.getChildren();
      for (let i = 0; i < children.length; ++i) {
        const child = children[i];
        if (child) {
          child.computeWorldMatrix();
          const bakedMatrix = TmpVectors.Matrix[0];
          child._localMatrix.multiplyToRef(this._localMatrix, bakedMatrix);
          const tmpRotationQuaternion = TmpVectors.Quaternion[0];
          bakedMatrix.decompose(child.scaling, tmpRotationQuaternion, child.position);
          if (child.rotationQuaternion) {
            child.rotationQuaternion.copyFrom(tmpRotationQuaternion);
          } else {
            tmpRotationQuaternion.toEulerAnglesToRef(child.rotation);
          }
        }
      }
    }
    this.scaling.copyFromFloats(1, 1, 1);
    this.position.copyFromFloats(0, 0, 0);
    this.rotation.copyFromFloats(0, 0, 0);
    if (this.rotationQuaternion) {
      this.rotationQuaternion = Quaternion.Identity();
    }
    this._worldMatrix = Matrix.Identity();
  }
  _afterComputeWorldMatrix() {
  }
  /**
   * If you'd like to be called back after the mesh position, rotation or scaling has been updated.
   * @param func callback function to add
   *
   * @returns the TransformNode.
   */
  registerAfterWorldMatrixUpdate(func) {
    this.onAfterWorldMatrixUpdateObservable.add(func);
    return this;
  }
  /**
   * Removes a registered callback function.
   * @param func callback function to remove
   * @returns the TransformNode.
   */
  unregisterAfterWorldMatrixUpdate(func) {
    this.onAfterWorldMatrixUpdateObservable.removeCallback(func);
    return this;
  }
  /**
   * Gets the position of the current mesh in camera space
   * @param camera defines the camera to use
   * @returns a position
   */
  getPositionInCameraSpace(camera = null) {
    if (!camera) {
      camera = this.getScene().activeCamera;
    }
    return Vector3.TransformCoordinates(this.getAbsolutePosition(), camera.getViewMatrix());
  }
  /**
   * Returns the distance from the mesh to the active camera
   * @param camera defines the camera to use
   * @returns the distance
   */
  getDistanceToCamera(camera = null) {
    if (!camera) {
      camera = this.getScene().activeCamera;
    }
    return this.getAbsolutePosition().subtract(camera.globalPosition).length();
  }
  /**
   * Clone the current transform node
   * @param name Name of the new clone
   * @param newParent New parent for the clone
   * @param doNotCloneChildren Do not clone children hierarchy
   * @returns the new transform node
   */
  clone(name, newParent, doNotCloneChildren) {
    const result = SerializationHelper.Clone(() => new _TransformNode(name, this.getScene()), this);
    result.name = name;
    result.id = name;
    if (newParent) {
      result.parent = newParent;
    }
    if (!doNotCloneChildren) {
      const directDescendants = this.getDescendants(true);
      for (let index = 0; index < directDescendants.length; index++) {
        const child = directDescendants[index];
        if (child.clone) {
          child.clone(name + "." + child.name, result);
        }
      }
    }
    return result;
  }
  /**
   * Serializes the objects information.
   * @param currentSerializationObject defines the object to serialize in
   * @returns the serialized object
   */
  serialize(currentSerializationObject) {
    const serializationObject = SerializationHelper.Serialize(this, currentSerializationObject);
    serializationObject.type = this.getClassName();
    serializationObject.uniqueId = this.uniqueId;
    if (this.parent) {
      this.parent._serializeAsParent(serializationObject);
    }
    serializationObject.localMatrix = this.getPivotMatrix().asArray();
    serializationObject.isEnabled = this.isEnabled();
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    serializationObject.ranges = this.serializeAnimationRanges();
    return serializationObject;
  }
  // Statics
  /**
   * Returns a new TransformNode object parsed from the source provided.
   * @param parsedTransformNode is the source.
   * @param scene the scene the object belongs to
   * @param rootUrl is a string, it's the root URL to prefix the `delayLoadingFile` property with
   * @returns a new TransformNode object parsed from the source provided.
   */
  static Parse(parsedTransformNode, scene, rootUrl) {
    const transformNode = SerializationHelper.Parse(() => new _TransformNode(parsedTransformNode.name, scene), parsedTransformNode, scene, rootUrl);
    if (parsedTransformNode.localMatrix) {
      transformNode.setPreTransformMatrix(Matrix.FromArray(parsedTransformNode.localMatrix));
    } else if (parsedTransformNode.pivotMatrix) {
      transformNode.setPivotMatrix(Matrix.FromArray(parsedTransformNode.pivotMatrix));
    }
    transformNode.setEnabled(parsedTransformNode.isEnabled);
    transformNode._waitingParsedUniqueId = parsedTransformNode.uniqueId;
    if (parsedTransformNode.parentId !== void 0) {
      transformNode._waitingParentId = parsedTransformNode.parentId;
    }
    if (parsedTransformNode.parentInstanceIndex !== void 0) {
      transformNode._waitingParentInstanceIndex = parsedTransformNode.parentInstanceIndex;
    }
    if (parsedTransformNode.animations) {
      for (let animationIndex = 0; animationIndex < parsedTransformNode.animations.length; animationIndex++) {
        const parsedAnimation = parsedTransformNode.animations[animationIndex];
        const internalClass = GetClass("BABYLON.Animation");
        if (internalClass) {
          transformNode.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
      Node.ParseAnimationRanges(transformNode, parsedTransformNode, scene);
    }
    if (parsedTransformNode.autoAnimate) {
      scene.beginAnimation(transformNode, parsedTransformNode.autoAnimateFrom, parsedTransformNode.autoAnimateTo, parsedTransformNode.autoAnimateLoop, parsedTransformNode.autoAnimateSpeed || 1);
    }
    return transformNode;
  }
  /**
   * Get all child-transformNodes of this node
   * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered
   * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored
   * @returns an array of TransformNode
   */
  getChildTransformNodes(directDescendantsOnly, predicate) {
    const results = [];
    this._getDescendants(results, directDescendantsOnly, (node) => {
      return (!predicate || predicate(node)) && node instanceof _TransformNode;
    });
    return results;
  }
  /**
   * Releases resources associated with this transform node.
   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
   */
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    this.getScene().stopAnimation(this);
    this.getScene().removeTransformNode(this);
    if (this._parentContainer) {
      const index = this._parentContainer.transformNodes.indexOf(this);
      if (index > -1) {
        this._parentContainer.transformNodes.splice(index, 1);
      }
      this._parentContainer = null;
    }
    this.onAfterWorldMatrixUpdateObservable.clear();
    if (doNotRecurse) {
      const transformNodes = this.getChildTransformNodes(true);
      for (const transformNode of transformNodes) {
        transformNode.parent = null;
        transformNode.computeWorldMatrix(true);
      }
    }
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
  /**
   * Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)
   * @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false
   * @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false
   * @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling
   * @returns the current mesh
   */
  normalizeToUnitCube(includeDescendants = true, ignoreRotation = false, predicate) {
    let storedRotation = null;
    let storedRotationQuaternion = null;
    if (ignoreRotation) {
      if (this.rotationQuaternion) {
        storedRotationQuaternion = this.rotationQuaternion.clone();
        this.rotationQuaternion.copyFromFloats(0, 0, 0, 1);
      } else if (this.rotation) {
        storedRotation = this.rotation.clone();
        this.rotation.copyFromFloats(0, 0, 0);
      }
    }
    const boundingVectors = this.getHierarchyBoundingVectors(includeDescendants, predicate);
    const sizeVec = boundingVectors.max.subtract(boundingVectors.min);
    const maxDimension = Math.max(sizeVec.x, sizeVec.y, sizeVec.z);
    if (maxDimension === 0) {
      return this;
    }
    const scale = 1 / maxDimension;
    this.scaling.scaleInPlace(scale);
    if (ignoreRotation) {
      if (this.rotationQuaternion && storedRotationQuaternion) {
        this.rotationQuaternion.copyFrom(storedRotationQuaternion);
      } else if (this.rotation && storedRotation) {
        this.rotation.copyFrom(storedRotation);
      }
    }
    return this;
  }
  _syncAbsoluteScalingAndRotation() {
    if (!this._isAbsoluteSynced) {
      this._worldMatrix.decompose(this._absoluteScaling, this._absoluteRotationQuaternion);
      this._isAbsoluteSynced = true;
    }
  }
};
TransformNode.BILLBOARDMODE_NONE = 0;
TransformNode.BILLBOARDMODE_X = 1;
TransformNode.BILLBOARDMODE_Y = 2;
TransformNode.BILLBOARDMODE_Z = 4;
TransformNode.BILLBOARDMODE_ALL = 7;
TransformNode.BILLBOARDMODE_USE_POSITION = 128;
TransformNode.BillboardUseParentOrientation = false;
TransformNode._TmpRotation = Quaternion.Zero();
TransformNode._TmpScaling = Vector3.Zero();
TransformNode._TmpTranslation = Vector3.Zero();
TransformNode._LookAtVectorCache = new Vector3(0, 0, 0);
TransformNode._RotationAxisCache = new Quaternion();
__decorate([
  serializeAsVector3("position")
], TransformNode.prototype, "_position", void 0);
__decorate([
  serializeAsVector3("rotation")
], TransformNode.prototype, "_rotation", void 0);
__decorate([
  serializeAsQuaternion("rotationQuaternion")
], TransformNode.prototype, "_rotationQuaternion", void 0);
__decorate([
  serializeAsVector3("scaling")
], TransformNode.prototype, "_scaling", void 0);
__decorate([
  serialize("billboardMode")
], TransformNode.prototype, "_billboardMode", void 0);
__decorate([
  serialize()
], TransformNode.prototype, "scalingDeterminant", void 0);
__decorate([
  serialize("infiniteDistance")
], TransformNode.prototype, "_infiniteDistance", void 0);
__decorate([
  serialize()
], TransformNode.prototype, "ignoreNonUniformScaling", void 0);
__decorate([
  serialize()
], TransformNode.prototype, "reIntegrateRotationIntoRotationQuaternion", void 0);

// node_modules/@babylonjs/core/Collisions/meshCollisionData.js
var _MeshCollisionData = class {
  constructor() {
    this._checkCollisions = false;
    this._collisionMask = -1;
    this._collisionGroup = -1;
    this._surroundingMeshes = null;
    this._collider = null;
    this._oldPositionForCollisions = new Vector3(0, 0, 0);
    this._diffPositionForCollisions = new Vector3(0, 0, 0);
    this._collisionResponse = true;
  }
};

// node_modules/@babylonjs/core/Meshes/abstractMesh.js
function applyMorph(data, kind, morphTargetManager) {
  let getTargetData = null;
  switch (kind) {
    case VertexBuffer.PositionKind:
      getTargetData = (target) => target.getPositions();
      break;
    case VertexBuffer.NormalKind:
      getTargetData = (target) => target.getNormals();
      break;
    case VertexBuffer.TangentKind:
      getTargetData = (target) => target.getTangents();
      break;
    case VertexBuffer.UVKind:
      getTargetData = (target) => target.getUVs();
      break;
    case VertexBuffer.UV2Kind:
      getTargetData = (target) => target.getUV2s();
      break;
    case VertexBuffer.ColorKind:
      getTargetData = (target) => target.getColors();
      break;
    default:
      return;
  }
  for (let index = 0; index < data.length; index++) {
    let value = data[index];
    for (let targetCount = 0; targetCount < morphTargetManager.numTargets; targetCount++) {
      const target = morphTargetManager.getTarget(targetCount);
      const influence = target.influence;
      if (influence !== 0) {
        const targetData = getTargetData(target);
        if (targetData) {
          value += (targetData[index] - data[index]) * influence;
        }
      }
    }
    data[index] = value;
  }
}
function applySkeleton(data, kind, skeletonMatrices, matricesIndicesData, matricesWeightsData, matricesIndicesExtraData, matricesWeightsExtraData) {
  const tempVector = TmpVectors.Vector3[0];
  const finalMatrix = TmpVectors.Matrix[0];
  const tempMatrix = TmpVectors.Matrix[1];
  const transformFromFloatsToRef = kind === VertexBuffer.NormalKind ? Vector3.TransformNormalFromFloatsToRef : Vector3.TransformCoordinatesFromFloatsToRef;
  for (let index = 0, matWeightIdx = 0; index < data.length; index += 3, matWeightIdx += 4) {
    finalMatrix.reset();
    let inf;
    let weight;
    for (inf = 0; inf < 4; inf++) {
      weight = matricesWeightsData[matWeightIdx + inf];
      if (weight > 0) {
        Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);
        finalMatrix.addToSelf(tempMatrix);
      }
    }
    if (matricesIndicesExtraData && matricesWeightsExtraData) {
      for (inf = 0; inf < 4; inf++) {
        weight = matricesWeightsExtraData[matWeightIdx + inf];
        if (weight > 0) {
          Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);
          finalMatrix.addToSelf(tempMatrix);
        }
      }
    }
    transformFromFloatsToRef(data[index], data[index + 1], data[index + 2], finalMatrix, tempVector);
    tempVector.toArray(data, index);
  }
}
var _FacetDataStorage = class {
  constructor() {
    this.facetNb = 0;
    this.partitioningSubdivisions = 10;
    this.partitioningBBoxRatio = 1.01;
    this.facetDataEnabled = false;
    this.facetParameters = {};
    this.bbSize = Vector3.Zero();
    this.subDiv = {
      // actual number of subdivisions per axis for ComputeNormals()
      max: 1,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      X: 1,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      Y: 1,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      Z: 1
    };
    this.facetDepthSort = false;
    this.facetDepthSortEnabled = false;
  }
};
var _InternalAbstractMeshDataInfo = class {
  constructor() {
    this._hasVertexAlpha = false;
    this._useVertexColors = true;
    this._numBoneInfluencers = 4;
    this._applyFog = true;
    this._receiveShadows = false;
    this._facetData = new _FacetDataStorage();
    this._visibility = 1;
    this._skeleton = null;
    this._layerMask = 268435455;
    this._computeBonesUsingShaders = true;
    this._isActive = false;
    this._onlyForInstances = false;
    this._isActiveIntermediate = false;
    this._onlyForInstancesIntermediate = false;
    this._actAsRegularMesh = false;
    this._currentLOD = /* @__PURE__ */ new Map();
    this._collisionRetryCount = 3;
    this._morphTargetManager = null;
    this._renderingGroupId = 0;
    this._bakedVertexAnimationManager = null;
    this._material = null;
    this._positions = null;
    this._pointerOverDisableMeshTesting = false;
    this._meshCollisionData = new _MeshCollisionData();
    this._enableDistantPicking = false;
    this._rawBoundingInfo = null;
    this._sideOrientationHint = false;
    this._inheritVisibility = false;
  }
};
var AbstractMesh = class _AbstractMesh extends TransformNode {
  /**
   * No billboard
   */
  static get BILLBOARDMODE_NONE() {
    return TransformNode.BILLBOARDMODE_NONE;
  }
  /** Billboard on X axis */
  static get BILLBOARDMODE_X() {
    return TransformNode.BILLBOARDMODE_X;
  }
  /** Billboard on Y axis */
  static get BILLBOARDMODE_Y() {
    return TransformNode.BILLBOARDMODE_Y;
  }
  /** Billboard on Z axis */
  static get BILLBOARDMODE_Z() {
    return TransformNode.BILLBOARDMODE_Z;
  }
  /** Billboard on all axes */
  static get BILLBOARDMODE_ALL() {
    return TransformNode.BILLBOARDMODE_ALL;
  }
  /** Billboard on using position instead of orientation */
  static get BILLBOARDMODE_USE_POSITION() {
    return TransformNode.BILLBOARDMODE_USE_POSITION;
  }
  /**
   * Gets the number of facets in the mesh
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#what-is-a-mesh-facet
   */
  get facetNb() {
    return this._internalAbstractMeshDataInfo._facetData.facetNb;
  }
  /**
   * Gets or set the number (integer) of subdivisions per axis in the partitioning space
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#tweaking-the-partitioning
   */
  get partitioningSubdivisions() {
    return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions;
  }
  set partitioningSubdivisions(nb) {
    this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions = nb;
  }
  /**
   * The ratio (float) to apply to the bounding box size to set to the partitioning space.
   * Ex : 1.01 (default) the partitioning space is 1% bigger than the bounding box
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#tweaking-the-partitioning
   */
  get partitioningBBoxRatio() {
    return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio;
  }
  set partitioningBBoxRatio(ratio) {
    this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio = ratio;
  }
  /**
   * Gets or sets a boolean indicating that the facets must be depth sorted on next call to `updateFacetData()`.
   * Works only for updatable meshes.
   * Doesn't work with multi-materials
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#facet-depth-sort
   */
  get mustDepthSortFacets() {
    return this._internalAbstractMeshDataInfo._facetData.facetDepthSort;
  }
  set mustDepthSortFacets(sort) {
    this._internalAbstractMeshDataInfo._facetData.facetDepthSort = sort;
  }
  /**
   * The location (Vector3) where the facet depth sort must be computed from.
   * By default, the active camera position.
   * Used only when facet depth sort is enabled
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#facet-depth-sort
   */
  get facetDepthSortFrom() {
    return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom;
  }
  set facetDepthSortFrom(location) {
    this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom = location;
  }
  /** number of collision detection tries. Change this value if not all collisions are detected and handled properly */
  get collisionRetryCount() {
    return this._internalAbstractMeshDataInfo._collisionRetryCount;
  }
  set collisionRetryCount(retryCount) {
    this._internalAbstractMeshDataInfo._collisionRetryCount = retryCount;
  }
  /**
   * gets a boolean indicating if facetData is enabled
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData#what-is-a-mesh-facet
   */
  get isFacetDataEnabled() {
    return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled;
  }
  /**
   * Gets or sets the morph target manager
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/morphTargets
   */
  get morphTargetManager() {
    return this._internalAbstractMeshDataInfo._morphTargetManager;
  }
  set morphTargetManager(value) {
    if (this._internalAbstractMeshDataInfo._morphTargetManager === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._morphTargetManager = value;
    this._syncGeometryWithMorphTargetManager();
  }
  /**
   * Gets or sets the baked vertex animation manager
   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/baked_texture_animations
   */
  get bakedVertexAnimationManager() {
    return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager;
  }
  set bakedVertexAnimationManager(value) {
    if (this._internalAbstractMeshDataInfo._bakedVertexAnimationManager === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._bakedVertexAnimationManager = value;
    this._markSubMeshesAsAttributesDirty();
  }
  /** @internal */
  _syncGeometryWithMorphTargetManager() {
  }
  /**
   * @internal
   */
  _updateNonUniformScalingState(value) {
    if (!super._updateNonUniformScalingState(value)) {
      return false;
    }
    this._markSubMeshesAsMiscDirty();
    return true;
  }
  /** @internal */
  get rawBoundingInfo() {
    return this._internalAbstractMeshDataInfo._rawBoundingInfo;
  }
  set rawBoundingInfo(boundingInfo) {
    this._internalAbstractMeshDataInfo._rawBoundingInfo = boundingInfo;
  }
  /** Set a function to call when this mesh collides with another one */
  set onCollide(callback) {
    if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver) {
      this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver);
    }
    this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver = this.onCollideObservable.add(callback);
  }
  /** Set a function to call when the collision's position changes */
  set onCollisionPositionChange(callback) {
    if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver) {
      this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver);
    }
    this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(callback);
  }
  /**
   * Gets or sets mesh visibility between 0 and 1 (default is 1)
   */
  get visibility() {
    return this._internalAbstractMeshDataInfo._visibility;
  }
  /**
   * Gets or sets mesh visibility between 0 and 1 (default is 1)
   */
  set visibility(value) {
    if (this._internalAbstractMeshDataInfo._visibility === value) {
      return;
    }
    const oldValue = this._internalAbstractMeshDataInfo._visibility;
    this._internalAbstractMeshDataInfo._visibility = value;
    if (oldValue === 1 && value !== 1 || oldValue !== 1 && value === 1) {
      this._markSubMeshesAsDirty((defines) => {
        defines.markAsMiscDirty();
        defines.markAsPrePassDirty();
      });
    }
  }
  /**
   * If set to true, a mesh will only be visible only if its parent(s) are also visible (default is false)
   */
  get inheritVisibility() {
    return this._internalAbstractMeshDataInfo._inheritVisibility;
  }
  set inheritVisibility(value) {
    this._internalAbstractMeshDataInfo._inheritVisibility = value;
  }
  /**
   * Gets or sets a boolean indicating if the mesh is visible (renderable). Default is true
   */
  get isVisible() {
    if (!this._isVisible || !this.inheritVisibility || !this._parentNode) {
      return this._isVisible;
    }
    if (this._isVisible) {
      let parent = this._parentNode;
      while (parent) {
        const parentVisible = parent.isVisible;
        if (typeof parentVisible !== "undefined") {
          return parentVisible;
        }
        parent = parent.parent;
      }
    }
    return this._isVisible;
  }
  set isVisible(value) {
    this._isVisible = value;
  }
  /**
   * Gets or sets the property which disables the test that is checking that the mesh under the pointer is the same than the previous time we tested for it (default: false).
   * Set this property to true if you want thin instances picking to be reported accurately when moving over the mesh.
   * Note that setting this property to true will incur some performance penalties when dealing with pointer events for this mesh so use it sparingly.
   */
  get pointerOverDisableMeshTesting() {
    return this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting;
  }
  set pointerOverDisableMeshTesting(disable) {
    this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting = disable;
  }
  /**
   * Specifies the rendering group id for this mesh (0 by default)
   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering#rendering-groups
   */
  get renderingGroupId() {
    return this._internalAbstractMeshDataInfo._renderingGroupId;
  }
  set renderingGroupId(value) {
    this._internalAbstractMeshDataInfo._renderingGroupId = value;
  }
  /** Gets or sets current material */
  get material() {
    return this._internalAbstractMeshDataInfo._material;
  }
  set material(value) {
    this._setMaterial(value);
  }
  /** @internal */
  _setMaterial(value) {
    if (this._internalAbstractMeshDataInfo._material === value) {
      return;
    }
    if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {
      this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0;
    }
    this._internalAbstractMeshDataInfo._material = value;
    if (value && value.meshMap) {
      value.meshMap[this.uniqueId] = this;
    }
    if (this.onMaterialChangedObservable.hasObservers()) {
      this.onMaterialChangedObservable.notifyObservers(this);
    }
    if (!this.subMeshes) {
      return;
    }
    this.resetDrawCache(void 0, value == null);
    this._unBindEffect();
  }
  /**
   * Gets the material used to render the mesh in a specific render pass
   * @param renderPassId render pass id
   * @returns material used for the render pass. If no specific material is used for this render pass, undefined is returned (meaning mesh.material is used for this pass)
   */
  getMaterialForRenderPass(renderPassId) {
    var _a;
    return (_a = this._internalAbstractMeshDataInfo._materialForRenderPass) == null ? void 0 : _a[renderPassId];
  }
  /**
   * Sets the material to be used to render the mesh in a specific render pass
   * @param renderPassId render pass id
   * @param material material to use for this render pass. If undefined is passed, no specific material will be used for this render pass but the regular material will be used instead (mesh.material)
   */
  setMaterialForRenderPass(renderPassId, material) {
    var _a;
    this.resetDrawCache(renderPassId);
    if (!this._internalAbstractMeshDataInfo._materialForRenderPass) {
      this._internalAbstractMeshDataInfo._materialForRenderPass = [];
    }
    const currentMaterial = this._internalAbstractMeshDataInfo._materialForRenderPass[renderPassId];
    if ((_a = currentMaterial == null ? void 0 : currentMaterial.meshMap) == null ? void 0 : _a[this.uniqueId]) {
      currentMaterial.meshMap[this.uniqueId] = void 0;
    }
    this._internalAbstractMeshDataInfo._materialForRenderPass[renderPassId] = material;
    if (material && material.meshMap) {
      material.meshMap[this.uniqueId] = this;
    }
  }
  /**
   * Gets or sets a boolean indicating that this mesh can receive realtime shadows
   * @see https://doc.babylonjs.com/features/featuresDeepDive/lights/shadows
   */
  get receiveShadows() {
    return this._internalAbstractMeshDataInfo._receiveShadows;
  }
  set receiveShadows(value) {
    if (this._internalAbstractMeshDataInfo._receiveShadows === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._receiveShadows = value;
    this._markSubMeshesAsLightDirty();
  }
  /**
   * Gets or sets a boolean indicating that this mesh needs to use vertex alpha data to render.
   * This property is misnamed and should be `useVertexAlpha`. Note that the mesh will be rendered
   * with alpha blending when this flag is set even if vertex alpha data is missing from the geometry.
   */
  get hasVertexAlpha() {
    return this._internalAbstractMeshDataInfo._hasVertexAlpha;
  }
  set hasVertexAlpha(value) {
    if (this._internalAbstractMeshDataInfo._hasVertexAlpha === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._hasVertexAlpha = value;
    this._markSubMeshesAsAttributesDirty();
    this._markSubMeshesAsMiscDirty();
  }
  /** Gets or sets a boolean indicating that this mesh needs to use vertex color data to render (if this kind of vertex data is available in the geometry) */
  get useVertexColors() {
    return this._internalAbstractMeshDataInfo._useVertexColors;
  }
  set useVertexColors(value) {
    if (this._internalAbstractMeshDataInfo._useVertexColors === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._useVertexColors = value;
    this._markSubMeshesAsAttributesDirty();
  }
  /**
   * Gets or sets a boolean indicating that bone animations must be computed by the GPU (true by default)
   */
  get computeBonesUsingShaders() {
    return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;
  }
  set computeBonesUsingShaders(value) {
    if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;
    this._markSubMeshesAsAttributesDirty();
  }
  /** Gets or sets the number of allowed bone influences per vertex (4 by default) */
  get numBoneInfluencers() {
    return this._internalAbstractMeshDataInfo._numBoneInfluencers;
  }
  set numBoneInfluencers(value) {
    if (this._internalAbstractMeshDataInfo._numBoneInfluencers === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._numBoneInfluencers = value;
    this._markSubMeshesAsAttributesDirty();
  }
  /** Gets or sets a boolean indicating that this mesh will allow fog to be rendered on it (true by default) */
  get applyFog() {
    return this._internalAbstractMeshDataInfo._applyFog;
  }
  set applyFog(value) {
    if (this._internalAbstractMeshDataInfo._applyFog === value) {
      return;
    }
    this._internalAbstractMeshDataInfo._applyFog = value;
    this._markSubMeshesAsMiscDirty();
  }
  /** When enabled, decompose picking matrices for better precision with large values for mesh position and scling */
  get enableDistantPicking() {
    return this._internalAbstractMeshDataInfo._enableDistantPicking;
  }
  set enableDistantPicking(value) {
    this._internalAbstractMeshDataInfo._enableDistantPicking = value;
  }
  /**
   * Gets or sets the current layer mask (default is 0x0FFFFFFF)
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/layerMasksAndMultiCam
   */
  get layerMask() {
    return this._internalAbstractMeshDataInfo._layerMask;
  }
  set layerMask(value) {
    if (value === this._internalAbstractMeshDataInfo._layerMask) {
      return;
    }
    this._internalAbstractMeshDataInfo._layerMask = value;
    this._resyncLightSources();
  }
  /**
   * Gets or sets a collision mask used to mask collisions (default is -1).
   * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0
   */
  get collisionMask() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask;
  }
  set collisionMask(mask) {
    this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask = !isNaN(mask) ? mask : -1;
  }
  /**
   * Gets or sets a collision response flag (default is true).
   * when collisionResponse is false, events are still triggered but colliding entity has no response
   * This helps creating trigger volume when user wants collision feedback events but not position/velocity
   * to respond to the collision.
   */
  get collisionResponse() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse;
  }
  set collisionResponse(response) {
    this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse = response;
  }
  /**
   * Gets or sets the current collision group mask (-1 by default).
   * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0
   */
  get collisionGroup() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup;
  }
  set collisionGroup(mask) {
    this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup = !isNaN(mask) ? mask : -1;
  }
  /**
   * Gets or sets current surrounding meshes (null by default).
   *
   * By default collision detection is tested against every mesh in the scene.
   * It is possible to set surroundingMeshes to a defined list of meshes and then only these specified
   * meshes will be tested for the collision.
   *
   * Note: if set to an empty array no collision will happen when this mesh is moved.
   */
  get surroundingMeshes() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes;
  }
  set surroundingMeshes(meshes) {
    this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes = meshes;
  }
  /** Gets the list of lights affecting that mesh */
  get lightSources() {
    return this._lightSources;
  }
  /**
   * Gets or sets a skeleton to apply skinning transformations
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons
   */
  set skeleton(value) {
    const skeleton = this._internalAbstractMeshDataInfo._skeleton;
    if (skeleton && skeleton.needInitialSkinMatrix) {
      skeleton._unregisterMeshWithPoseMatrix(this);
    }
    if (value && value.needInitialSkinMatrix) {
      value._registerMeshWithPoseMatrix(this);
    }
    this._internalAbstractMeshDataInfo._skeleton = value;
    if (!this._internalAbstractMeshDataInfo._skeleton) {
      this._bonesTransformMatrices = null;
    }
    this._markSubMeshesAsAttributesDirty();
  }
  get skeleton() {
    return this._internalAbstractMeshDataInfo._skeleton;
  }
  // Constructor
  /**
   * Creates a new AbstractMesh
   * @param name defines the name of the mesh
   * @param scene defines the hosting scene
   */
  constructor(name, scene = null) {
    super(name, scene, false);
    this._internalAbstractMeshDataInfo = new _InternalAbstractMeshDataInfo();
    this._waitingMaterialId = null;
    this._waitingMorphTargetManagerId = null;
    this.cullingStrategy = _AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;
    this.onCollideObservable = new Observable();
    this.onCollisionPositionChangeObservable = new Observable();
    this.onMaterialChangedObservable = new Observable();
    this.definedFacingForward = true;
    this._occlusionQuery = null;
    this._renderingGroup = null;
    this.alphaIndex = Number.MAX_VALUE;
    this._isVisible = true;
    this.isPickable = true;
    this.isNearPickable = false;
    this.isNearGrabbable = false;
    this.showSubMeshesBoundingBox = false;
    this.isBlocker = false;
    this.enablePointerMoveEvents = false;
    this.outlineColor = Color3.Red();
    this.outlineWidth = 0.02;
    this.overlayColor = Color3.Red();
    this.overlayAlpha = 0.5;
    this.useOctreeForRenderingSelection = true;
    this.useOctreeForPicking = true;
    this.useOctreeForCollisions = true;
    this.alwaysSelectAsActiveMesh = false;
    this.doNotSyncBoundingInfo = false;
    this.actionManager = null;
    this.ellipsoid = new Vector3(0.5, 1, 0.5);
    this.ellipsoidOffset = new Vector3(0, 0, 0);
    this.edgesWidth = 1;
    this.edgesColor = new Color4(1, 0, 0, 1);
    this._edgesRenderer = null;
    this._masterMesh = null;
    this._boundingInfo = null;
    this._boundingInfoIsDirty = true;
    this._renderId = 0;
    this._intersectionsInProgress = new Array();
    this._unIndexed = false;
    this._lightSources = new Array();
    this._waitingData = {
      lods: null,
      actions: null,
      freezeWorldMatrix: null
    };
    this._bonesTransformMatrices = null;
    this._transformMatrixTexture = null;
    this.onRebuildObservable = new Observable();
    this._onCollisionPositionChange = (collisionId, newPosition, collidedMesh = null) => {
      newPosition.subtractToRef(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions);
      if (this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length() > AbstractEngine.CollisionsEpsilon) {
        this.position.addInPlace(this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions);
      }
      if (collidedMesh) {
        this.onCollideObservable.notifyObservers(collidedMesh);
      }
      this.onCollisionPositionChangeObservable.notifyObservers(this.position);
    };
    scene = this.getScene();
    scene.addMesh(this);
    this._resyncLightSources();
    this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), void 0, void 0, name, !this.getScene().getEngine().isWebGPU);
    this._buildUniformLayout();
    switch (scene.performancePriority) {
      case 2:
        this.doNotSyncBoundingInfo = true;
      case 1:
        this.alwaysSelectAsActiveMesh = true;
        this.isPickable = false;
        break;
    }
  }
  _buildUniformLayout() {
    this._uniformBuffer.addUniform("world", 16);
    this._uniformBuffer.addUniform("visibility", 1);
    this._uniformBuffer.create();
  }
  /**
   * Transfer the mesh values to its UBO.
   * @param world The world matrix associated with the mesh
   */
  transferToEffect(world) {
    const ubo = this._uniformBuffer;
    ubo.updateMatrix("world", world);
    ubo.updateFloat("visibility", this._internalAbstractMeshDataInfo._visibility);
    ubo.update();
  }
  /**
   * Gets the mesh uniform buffer.
   * @returns the uniform buffer of the mesh.
   */
  getMeshUniformBuffer() {
    return this._uniformBuffer;
  }
  /**
   * Returns the string "AbstractMesh"
   * @returns "AbstractMesh"
   */
  getClassName() {
    return "AbstractMesh";
  }
  /**
   * Gets a string representation of the current mesh
   * @param fullDetails defines a boolean indicating if full details must be included
   * @returns a string representation of the current mesh
   */
  toString(fullDetails) {
    let ret = "Name: " + this.name + ", isInstance: " + (this.getClassName() !== "InstancedMesh" ? "YES" : "NO");
    ret += ", # of submeshes: " + (this.subMeshes ? this.subMeshes.length : 0);
    const skeleton = this._internalAbstractMeshDataInfo._skeleton;
    if (skeleton) {
      ret += ", skeleton: " + skeleton.name;
    }
    if (fullDetails) {
      ret += ", billboard mode: " + ["NONE", "X", "Y", null, "Z", null, null, "ALL"][this.billboardMode];
      ret += ", freeze wrld mat: " + (this._isWorldMatrixFrozen || this._waitingData.freezeWorldMatrix ? "YES" : "NO");
    }
    return ret;
  }
  /**
   * @internal
   */
  _getEffectiveParent() {
    if (this._masterMesh && this.billboardMode !== TransformNode.BILLBOARDMODE_NONE) {
      return this._masterMesh;
    }
    return super._getEffectiveParent();
  }
  /**
   * @internal
   */
  _getActionManagerForTrigger(trigger, initialCall = true) {
    if (this.actionManager && (initialCall || this.actionManager.isRecursive)) {
      if (trigger) {
        if (this.actionManager.hasSpecificTrigger(trigger)) {
          return this.actionManager;
        }
      } else {
        return this.actionManager;
      }
    }
    if (!this.parent) {
      return null;
    }
    return this.parent._getActionManagerForTrigger(trigger, false);
  }
  /**
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _rebuild(dispose = false) {
    this.onRebuildObservable.notifyObservers(this);
    if (this._occlusionQuery !== null) {
      this._occlusionQuery = null;
    }
    if (!this.subMeshes) {
      return;
    }
    for (const subMesh of this.subMeshes) {
      subMesh._rebuild();
    }
    this.resetDrawCache();
  }
  /** @internal */
  _resyncLightSources() {
    this._lightSources.length = 0;
    for (const light of this.getScene().lights) {
      if (!light.isEnabled()) {
        continue;
      }
      if (light.canAffectMesh(this)) {
        this._lightSources.push(light);
      }
    }
    this._markSubMeshesAsLightDirty();
  }
  /**
   * @internal
   */
  _resyncLightSource(light) {
    const isIn = light.isEnabled() && light.canAffectMesh(this);
    const index = this._lightSources.indexOf(light);
    let removed = false;
    if (index === -1) {
      if (!isIn) {
        return;
      }
      this._lightSources.push(light);
    } else {
      if (isIn) {
        return;
      }
      removed = true;
      this._lightSources.splice(index, 1);
    }
    this._markSubMeshesAsLightDirty(removed);
  }
  /** @internal */
  _unBindEffect() {
    for (const subMesh of this.subMeshes) {
      subMesh.setEffect(null);
    }
  }
  /**
   * @internal
   */
  _removeLightSource(light, dispose) {
    const index = this._lightSources.indexOf(light);
    if (index === -1) {
      return;
    }
    this._lightSources.splice(index, 1);
    this._markSubMeshesAsLightDirty(dispose);
  }
  _markSubMeshesAsDirty(func) {
    if (!this.subMeshes) {
      return;
    }
    for (const subMesh of this.subMeshes) {
      for (let i = 0; i < subMesh._drawWrappers.length; ++i) {
        const drawWrapper = subMesh._drawWrappers[i];
        if (!drawWrapper || !drawWrapper.defines || !drawWrapper.defines.markAllAsDirty) {
          continue;
        }
        func(drawWrapper.defines);
      }
    }
  }
  /**
   * @internal
   */
  _markSubMeshesAsLightDirty(dispose = false) {
    this._markSubMeshesAsDirty((defines) => defines.markAsLightDirty(dispose));
  }
  /** @internal */
  _markSubMeshesAsAttributesDirty() {
    this._markSubMeshesAsDirty((defines) => defines.markAsAttributesDirty());
  }
  /** @internal */
  _markSubMeshesAsMiscDirty() {
    this._markSubMeshesAsDirty((defines) => defines.markAsMiscDirty());
  }
  /**
   * Flag the AbstractMesh as dirty (Forcing it to update everything)
   * @param property if set to "rotation" the objects rotationQuaternion will be set to null
   * @returns this AbstractMesh
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  markAsDirty(property) {
    this._currentRenderId = Number.MAX_VALUE;
    super.markAsDirty(property);
    this._isDirty = true;
    return this;
  }
  /**
   * Resets the draw wrappers cache for all submeshes of this abstract mesh
   * @param passId If provided, releases only the draw wrapper corresponding to this render pass id
   * @param immediate If true, the effect will be released immediately, otherwise it will be released at the next frame
   */
  resetDrawCache(passId, immediate = false) {
    if (!this.subMeshes) {
      return;
    }
    for (const subMesh of this.subMeshes) {
      subMesh.resetDrawCache(passId, immediate);
    }
  }
  // Methods
  /**
   * Returns true if the mesh is blocked. Implemented by child classes
   */
  get isBlocked() {
    return false;
  }
  /**
   * Returns the mesh itself by default. Implemented by child classes
   * @param camera defines the camera to use to pick the right LOD level
   * @returns the currentAbstractMesh
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getLOD(camera) {
    return this;
  }
  /**
   * Returns 0 by default. Implemented by child classes
   * @returns an integer
   */
  getTotalVertices() {
    return 0;
  }
  /**
   * Returns a positive integer : the total number of indices in this mesh geometry.
   * @returns the number of indices or zero if the mesh has no geometry.
   */
  getTotalIndices() {
    return 0;
  }
  /**
   * Returns null by default. Implemented by child classes
   * @returns null
   */
  getIndices() {
    return null;
  }
  /**
   * Returns the array of the requested vertex data kind. Implemented by child classes
   * @param kind defines the vertex data kind to use
   * @returns null
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getVerticesData(kind) {
    return null;
  }
  /**
   * Sets the vertex data of the mesh geometry for the requested `kind`.
   * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.
   * Note that a new underlying VertexBuffer object is created each call.
   * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
   * @param kind defines vertex data kind:
   * * VertexBuffer.PositionKind
   * * VertexBuffer.UVKind
   * * VertexBuffer.UV2Kind
   * * VertexBuffer.UV3Kind
   * * VertexBuffer.UV4Kind
   * * VertexBuffer.UV5Kind
   * * VertexBuffer.UV6Kind
   * * VertexBuffer.ColorKind
   * * VertexBuffer.MatricesIndicesKind
   * * VertexBuffer.MatricesIndicesExtraKind
   * * VertexBuffer.MatricesWeightsKind
   * * VertexBuffer.MatricesWeightsExtraKind
   * @param data defines the data source
   * @param updatable defines if the data must be flagged as updatable (or static)
   * @param stride defines the vertex stride (size of an entire vertex). Can be null and in this case will be deduced from vertex data kind
   * @returns the current mesh
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setVerticesData(kind, data, updatable, stride) {
    return this;
  }
  /**
   * Updates the existing vertex data of the mesh geometry for the requested `kind`.
   * If the mesh has no geometry, it is simply returned as it is.
   * @param kind defines vertex data kind:
   * * VertexBuffer.PositionKind
   * * VertexBuffer.UVKind
   * * VertexBuffer.UV2Kind
   * * VertexBuffer.UV3Kind
   * * VertexBuffer.UV4Kind
   * * VertexBuffer.UV5Kind
   * * VertexBuffer.UV6Kind
   * * VertexBuffer.ColorKind
   * * VertexBuffer.MatricesIndicesKind
   * * VertexBuffer.MatricesIndicesExtraKind
   * * VertexBuffer.MatricesWeightsKind
   * * VertexBuffer.MatricesWeightsExtraKind
   * @param data defines the data source
   * @param updateExtends If `kind` is `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed
   * @param makeItUnique If true, a new global geometry is created from this data and is set to the mesh
   * @returns the current mesh
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  updateVerticesData(kind, data, updateExtends, makeItUnique) {
    return this;
  }
  /**
   * Sets the mesh indices,
   * If the mesh has no geometry, a new Geometry object is created and set to the mesh.
   * @param indices Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array)
   * @param totalVertices Defines the total number of vertices
   * @returns the current mesh
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setIndices(indices, totalVertices) {
    return this;
  }
  /**
   * Gets a boolean indicating if specific vertex data is present
   * @param kind defines the vertex data kind to use
   * @returns true is data kind is present
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  isVerticesDataPresent(kind) {
    return false;
  }
  /**
   * Returns the mesh BoundingInfo object or creates a new one and returns if it was undefined.
   * Note that it returns a shallow bounding of the mesh (i.e. it does not include children).
   * However, if the mesh contains thin instances, it will be expanded to include them. If you want the "raw" bounding data instead, then use `getRawBoundingInfo()`.
   * To get the full bounding of all children, call `getHierarchyBoundingVectors` instead.
   * @returns a BoundingInfo
   */
  getBoundingInfo() {
    if (this._masterMesh) {
      return this._masterMesh.getBoundingInfo();
    }
    if (this._boundingInfoIsDirty) {
      this._boundingInfoIsDirty = false;
      this._updateBoundingInfo();
    }
    return this._boundingInfo;
  }
  /**
   * Returns the bounding info unnafected by instance data.
   * @returns the bounding info of the mesh unaffected by instance data.
   */
  getRawBoundingInfo() {
    return this.rawBoundingInfo ?? this.getBoundingInfo();
  }
  /**
   * Overwrite the current bounding info
   * @param boundingInfo defines the new bounding info
   * @returns the current mesh
   */
  setBoundingInfo(boundingInfo) {
    this._boundingInfo = boundingInfo;
    return this;
  }
  /**
   * Returns true if there is already a bounding info
   */
  get hasBoundingInfo() {
    return this._boundingInfo !== null;
  }
  /**
   * Creates a new bounding info for the mesh
   * @param minimum min vector of the bounding box/sphere
   * @param maximum max vector of the bounding box/sphere
   * @param worldMatrix defines the new world matrix
   * @returns the new bounding info
   */
  buildBoundingInfo(minimum, maximum, worldMatrix) {
    this._boundingInfo = new BoundingInfo(minimum, maximum, worldMatrix);
    return this._boundingInfo;
  }
  /**
   * Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)
   * @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false
   * @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false
   * @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling
   * @returns the current mesh
   */
  normalizeToUnitCube(includeDescendants = true, ignoreRotation = false, predicate) {
    return super.normalizeToUnitCube(includeDescendants, ignoreRotation, predicate);
  }
  /** Gets a boolean indicating if this mesh has skinning data and an attached skeleton */
  get useBones() {
    return this.skeleton && this.getScene().skeletonsEnabled && this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind) && this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind);
  }
  /** @internal */
  _preActivate() {
  }
  /**
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _preActivateForIntermediateRendering(renderId) {
  }
  /**
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _activate(renderId, intermediateRendering) {
    this._renderId = renderId;
    return true;
  }
  /** @internal */
  _postActivate() {
  }
  /** @internal */
  _freeze() {
  }
  /** @internal */
  _unFreeze() {
  }
  /**
   * Gets the current world matrix
   * @returns a Matrix
   */
  getWorldMatrix() {
    if (this._masterMesh && this.billboardMode === TransformNode.BILLBOARDMODE_NONE) {
      return this._masterMesh.getWorldMatrix();
    }
    return super.getWorldMatrix();
  }
  /** @internal */
  _getWorldMatrixDeterminant() {
    if (this._masterMesh) {
      return this._masterMesh._getWorldMatrixDeterminant();
    }
    return super._getWorldMatrixDeterminant();
  }
  /**
   * Gets a boolean indicating if this mesh is an instance or a regular mesh
   */
  get isAnInstance() {
    return false;
  }
  /**
   * Gets a boolean indicating if this mesh has instances
   */
  get hasInstances() {
    return false;
  }
  /**
   * Gets a boolean indicating if this mesh has thin instances
   */
  get hasThinInstances() {
    return false;
  }
  // ================================== Point of View Movement =================================
  /**
   * Perform relative position change from the point of view of behind the front of the mesh.
   * This is performed taking into account the meshes current rotation, so you do not have to care.
   * Supports definition of mesh facing forward or backward {@link definedFacingForwardSearch | See definedFacingForwardSearch }.
   * @param amountRight defines the distance on the right axis
   * @param amountUp defines the distance on the up axis
   * @param amountForward defines the distance on the forward axis
   * @returns the current mesh
   */
  movePOV(amountRight, amountUp, amountForward) {
    this.position.addInPlace(this.calcMovePOV(amountRight, amountUp, amountForward));
    return this;
  }
  /**
   * Calculate relative position change from the point of view of behind the front of the mesh.
   * This is performed taking into account the meshes current rotation, so you do not have to care.
   * Supports definition of mesh facing forward or backward {@link definedFacingForwardSearch | See definedFacingForwardSearch }.
   * @param amountRight defines the distance on the right axis
   * @param amountUp defines the distance on the up axis
   * @param amountForward defines the distance on the forward axis
   * @returns the new displacement vector
   */
  calcMovePOV(amountRight, amountUp, amountForward) {
    const rotMatrix = new Matrix();
    const rotQuaternion = this.rotationQuaternion ? this.rotationQuaternion : Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);
    rotQuaternion.toRotationMatrix(rotMatrix);
    const translationDelta = Vector3.Zero();
    const defForwardMult = this.definedFacingForward ? -1 : 1;
    Vector3.TransformCoordinatesFromFloatsToRef(amountRight * defForwardMult, amountUp, amountForward * defForwardMult, rotMatrix, translationDelta);
    return translationDelta;
  }
  // ================================== Point of View Rotation =================================
  /**
   * Perform relative rotation change from the point of view of behind the front of the mesh.
   * Supports definition of mesh facing forward or backward {@link definedFacingForwardSearch | See definedFacingForwardSearch }.
   * @param flipBack defines the flip
   * @param twirlClockwise defines the twirl
   * @param tiltRight defines the tilt
   * @returns the current mesh
   */
  rotatePOV(flipBack, twirlClockwise, tiltRight) {
    this.rotation.addInPlace(this.calcRotatePOV(flipBack, twirlClockwise, tiltRight));
    return this;
  }
  /**
   * Calculate relative rotation change from the point of view of behind the front of the mesh.
   * Supports definition of mesh facing forward or backward {@link definedFacingForwardSearch | See definedFacingForwardSearch }.
   * @param flipBack defines the flip
   * @param twirlClockwise defines the twirl
   * @param tiltRight defines the tilt
   * @returns the new rotation vector
   */
  calcRotatePOV(flipBack, twirlClockwise, tiltRight) {
    const defForwardMult = this.definedFacingForward ? 1 : -1;
    return new Vector3(flipBack * defForwardMult, twirlClockwise, tiltRight * defForwardMult);
  }
  /**
   * @internal
   */
  _refreshBoundingInfo(data, bias) {
    if (data) {
      const extend = extractMinAndMax(data, 0, this.getTotalVertices(), bias);
      if (this._boundingInfo) {
        this._boundingInfo.reConstruct(extend.minimum, extend.maximum);
      } else {
        this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);
      }
    }
    if (this.subMeshes) {
      for (let index = 0; index < this.subMeshes.length; index++) {
        this.subMeshes[index].refreshBoundingInfo(data);
      }
    }
    this._updateBoundingInfo();
  }
  /**
   * @internal
   */
  _refreshBoundingInfoDirect(extend) {
    if (this._boundingInfo) {
      this._boundingInfo.reConstruct(extend.minimum, extend.maximum);
    } else {
      this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);
    }
    if (this.subMeshes) {
      for (let index = 0; index < this.subMeshes.length; index++) {
        this.subMeshes[index].refreshBoundingInfo(null);
      }
    }
    this._updateBoundingInfo();
  }
  // This function is only here so we can apply the nativeOverride decorator.
  static _ApplySkeleton(data, kind, skeletonMatrices, matricesIndicesData, matricesWeightsData, matricesIndicesExtraData, matricesWeightsExtraData) {
    applySkeleton(data, kind, skeletonMatrices, matricesIndicesData, matricesWeightsData, matricesIndicesExtraData, matricesWeightsExtraData);
  }
  /** @internal */
  _getData(options, data, kind = VertexBuffer.PositionKind) {
    const cache = options.cache;
    const getVertexData = (kind2) => {
      if (cache) {
        const vertexData = cache._vertexData || (cache._vertexData = {});
        if (!vertexData[kind2]) {
          this.copyVerticesData(kind2, vertexData);
        }
        return vertexData[kind2];
      }
      return this.getVerticesData(kind2);
    };
    data || (data = getVertexData(kind));
    if (!data) {
      return null;
    }
    if (cache) {
      if (cache._outputData) {
        cache._outputData.set(data);
      } else {
        cache._outputData = new Float32Array(data);
      }
      data = cache._outputData;
    } else if (options.applyMorph && this.morphTargetManager || options.applySkeleton && this.skeleton) {
      data = data.slice();
    }
    if (options.applyMorph && this.morphTargetManager) {
      applyMorph(data, kind, this.morphTargetManager);
    }
    if (options.applySkeleton && this.skeleton) {
      const matricesIndicesData = getVertexData(VertexBuffer.MatricesIndicesKind);
      const matricesWeightsData = getVertexData(VertexBuffer.MatricesWeightsKind);
      if (matricesWeightsData && matricesIndicesData) {
        const needExtras = this.numBoneInfluencers > 4;
        const matricesIndicesExtraData = needExtras ? getVertexData(VertexBuffer.MatricesIndicesExtraKind) : null;
        const matricesWeightsExtraData = needExtras ? getVertexData(VertexBuffer.MatricesWeightsExtraKind) : null;
        const skeletonMatrices = this.skeleton.getTransformMatrices(this);
        _AbstractMesh._ApplySkeleton(data, kind, skeletonMatrices, matricesIndicesData, matricesWeightsData, matricesIndicesExtraData, matricesWeightsExtraData);
      }
    }
    if (options.updatePositionsArray !== false && kind === VertexBuffer.PositionKind) {
      const positions = this._internalAbstractMeshDataInfo._positions || [];
      const previousLength = positions.length;
      positions.length = data.length / 3;
      if (previousLength < positions.length) {
        for (let positionIndex = previousLength; positionIndex < positions.length; positionIndex++) {
          positions[positionIndex] = new Vector3();
        }
      }
      for (let positionIndex = 0, dataIndex = 0; positionIndex < positions.length; positionIndex++, dataIndex += 3) {
        positions[positionIndex].copyFromFloats(data[dataIndex], data[dataIndex + 1], data[dataIndex + 2]);
      }
      this._internalAbstractMeshDataInfo._positions = positions;
    }
    return data;
  }
  /**
   * Get the normals vertex data and optionally apply skeleton and morphing.
   * @param applySkeleton defines whether to apply the skeleton
   * @param applyMorph  defines whether to apply the morph target
   * @returns the normals data
   */
  getNormalsData(applySkeleton2 = false, applyMorph2 = false) {
    return this._getData({ applySkeleton: applySkeleton2, applyMorph: applyMorph2, updatePositionsArray: false }, null, VertexBuffer.NormalKind);
  }
  /**
   * Get the position vertex data and optionally apply skeleton and morphing.
   * @param applySkeleton defines whether to apply the skeleton
   * @param applyMorph  defines whether to apply the morph target
   * @param data defines the position data to apply the skeleton and morph to
   * @returns the position data
   */
  getPositionData(applySkeleton2 = false, applyMorph2 = false, data = null) {
    return this._getData({ applySkeleton: applySkeleton2, applyMorph: applyMorph2, updatePositionsArray: false }, data, VertexBuffer.PositionKind);
  }
  /** @internal */
  _updateBoundingInfo() {
    if (this._boundingInfo) {
      this._boundingInfo.update(this.worldMatrixFromCache);
    } else {
      this._boundingInfo = new BoundingInfo(Vector3.Zero(), Vector3.Zero(), this.worldMatrixFromCache);
    }
    this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
    return this;
  }
  /**
   * @internal
   */
  _updateSubMeshesBoundingInfo(matrix) {
    if (!this.subMeshes) {
      return this;
    }
    const count = this.subMeshes.length;
    for (let subIndex = 0; subIndex < count; subIndex++) {
      const subMesh = this.subMeshes[subIndex];
      if (count > 1 || !subMesh.IsGlobal) {
        subMesh.updateBoundingInfo(matrix);
      }
    }
    return this;
  }
  /** @internal */
  _afterComputeWorldMatrix() {
    if (this.doNotSyncBoundingInfo) {
      return;
    }
    this._boundingInfoIsDirty = true;
  }
  /**
   * Returns `true` if the mesh is within the frustum defined by the passed array of planes.
   * A mesh is in the frustum if its bounding box intersects the frustum
   * @param frustumPlanes defines the frustum to test
   * @returns true if the mesh is in the frustum planes
   */
  isInFrustum(frustumPlanes) {
    return this.getBoundingInfo().isInFrustum(frustumPlanes, this.cullingStrategy);
  }
  /**
   * Returns `true` if the mesh is completely in the frustum defined be the passed array of planes.
   * A mesh is completely in the frustum if its bounding box it completely inside the frustum.
   * @param frustumPlanes defines the frustum to test
   * @returns true if the mesh is completely in the frustum planes
   */
  isCompletelyInFrustum(frustumPlanes) {
    return this.getBoundingInfo().isCompletelyInFrustum(frustumPlanes);
  }
  /**
   * True if the mesh intersects another mesh or a SolidParticle object
   * @param mesh defines a target mesh or SolidParticle to test
   * @param precise Unless the parameter `precise` is set to `true` the intersection is computed according to Axis Aligned Bounding Boxes (AABB), else according to OBB (Oriented BBoxes)
   * @param includeDescendants Can be set to true to test if the mesh defined in parameters intersects with the current mesh or any child meshes
   * @returns true if there is an intersection
   */
  intersectsMesh(mesh, precise = false, includeDescendants) {
    const boundingInfo = this.getBoundingInfo();
    const otherBoundingInfo = mesh.getBoundingInfo();
    if (boundingInfo.intersects(otherBoundingInfo, precise)) {
      return true;
    }
    if (includeDescendants) {
      for (const child of this.getChildMeshes()) {
        if (child.intersectsMesh(mesh, precise, true)) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Returns true if the passed point (Vector3) is inside the mesh bounding box
   * @param point defines the point to test
   * @returns true if there is an intersection
   */
  intersectsPoint(point) {
    return this.getBoundingInfo().intersectsPoint(point);
  }
  // Collisions
  /**
   * Gets or sets a boolean indicating that this mesh can be used in the collision engine
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions
   */
  get checkCollisions() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions;
  }
  set checkCollisions(collisionEnabled) {
    this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions = collisionEnabled;
  }
  /**
   * Gets Collider object used to compute collisions (not physics)
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions
   */
  get collider() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._collider;
  }
  /**
   * Move the mesh using collision engine
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions
   * @param displacement defines the requested displacement vector
   * @returns the current mesh
   */
  moveWithCollisions(displacement) {
    const globalPosition = this.getAbsolutePosition();
    globalPosition.addToRef(this.ellipsoidOffset, this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions);
    const coordinator = this.getScene().collisionCoordinator;
    if (!this._internalAbstractMeshDataInfo._meshCollisionData._collider) {
      this._internalAbstractMeshDataInfo._meshCollisionData._collider = coordinator.createCollider();
    }
    this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius = this.ellipsoid;
    coordinator.getNewPosition(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, displacement, this._internalAbstractMeshDataInfo._meshCollisionData._collider, this.collisionRetryCount, this, this._onCollisionPositionChange, this.uniqueId);
    return this;
  }
  // Collisions
  /**
   * @internal
   */
  _collideForSubMesh(subMesh, transformMatrix, collider) {
    var _a;
    this._generatePointsArray();
    if (!this._positions) {
      return this;
    }
    if (!subMesh._lastColliderWorldVertices || !subMesh._lastColliderTransformMatrix.equals(transformMatrix)) {
      subMesh._lastColliderTransformMatrix = transformMatrix.clone();
      subMesh._lastColliderWorldVertices = [];
      subMesh._trianglePlanes = [];
      const start = subMesh.verticesStart;
      const end = subMesh.verticesStart + subMesh.verticesCount;
      for (let i = start; i < end; i++) {
        subMesh._lastColliderWorldVertices.push(Vector3.TransformCoordinates(this._positions[i], transformMatrix));
      }
    }
    collider._collide(subMesh._trianglePlanes, subMesh._lastColliderWorldVertices, this.getIndices(), subMesh.indexStart, subMesh.indexStart + subMesh.indexCount, subMesh.verticesStart, !!subMesh.getMaterial(), this, this._shouldConvertRHS(), ((_a = subMesh.getMaterial()) == null ? void 0 : _a.fillMode) === 7);
    return this;
  }
  /**
   * @internal
   */
  _processCollisionsForSubMeshes(collider, transformMatrix) {
    const subMeshes = this._scene.getCollidingSubMeshCandidates(this, collider);
    const len = subMeshes.length;
    for (let index = 0; index < len; index++) {
      const subMesh = subMeshes.data[index];
      if (len > 1 && !subMesh._checkCollision(collider)) {
        continue;
      }
      this._collideForSubMesh(subMesh, transformMatrix, collider);
    }
    return this;
  }
  /** @internal */
  _shouldConvertRHS() {
    return false;
  }
  /**
   * @internal
   */
  _checkCollision(collider) {
    if (!this.getBoundingInfo()._checkCollision(collider)) {
      return this;
    }
    const collisionsScalingMatrix = TmpVectors.Matrix[0];
    const collisionsTransformMatrix = TmpVectors.Matrix[1];
    Matrix.ScalingToRef(1 / collider._radius.x, 1 / collider._radius.y, 1 / collider._radius.z, collisionsScalingMatrix);
    this.worldMatrixFromCache.multiplyToRef(collisionsScalingMatrix, collisionsTransformMatrix);
    this._processCollisionsForSubMeshes(collider, collisionsTransformMatrix);
    return this;
  }
  // Picking
  /** @internal */
  _generatePointsArray() {
    return false;
  }
  /**
   * Checks if the passed Ray intersects with the mesh. A mesh triangle can be picked both from its front and back sides,
   * irrespective of orientation.
   * @param ray defines the ray to use. It should be in the mesh's LOCAL coordinate space.
   * @param fastCheck defines if fast mode (but less precise) must be used (false by default)
   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
   * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)
   * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point
   * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check
   * @returns the picking info
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect
   */
  intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo = false, worldToUse, skipBoundingInfo = false) {
    const pickingInfo = new PickingInfo();
    const className = this.getClassName();
    const intersectionThreshold = className === "InstancedLinesMesh" || className === "LinesMesh" || className === "GreasedLineMesh" ? this.intersectionThreshold : 0;
    const boundingInfo = this.getBoundingInfo();
    if (!this.subMeshes) {
      return pickingInfo;
    }
    if (!skipBoundingInfo && (!ray.intersectsSphere(boundingInfo.boundingSphere, intersectionThreshold) || !ray.intersectsBox(boundingInfo.boundingBox, intersectionThreshold))) {
      return pickingInfo;
    }
    if (onlyBoundingInfo) {
      pickingInfo.hit = skipBoundingInfo ? false : true;
      pickingInfo.pickedMesh = skipBoundingInfo ? null : this;
      pickingInfo.distance = skipBoundingInfo ? 0 : Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);
      pickingInfo.subMeshId = 0;
      return pickingInfo;
    }
    if (!this._generatePointsArray()) {
      return pickingInfo;
    }
    let intersectInfo = null;
    const subMeshes = this._scene.getIntersectingSubMeshCandidates(this, ray);
    const len = subMeshes.length;
    let anySubmeshSupportIntersect = false;
    for (let index = 0; index < len; index++) {
      const subMesh = subMeshes.data[index];
      const material = subMesh.getMaterial();
      if (!material) {
        continue;
      }
      if (material.fillMode == 7 || material.fillMode == 0 || material.fillMode == 1 || material.fillMode == 2 || material.fillMode == 4) {
        anySubmeshSupportIntersect = true;
        break;
      }
    }
    if (!anySubmeshSupportIntersect) {
      pickingInfo.hit = true;
      pickingInfo.pickedMesh = this;
      pickingInfo.distance = Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);
      pickingInfo.subMeshId = -1;
      return pickingInfo;
    }
    for (let index = 0; index < len; index++) {
      const subMesh = subMeshes.data[index];
      if (len > 1 && !skipBoundingInfo && !subMesh.canIntersects(ray)) {
        continue;
      }
      const currentIntersectInfo = subMesh.intersects(ray, this._positions, this.getIndices(), fastCheck, trianglePredicate);
      if (currentIntersectInfo) {
        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
          intersectInfo = currentIntersectInfo;
          intersectInfo.subMeshId = index;
          if (fastCheck) {
            break;
          }
        }
      }
    }
    if (intersectInfo) {
      const world = worldToUse ?? this.getWorldMatrix();
      const worldOrigin = TmpVectors.Vector3[0];
      const direction = TmpVectors.Vector3[1];
      Vector3.TransformCoordinatesToRef(ray.origin, world, worldOrigin);
      ray.direction.scaleToRef(intersectInfo.distance, direction);
      const worldDirection = Vector3.TransformNormal(direction, world);
      const pickedPoint = worldDirection.addInPlace(worldOrigin);
      pickingInfo.hit = true;
      pickingInfo.distance = Vector3.Distance(worldOrigin, pickedPoint);
      pickingInfo.pickedPoint = pickedPoint;
      pickingInfo.pickedMesh = this;
      pickingInfo.bu = intersectInfo.bu || 0;
      pickingInfo.bv = intersectInfo.bv || 0;
      pickingInfo.subMeshFaceId = intersectInfo.faceId;
      pickingInfo.faceId = intersectInfo.faceId + subMeshes.data[intersectInfo.subMeshId].indexStart / (this.getClassName().indexOf("LinesMesh") !== -1 ? 2 : 3);
      pickingInfo.subMeshId = intersectInfo.subMeshId;
      return pickingInfo;
    }
    return pickingInfo;
  }
  /**
   * Clones the current mesh
   * @param name defines the mesh name
   * @param newParent defines the new mesh parent
   * @param doNotCloneChildren defines a boolean indicating that children must not be cloned (false by default)
   * @returns the new mesh
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  clone(name, newParent, doNotCloneChildren) {
    return null;
  }
  /**
   * Disposes all the submeshes of the current mesh
   * @param immediate should dispose the effects immediately or not
   * @returns the current mesh
   */
  releaseSubMeshes(immediate = false) {
    if (this.subMeshes) {
      while (this.subMeshes.length) {
        this.subMeshes[0].dispose(immediate);
      }
    } else {
      this.subMeshes = [];
    }
    return this;
  }
  /**
   * Releases resources associated with this abstract mesh.
   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
   */
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    let index;
    const scene = this.getScene();
    if (this._scene.useMaterialMeshMap) {
      if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {
        this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0;
      }
    }
    scene.freeActiveMeshes();
    scene.freeRenderingGroups();
    if (scene.renderingManager.maintainStateBetweenFrames) {
      scene.renderingManager.restoreDispachedFlags();
    }
    if (this.actionManager !== void 0 && this.actionManager !== null) {
      if (this.actionManager.disposeWhenUnowned && !this._scene.meshes.some((m) => m !== this && m.actionManager === this.actionManager)) {
        this.actionManager.dispose();
      }
      this.actionManager = null;
    }
    this._internalAbstractMeshDataInfo._skeleton = null;
    if (this._transformMatrixTexture) {
      this._transformMatrixTexture.dispose();
      this._transformMatrixTexture = null;
    }
    for (index = 0; index < this._intersectionsInProgress.length; index++) {
      const other = this._intersectionsInProgress[index];
      const pos = other._intersectionsInProgress.indexOf(this);
      other._intersectionsInProgress.splice(pos, 1);
    }
    this._intersectionsInProgress.length = 0;
    const lights = scene.lights;
    lights.forEach((light) => {
      let meshIndex = light.includedOnlyMeshes.indexOf(this);
      if (meshIndex !== -1) {
        light.includedOnlyMeshes.splice(meshIndex, 1);
      }
      meshIndex = light.excludedMeshes.indexOf(this);
      if (meshIndex !== -1) {
        light.excludedMeshes.splice(meshIndex, 1);
      }
      const generators = light.getShadowGenerators();
      if (generators) {
        const iterator = generators.values();
        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
          const generator = key.value;
          const shadowMap = generator.getShadowMap();
          if (shadowMap && shadowMap.renderList) {
            meshIndex = shadowMap.renderList.indexOf(this);
            if (meshIndex !== -1) {
              shadowMap.renderList.splice(meshIndex, 1);
            }
          }
        }
      }
    });
    if (this.getClassName() !== "InstancedMesh" || this.getClassName() !== "InstancedLinesMesh") {
      this.releaseSubMeshes(true);
    }
    const engine = scene.getEngine();
    if (this._occlusionQuery !== null) {
      this.isOcclusionQueryInProgress = false;
      engine.deleteQuery(this._occlusionQuery);
      this._occlusionQuery = null;
    }
    engine.wipeCaches();
    scene.removeMesh(this);
    if (this._parentContainer) {
      const index2 = this._parentContainer.meshes.indexOf(this);
      if (index2 > -1) {
        this._parentContainer.meshes.splice(index2, 1);
      }
      this._parentContainer = null;
    }
    if (disposeMaterialAndTextures) {
      if (this.material) {
        if (this.material.getClassName() === "MultiMaterial") {
          this.material.dispose(false, true, true);
        } else {
          this.material.dispose(false, true);
        }
      }
    }
    if (!doNotRecurse) {
      for (index = 0; index < scene.particleSystems.length; index++) {
        if (scene.particleSystems[index].emitter === this) {
          scene.particleSystems[index].dispose();
          index--;
        }
      }
    }
    if (this._internalAbstractMeshDataInfo._facetData.facetDataEnabled) {
      this.disableFacetData();
    }
    this._uniformBuffer.dispose();
    this.onAfterWorldMatrixUpdateObservable.clear();
    this.onCollideObservable.clear();
    this.onCollisionPositionChangeObservable.clear();
    this.onRebuildObservable.clear();
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
  // Facet data
  /** @internal */
  _initFacetData() {
    const data = this._internalAbstractMeshDataInfo._facetData;
    if (!data.facetNormals) {
      data.facetNormals = [];
    }
    if (!data.facetPositions) {
      data.facetPositions = [];
    }
    if (!data.facetPartitioning) {
      data.facetPartitioning = new Array();
    }
    data.facetNb = this.getIndices().length / 3 | 0;
    data.partitioningSubdivisions = data.partitioningSubdivisions ? data.partitioningSubdivisions : 10;
    data.partitioningBBoxRatio = data.partitioningBBoxRatio ? data.partitioningBBoxRatio : 1.01;
    for (let f = 0; f < data.facetNb; f++) {
      data.facetNormals[f] = Vector3.Zero();
      data.facetPositions[f] = Vector3.Zero();
    }
    data.facetDataEnabled = true;
    return this;
  }
  /**
   * Updates the mesh facetData arrays and the internal partitioning when the mesh is morphed or updated.
   * This method can be called within the render loop.
   * You don't need to call this method by yourself in the render loop when you update/morph a mesh with the methods CreateXXX() as they automatically manage this computation
   * @returns the current mesh
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  updateFacetData() {
    const data = this._internalAbstractMeshDataInfo._facetData;
    if (!data.facetDataEnabled) {
      this._initFacetData();
    }
    const positions = this.getVerticesData(VertexBuffer.PositionKind);
    const indices = this.getIndices();
    const normals = this.getVerticesData(VertexBuffer.NormalKind);
    const bInfo = this.getBoundingInfo();
    if (data.facetDepthSort && !data.facetDepthSortEnabled) {
      data.facetDepthSortEnabled = true;
      if (indices instanceof Uint16Array) {
        data.depthSortedIndices = new Uint16Array(indices);
      } else if (indices instanceof Uint32Array) {
        data.depthSortedIndices = new Uint32Array(indices);
      } else {
        let needs32bits = false;
        for (let i = 0; i < indices.length; i++) {
          if (indices[i] > 65535) {
            needs32bits = true;
            break;
          }
        }
        if (needs32bits) {
          data.depthSortedIndices = new Uint32Array(indices);
        } else {
          data.depthSortedIndices = new Uint16Array(indices);
        }
      }
      data.facetDepthSortFunction = function(f1, f2) {
        return f2.sqDistance - f1.sqDistance;
      };
      if (!data.facetDepthSortFrom) {
        const camera = this.getScene().activeCamera;
        data.facetDepthSortFrom = camera ? camera.position : Vector3.Zero();
      }
      data.depthSortedFacets = [];
      for (let f = 0; f < data.facetNb; f++) {
        const depthSortedFacet = { ind: f * 3, sqDistance: 0 };
        data.depthSortedFacets.push(depthSortedFacet);
      }
      data.invertedMatrix = Matrix.Identity();
      data.facetDepthSortOrigin = Vector3.Zero();
    }
    data.bbSize.x = bInfo.maximum.x - bInfo.minimum.x > Epsilon ? bInfo.maximum.x - bInfo.minimum.x : Epsilon;
    data.bbSize.y = bInfo.maximum.y - bInfo.minimum.y > Epsilon ? bInfo.maximum.y - bInfo.minimum.y : Epsilon;
    data.bbSize.z = bInfo.maximum.z - bInfo.minimum.z > Epsilon ? bInfo.maximum.z - bInfo.minimum.z : Epsilon;
    let bbSizeMax = data.bbSize.x > data.bbSize.y ? data.bbSize.x : data.bbSize.y;
    bbSizeMax = bbSizeMax > data.bbSize.z ? bbSizeMax : data.bbSize.z;
    data.subDiv.max = data.partitioningSubdivisions;
    data.subDiv.X = Math.floor(data.subDiv.max * data.bbSize.x / bbSizeMax);
    data.subDiv.Y = Math.floor(data.subDiv.max * data.bbSize.y / bbSizeMax);
    data.subDiv.Z = Math.floor(data.subDiv.max * data.bbSize.z / bbSizeMax);
    data.subDiv.X = data.subDiv.X < 1 ? 1 : data.subDiv.X;
    data.subDiv.Y = data.subDiv.Y < 1 ? 1 : data.subDiv.Y;
    data.subDiv.Z = data.subDiv.Z < 1 ? 1 : data.subDiv.Z;
    data.facetParameters.facetNormals = this.getFacetLocalNormals();
    data.facetParameters.facetPositions = this.getFacetLocalPositions();
    data.facetParameters.facetPartitioning = this.getFacetLocalPartitioning();
    data.facetParameters.bInfo = bInfo;
    data.facetParameters.bbSize = data.bbSize;
    data.facetParameters.subDiv = data.subDiv;
    data.facetParameters.ratio = this.partitioningBBoxRatio;
    data.facetParameters.depthSort = data.facetDepthSort;
    if (data.facetDepthSort && data.facetDepthSortEnabled) {
      this.computeWorldMatrix(true);
      this._worldMatrix.invertToRef(data.invertedMatrix);
      Vector3.TransformCoordinatesToRef(data.facetDepthSortFrom, data.invertedMatrix, data.facetDepthSortOrigin);
      data.facetParameters.distanceTo = data.facetDepthSortOrigin;
    }
    data.facetParameters.depthSortedFacets = data.depthSortedFacets;
    if (normals) {
      VertexData.ComputeNormals(positions, indices, normals, data.facetParameters);
    }
    if (data.facetDepthSort && data.facetDepthSortEnabled) {
      data.depthSortedFacets.sort(data.facetDepthSortFunction);
      const l = data.depthSortedIndices.length / 3 | 0;
      for (let f = 0; f < l; f++) {
        const sind = data.depthSortedFacets[f].ind;
        data.depthSortedIndices[f * 3] = indices[sind];
        data.depthSortedIndices[f * 3 + 1] = indices[sind + 1];
        data.depthSortedIndices[f * 3 + 2] = indices[sind + 2];
      }
      this.updateIndices(data.depthSortedIndices, void 0, true);
    }
    return this;
  }
  /**
   * Returns the facetLocalNormals array.
   * The normals are expressed in the mesh local spac
   * @returns an array of Vector3
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  getFacetLocalNormals() {
    const facetData = this._internalAbstractMeshDataInfo._facetData;
    if (!facetData.facetNormals) {
      this.updateFacetData();
    }
    return facetData.facetNormals;
  }
  /**
   * Returns the facetLocalPositions array.
   * The facet positions are expressed in the mesh local space
   * @returns an array of Vector3
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  getFacetLocalPositions() {
    const facetData = this._internalAbstractMeshDataInfo._facetData;
    if (!facetData.facetPositions) {
      this.updateFacetData();
    }
    return facetData.facetPositions;
  }
  /**
   * Returns the facetLocalPartitioning array
   * @returns an array of array of numbers
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  getFacetLocalPartitioning() {
    const facetData = this._internalAbstractMeshDataInfo._facetData;
    if (!facetData.facetPartitioning) {
      this.updateFacetData();
    }
    return facetData.facetPartitioning;
  }
  /**
   * Returns the i-th facet position in the world system.
   * This method allocates a new Vector3 per call
   * @param i defines the facet index
   * @returns a new Vector3
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  getFacetPosition(i) {
    const pos = Vector3.Zero();
    this.getFacetPositionToRef(i, pos);
    return pos;
  }
  /**
   * Sets the reference Vector3 with the i-th facet position in the world system
   * @param i defines the facet index
   * @param ref defines the target vector
   * @returns the current mesh
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  getFacetPositionToRef(i, ref) {
    const localPos = this.getFacetLocalPositions()[i];
    const world = this.getWorldMatrix();
    Vector3.TransformCoordinatesToRef(localPos, world, ref);
    return this;
  }
  /**
   * Returns the i-th facet normal in the world system.
   * This method allocates a new Vector3 per call
   * @param i defines the facet index
   * @returns a new Vector3
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  getFacetNormal(i) {
    const norm = Vector3.Zero();
    this.getFacetNormalToRef(i, norm);
    return norm;
  }
  /**
   * Sets the reference Vector3 with the i-th facet normal in the world system
   * @param i defines the facet index
   * @param ref defines the target vector
   * @returns the current mesh
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  getFacetNormalToRef(i, ref) {
    const localNorm = this.getFacetLocalNormals()[i];
    Vector3.TransformNormalToRef(localNorm, this.getWorldMatrix(), ref);
    return this;
  }
  /**
   * Returns the facets (in an array) in the same partitioning block than the one the passed coordinates are located (expressed in the mesh local system)
   * @param x defines x coordinate
   * @param y defines y coordinate
   * @param z defines z coordinate
   * @returns the array of facet indexes
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  getFacetsAtLocalCoordinates(x, y, z) {
    const bInfo = this.getBoundingInfo();
    const data = this._internalAbstractMeshDataInfo._facetData;
    const ox = Math.floor((x - bInfo.minimum.x * data.partitioningBBoxRatio) * data.subDiv.X * data.partitioningBBoxRatio / data.bbSize.x);
    const oy = Math.floor((y - bInfo.minimum.y * data.partitioningBBoxRatio) * data.subDiv.Y * data.partitioningBBoxRatio / data.bbSize.y);
    const oz = Math.floor((z - bInfo.minimum.z * data.partitioningBBoxRatio) * data.subDiv.Z * data.partitioningBBoxRatio / data.bbSize.z);
    if (ox < 0 || ox > data.subDiv.max || oy < 0 || oy > data.subDiv.max || oz < 0 || oz > data.subDiv.max) {
      return null;
    }
    return data.facetPartitioning[ox + data.subDiv.max * oy + data.subDiv.max * data.subDiv.max * oz];
  }
  /**
   * Returns the closest mesh facet index at (x,y,z) World coordinates, null if not found
   * @param x defines x coordinate
   * @param y defines y coordinate
   * @param z defines z coordinate
   * @param projected sets as the (x,y,z) world projection on the facet
   * @param checkFace if true (default false), only the facet "facing" to (x,y,z) or only the ones "turning their backs", according to the parameter "facing" are returned
   * @param facing if facing and checkFace are true, only the facet "facing" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet "turning their backs" to (x, y, z) are returned : negative dot (x, y, z) * facet position
   * @returns the face index if found (or null instead)
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  getClosestFacetAtCoordinates(x, y, z, projected, checkFace = false, facing = true) {
    const world = this.getWorldMatrix();
    const invMat = TmpVectors.Matrix[5];
    world.invertToRef(invMat);
    const invVect = TmpVectors.Vector3[8];
    Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, invMat, invVect);
    const closest = this.getClosestFacetAtLocalCoordinates(invVect.x, invVect.y, invVect.z, projected, checkFace, facing);
    if (projected) {
      Vector3.TransformCoordinatesFromFloatsToRef(projected.x, projected.y, projected.z, world, projected);
    }
    return closest;
  }
  /**
   * Returns the closest mesh facet index at (x,y,z) local coordinates, null if not found
   * @param x defines x coordinate
   * @param y defines y coordinate
   * @param z defines z coordinate
   * @param projected sets as the (x,y,z) local projection on the facet
   * @param checkFace if true (default false), only the facet "facing" to (x,y,z) or only the ones "turning their backs", according to the parameter "facing" are returned
   * @param facing if facing and checkFace are true, only the facet "facing" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet "turning their backs" to (x, y, z) are returned : negative dot (x, y, z) * facet position
   * @returns the face index if found (or null instead)
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  getClosestFacetAtLocalCoordinates(x, y, z, projected, checkFace = false, facing = true) {
    let closest = null;
    let tmpx = 0;
    let tmpy = 0;
    let tmpz = 0;
    let d = 0;
    let t0 = 0;
    let projx = 0;
    let projy = 0;
    let projz = 0;
    const facetPositions = this.getFacetLocalPositions();
    const facetNormals = this.getFacetLocalNormals();
    const facetsInBlock = this.getFacetsAtLocalCoordinates(x, y, z);
    if (!facetsInBlock) {
      return null;
    }
    let shortest = Number.MAX_VALUE;
    let tmpDistance = shortest;
    let fib;
    let norm;
    let p0;
    for (let idx = 0; idx < facetsInBlock.length; idx++) {
      fib = facetsInBlock[idx];
      norm = facetNormals[fib];
      p0 = facetPositions[fib];
      d = (x - p0.x) * norm.x + (y - p0.y) * norm.y + (z - p0.z) * norm.z;
      if (!checkFace || checkFace && facing && d >= 0 || checkFace && !facing && d <= 0) {
        d = norm.x * p0.x + norm.y * p0.y + norm.z * p0.z;
        t0 = -(norm.x * x + norm.y * y + norm.z * z - d) / (norm.x * norm.x + norm.y * norm.y + norm.z * norm.z);
        projx = x + norm.x * t0;
        projy = y + norm.y * t0;
        projz = z + norm.z * t0;
        tmpx = projx - x;
        tmpy = projy - y;
        tmpz = projz - z;
        tmpDistance = tmpx * tmpx + tmpy * tmpy + tmpz * tmpz;
        if (tmpDistance < shortest) {
          shortest = tmpDistance;
          closest = fib;
          if (projected) {
            projected.x = projx;
            projected.y = projy;
            projected.z = projz;
          }
        }
      }
    }
    return closest;
  }
  /**
   * Returns the object "parameter" set with all the expected parameters for facetData computation by ComputeNormals()
   * @returns the parameters
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  getFacetDataParameters() {
    return this._internalAbstractMeshDataInfo._facetData.facetParameters;
  }
  /**
   * Disables the feature FacetData and frees the related memory
   * @returns the current mesh
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/facetData
   */
  disableFacetData() {
    const facetData = this._internalAbstractMeshDataInfo._facetData;
    if (facetData.facetDataEnabled) {
      facetData.facetDataEnabled = false;
      facetData.facetPositions = [];
      facetData.facetNormals = [];
      facetData.facetPartitioning = new Array();
      facetData.facetParameters = {};
      facetData.depthSortedIndices = new Uint32Array(0);
    }
    return this;
  }
  /**
   * Updates the AbstractMesh indices array
   * @param indices defines the data source
   * @param offset defines the offset in the index buffer where to store the new data (can be null)
   * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)
   * @returns the current mesh
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  updateIndices(indices, offset, gpuMemoryOnly = false) {
    return this;
  }
  /**
   * Creates new normals data for the mesh
   * @param updatable defines if the normal vertex buffer must be flagged as updatable
   * @returns the current mesh
   */
  createNormals(updatable) {
    const positions = this.getVerticesData(VertexBuffer.PositionKind);
    const indices = this.getIndices();
    let normals;
    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      normals = this.getVerticesData(VertexBuffer.NormalKind);
    } else {
      normals = [];
    }
    VertexData.ComputeNormals(positions, indices, normals, { useRightHandedSystem: this.getScene().useRightHandedSystem });
    this.setVerticesData(VertexBuffer.NormalKind, normals, updatable);
    return this;
  }
  /**
   * Optimize the indices order so that we keep the faces with similar indices together
   * @returns the current mesh
   */
  async optimizeIndicesAsync() {
    const indices = this.getIndices();
    if (!indices) {
      return this;
    }
    const { OptimizeIndices } = await import("./mesh.vertexData.functions-GRC4GMC4.js");
    OptimizeIndices(indices);
    this.setIndices(indices, this.getTotalVertices());
    return this;
  }
  /**
   * Align the mesh with a normal
   * @param normal defines the normal to use
   * @param upDirection can be used to redefined the up vector to use (will use the (0, 1, 0) by default)
   * @returns the current mesh
   */
  alignWithNormal(normal, upDirection) {
    if (!upDirection) {
      upDirection = Axis.Y;
    }
    const axisX = TmpVectors.Vector3[0];
    const axisZ = TmpVectors.Vector3[1];
    Vector3.CrossToRef(upDirection, normal, axisZ);
    Vector3.CrossToRef(normal, axisZ, axisX);
    if (this.rotationQuaternion) {
      Quaternion.RotationQuaternionFromAxisToRef(axisX, normal, axisZ, this.rotationQuaternion);
    } else {
      Vector3.RotationFromAxisToRef(axisX, normal, axisZ, this.rotation);
    }
    return this;
  }
  /** @internal */
  _checkOcclusionQuery() {
    return false;
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Disables the mesh edge rendering mode
   * @returns the currentAbstractMesh
   */
  disableEdgesRendering() {
    throw _WarnImport("EdgesRenderer");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Enables the edge rendering mode on the mesh.
   * This mode makes the mesh edges visible
   * @param epsilon defines the maximal distance between two angles to detect a face
   * @param checkVerticesInsteadOfIndices indicates that we should check vertex list directly instead of faces
   * @param options options to the edge renderer
   * @returns the currentAbstractMesh
   * @see https://www.babylonjs-playground.com/#19O9TU#0
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  enableEdgesRendering(epsilon, checkVerticesInsteadOfIndices, options) {
    throw _WarnImport("EdgesRenderer");
  }
  /**
   * This function returns all of the particle systems in the scene that use the mesh as an emitter.
   * @returns an array of particle systems in the scene that use the mesh as an emitter
   */
  getConnectedParticleSystems() {
    return this._scene.particleSystems.filter((particleSystem) => particleSystem.emitter === this);
  }
};
AbstractMesh.OCCLUSION_TYPE_NONE = 0;
AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC = 1;
AbstractMesh.OCCLUSION_TYPE_STRICT = 2;
AbstractMesh.OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0;
AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1;
AbstractMesh.CULLINGSTRATEGY_STANDARD = 0;
AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1;
AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2;
AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3;
__decorate([
  nativeOverride.filter((...[data, matricesIndicesData, matricesWeightsData, matricesIndicesExtraData, matricesWeightsExtraData]) => !Array.isArray(data) && !Array.isArray(matricesIndicesData) && !Array.isArray(matricesWeightsData) && !Array.isArray(matricesIndicesExtraData) && !Array.isArray(matricesWeightsExtraData))
], AbstractMesh, "_ApplySkeleton", null);
RegisterClass("BABYLON.AbstractMesh", AbstractMesh);

export {
  inlineScheduler,
  createYieldingScheduler,
  runCoroutine,
  runCoroutineSync,
  runCoroutineAsync,
  makeSyncFunction,
  makeAsyncFunction,
  VertexDataMaterialInfo,
  VertexData,
  TransformNode,
  _MeshCollisionData,
  AbstractMesh
};
//# sourceMappingURL=chunk-EB6Z7H3C.js.map
