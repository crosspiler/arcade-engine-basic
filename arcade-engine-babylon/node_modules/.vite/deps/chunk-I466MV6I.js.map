{
  "version": 3,
  "sources": ["../../../dev/core/src/Meshes/Builders/ribbonBuilder.ts", "../../../dev/core/src/Meshes/Builders/discBuilder.ts", "../../../dev/core/src/Meshes/Builders/tiledPlaneBuilder.ts", "../../../dev/core/src/Meshes/Builders/tiledBoxBuilder.ts", "../../../dev/core/src/Meshes/Builders/sphereBuilder.ts", "../../../dev/core/src/Meshes/Builders/cylinderBuilder.ts", "../../../dev/core/src/Meshes/Builders/torusBuilder.ts", "../../../dev/core/src/Meshes/Builders/torusKnotBuilder.ts", "../../../dev/core/src/Meshes/instancedMesh.ts", "../../../dev/core/src/Meshes/linesMesh.ts", "../../../dev/core/src/Meshes/Builders/linesBuilder.ts", "../../../dev/core/src/Meshes/polygonMesh.ts", "../../../dev/core/src/Meshes/Builders/polygonBuilder.ts", "../../../dev/core/src/Meshes/Builders/shapeBuilder.ts", "../../../dev/core/src/Meshes/Builders/latheBuilder.ts", "../../../dev/core/src/Meshes/Builders/tubeBuilder.ts", "../../../dev/core/src/Meshes/Builders/polyhedronBuilder.ts", "../../../dev/core/src/Meshes/Builders/icoSphereBuilder.ts", "../../../dev/core/src/Meshes/Builders/decalBuilder.ts", "../../../dev/core/src/Meshes/Builders/capsuleBuilder.ts", "../../../dev/core/src/Maths/math.isovector.ts", "../../../dev/core/src/Meshes/geodesicMesh.ts", "../../../dev/core/src/Meshes/Builders/geodesicBuilder.ts", "../../../dev/core/src/Meshes/goldbergMesh.ts", "../../../dev/core/src/Meshes/Builders/goldbergBuilder.ts", "../../../dev/core/src/Meshes/Builders/textBuilder.ts", "../../../dev/core/src/Meshes/meshBuilder.ts"],
  "sourcesContent": ["import type { Nullable, FloatArray } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector3, Vector2, Vector4 } from \"../../Maths/math.vector\";\r\nimport { TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { useOpenGLOrientationForUV } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a Ribbon\r\n * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\r\n * * pathArray array of paths, each of which an array of successive Vector3\r\n * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\r\n * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\r\n * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\r\n * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\r\n * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\r\n * @returns the VertexData of the ribbon\r\n */\r\nexport function CreateRibbonVertexData(options: {\r\n    pathArray: Vector3[][];\r\n    closeArray?: boolean;\r\n    closePath?: boolean;\r\n    offset?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    invertUV?: boolean;\r\n    uvs?: Vector2[];\r\n    colors?: Color4[];\r\n}): VertexData {\r\n    let pathArray: Vector3[][] = options.pathArray;\r\n    const closeArray: boolean = options.closeArray || false;\r\n    const closePath: boolean = options.closePath || false;\r\n    const invertUV: boolean = options.invertUV || false;\r\n    const defaultOffset: number = Math.floor(pathArray[0].length / 2);\r\n    let offset: number = options.offset || defaultOffset;\r\n    offset = offset > defaultOffset ? defaultOffset : Math.floor(offset); // offset max allowed : defaultOffset\r\n    const sideOrientation: number = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const customUV = options.uvs;\r\n    const customColors = options.colors;\r\n\r\n    const positions: number[] = [];\r\n    const indices: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n\r\n    const us: number[][] = []; // us[path_id] = [uDist1, uDist2, uDist3 ... ] distances between points on path path_id\r\n    const vs: number[][] = []; // vs[i] = [vDist1, vDist2, vDist3, ... ] distances between points i of consecutive paths from pathArray\r\n    const uTotalDistance: number[] = []; // uTotalDistance[p] : total distance of path p\r\n    const vTotalDistance: number[] = []; //  vTotalDistance[i] : total distance between points i of first and last path from pathArray\r\n    let minlg: number; // minimal length among all paths from pathArray\r\n    const lg: number[] = []; // array of path lengths : nb of vertex per path\r\n    const idx: number[] = []; // array of path indexes : index of each path (first vertex) in the total vertex number\r\n    let p: number; // path iterator\r\n    let i: number; // point iterator\r\n    let j: number; // point iterator\r\n\r\n    // if single path in pathArray\r\n    if (pathArray.length < 2) {\r\n        const ar1: Vector3[] = [];\r\n        const ar2: Vector3[] = [];\r\n        for (i = 0; i < pathArray[0].length - offset; i++) {\r\n            ar1.push(pathArray[0][i]);\r\n            ar2.push(pathArray[0][i + offset]);\r\n        }\r\n        pathArray = [ar1, ar2];\r\n    }\r\n\r\n    // positions and horizontal distances (u)\r\n    let idc: number = 0;\r\n    const closePathCorr: number = closePath ? 1 : 0; // the final index will be +1 if closePath\r\n    const closeArrayCorr: number = closeArray ? 1 : 0;\r\n    let path: Vector3[];\r\n    let l: number;\r\n    minlg = pathArray[0].length;\r\n    let vectlg: number;\r\n    let dist: number;\r\n    for (p = 0; p < pathArray.length + closeArrayCorr; p++) {\r\n        uTotalDistance[p] = 0;\r\n        us[p] = [0];\r\n        path = p === pathArray.length ? pathArray[0] : pathArray[p];\r\n        l = path.length;\r\n        minlg = minlg < l ? minlg : l;\r\n\r\n        j = 0;\r\n        while (j < l) {\r\n            positions.push(path[j].x, path[j].y, path[j].z);\r\n            if (j > 0) {\r\n                vectlg = path[j].subtract(path[j - 1]).length();\r\n                dist = vectlg + uTotalDistance[p];\r\n                us[p].push(dist);\r\n                uTotalDistance[p] = dist;\r\n            }\r\n            j++;\r\n        }\r\n\r\n        if (closePath) {\r\n            // an extra hidden vertex is added in the \"positions\" array\r\n            j--;\r\n            positions.push(path[0].x, path[0].y, path[0].z);\r\n            vectlg = path[j].subtract(path[0]).length();\r\n            dist = vectlg + uTotalDistance[p];\r\n            us[p].push(dist);\r\n            uTotalDistance[p] = dist;\r\n        }\r\n\r\n        lg[p] = l + closePathCorr;\r\n        idx[p] = idc;\r\n        idc += l + closePathCorr;\r\n    }\r\n\r\n    // vertical distances (v)\r\n    let path1: Vector3[];\r\n    let path2: Vector3[];\r\n    let vertex1: Nullable<Vector3> = null;\r\n    let vertex2: Nullable<Vector3> = null;\r\n    for (i = 0; i < minlg + closePathCorr; i++) {\r\n        vTotalDistance[i] = 0;\r\n        vs[i] = [0];\r\n        for (p = 0; p < pathArray.length - 1 + closeArrayCorr; p++) {\r\n            path1 = pathArray[p];\r\n            path2 = p === pathArray.length - 1 ? pathArray[0] : pathArray[p + 1];\r\n            if (i === minlg) {\r\n                // closePath\r\n                vertex1 = path1[0];\r\n                vertex2 = path2[0];\r\n            } else {\r\n                vertex1 = path1[i];\r\n                vertex2 = path2[i];\r\n            }\r\n            vectlg = vertex2.subtract(vertex1).length();\r\n            dist = vectlg + vTotalDistance[i];\r\n            vs[i].push(dist);\r\n            vTotalDistance[i] = dist;\r\n        }\r\n    }\r\n\r\n    // uvs\r\n    let u: number;\r\n    let v: number;\r\n    if (customUV) {\r\n        for (p = 0; p < customUV.length; p++) {\r\n            uvs.push(customUV[p].x, useOpenGLOrientationForUV ? 1.0 - customUV[p].y : customUV[p].y);\r\n        }\r\n    } else {\r\n        for (p = 0; p < pathArray.length + closeArrayCorr; p++) {\r\n            for (i = 0; i < minlg + closePathCorr; i++) {\r\n                u = uTotalDistance[p] != 0.0 ? us[p][i] / uTotalDistance[p] : 0.0;\r\n                v = vTotalDistance[i] != 0.0 ? vs[i][p] / vTotalDistance[i] : 0.0;\r\n                if (invertUV) {\r\n                    uvs.push(v, u);\r\n                } else {\r\n                    uvs.push(u, useOpenGLOrientationForUV ? 1.0 - v : v);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // indices\r\n    p = 0; // path index\r\n    let pi: number = 0; // positions array index\r\n    let l1: number = lg[p] - 1; // path1 length\r\n    let l2: number = lg[p + 1] - 1; // path2 length\r\n    let min: number = l1 < l2 ? l1 : l2; // current path stop index\r\n    let shft: number = idx[1] - idx[0]; // shift\r\n    const path1nb: number = lg.length - 1; // number of path1 to iterate on\r\n\r\n    while (pi <= min && p < path1nb) {\r\n        //  stay under min and don't go over next to last path\r\n        // draw two triangles between path1 (p1) and path2 (p2) : (p1.pi, p2.pi, p1.pi+1) and (p2.pi+1, p1.pi+1, p2.pi) clockwise\r\n\r\n        indices.push(pi, pi + shft, pi + 1);\r\n        indices.push(pi + shft + 1, pi + 1, pi + shft);\r\n        pi += 1;\r\n        if (pi === min) {\r\n            // if end of one of two consecutive paths reached, go to next existing path\r\n            p++;\r\n            shft = idx[p + 1] - idx[p];\r\n            l1 = lg[p] - 1;\r\n            l2 = lg[p + 1] - 1;\r\n            pi = idx[p];\r\n            min = l1 < l2 ? l1 + pi : l2 + pi;\r\n        }\r\n    }\r\n\r\n    // normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    if (closePath) {\r\n        // update both the first and last vertex normals to their average value\r\n        let indexFirst: number = 0;\r\n        let indexLast: number = 0;\r\n        for (p = 0; p < pathArray.length; p++) {\r\n            indexFirst = idx[p] * 3;\r\n            if (p + 1 < pathArray.length) {\r\n                indexLast = (idx[p + 1] - 1) * 3;\r\n            } else {\r\n                indexLast = normals.length - 3;\r\n            }\r\n            normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\r\n            normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\r\n            normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\r\n            const l = Math.sqrt(normals[indexFirst] * normals[indexFirst] + normals[indexFirst + 1] * normals[indexFirst + 1] + normals[indexFirst + 2] * normals[indexFirst + 2]);\r\n            normals[indexFirst] /= l;\r\n            normals[indexFirst + 1] /= l;\r\n            normals[indexFirst + 2] /= l;\r\n            normals[indexLast] = normals[indexFirst];\r\n            normals[indexLast + 1] = normals[indexFirst + 1];\r\n            normals[indexLast + 2] = normals[indexFirst + 2];\r\n        }\r\n    }\r\n\r\n    if (closeArray) {\r\n        let indexFirst = idx[0] * 3;\r\n        let indexLast = idx[pathArray.length] * 3;\r\n        for (i = 0; i < minlg + closePathCorr; i++) {\r\n            normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\r\n            normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\r\n            normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\r\n            const l = Math.sqrt(normals[indexFirst] * normals[indexFirst] + normals[indexFirst + 1] * normals[indexFirst + 1] + normals[indexFirst + 2] * normals[indexFirst + 2]);\r\n            normals[indexFirst] /= l;\r\n            normals[indexFirst + 1] /= l;\r\n            normals[indexFirst + 2] /= l;\r\n            normals[indexLast] = normals[indexFirst];\r\n            normals[indexLast + 1] = normals[indexFirst + 1];\r\n            normals[indexLast + 2] = normals[indexFirst + 2];\r\n            indexFirst += 3;\r\n            indexLast += 3;\r\n        }\r\n    }\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Colors\r\n    let colors: Nullable<Float32Array> = null;\r\n    if (customColors) {\r\n        colors = new Float32Array(customColors.length * 4);\r\n        for (let c = 0; c < customColors.length; c++) {\r\n            colors[c * 4] = customColors[c].r;\r\n            colors[c * 4 + 1] = customColors[c].g;\r\n            colors[c * 4 + 2] = customColors[c].b;\r\n            colors[c * 4 + 3] = customColors[c].a;\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    const positions32 = new Float32Array(positions);\r\n    const normals32 = new Float32Array(normals);\r\n    const uvs32 = new Float32Array(uvs);\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions32;\r\n    vertexData.normals = normals32;\r\n    vertexData.uvs = uvs32;\r\n    if (colors) {\r\n        vertexData.set(colors, VertexBuffer.ColorKind);\r\n    }\r\n\r\n    if (closePath) {\r\n        (<any>vertexData)._idx = idx;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters\r\n * * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry\r\n * * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array\r\n * * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array\r\n * * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path\r\n * * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11\r\n * * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#ribbon\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n * * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones\r\n * * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values\r\n * * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry\r\n * * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the ribbon mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/ribbon_extra\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n */\r\nexport function CreateRibbon(\r\n    name: string,\r\n    options: {\r\n        pathArray: Vector3[][];\r\n        closeArray?: boolean;\r\n        closePath?: boolean;\r\n        offset?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        instance?: Mesh;\r\n        invertUV?: boolean;\r\n        uvs?: Vector2[];\r\n        colors?: Color4[];\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const pathArray = options.pathArray;\r\n    const closeArray = options.closeArray;\r\n    const closePath = options.closePath;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const instance = options.instance;\r\n    const updatable = options.updatable;\r\n\r\n    if (instance) {\r\n        // existing ribbon instance update\r\n        // positionFunction : ribbon case\r\n        // only pathArray and sideOrientation parameters are taken into account for positions update\r\n        const minimum = TmpVectors.Vector3[0].setAll(Number.MAX_VALUE);\r\n        const maximum = TmpVectors.Vector3[1].setAll(-Number.MAX_VALUE);\r\n        const positionFunction = (positions: FloatArray) => {\r\n            let minlg = pathArray[0].length;\r\n            const mesh = <Mesh>instance;\r\n            let i = 0;\r\n            const ns = mesh._originalBuilderSideOrientation === Mesh.DOUBLESIDE ? 2 : 1;\r\n            for (let si = 1; si <= ns; ++si) {\r\n                for (let p = 0; p < pathArray.length; ++p) {\r\n                    const path = pathArray[p];\r\n                    const l = path.length;\r\n                    minlg = minlg < l ? minlg : l;\r\n                    for (let j = 0; j < minlg; ++j) {\r\n                        const pathPoint = path[j];\r\n                        positions[i] = pathPoint.x;\r\n                        positions[i + 1] = pathPoint.y;\r\n                        positions[i + 2] = pathPoint.z;\r\n                        minimum.minimizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\r\n                        maximum.maximizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\r\n                        i += 3;\r\n                    }\r\n                    if (mesh._creationDataStorage && mesh._creationDataStorage.closePath) {\r\n                        const pathPoint = path[0];\r\n                        positions[i] = pathPoint.x;\r\n                        positions[i + 1] = pathPoint.y;\r\n                        positions[i + 2] = pathPoint.z;\r\n                        i += 3;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        const positions = <FloatArray>instance.getVerticesData(VertexBuffer.PositionKind);\r\n        positionFunction(positions);\r\n        if (instance.hasBoundingInfo) {\r\n            instance.getBoundingInfo().reConstruct(minimum, maximum, instance._worldMatrix);\r\n        } else {\r\n            instance.buildBoundingInfo(minimum, maximum, instance._worldMatrix);\r\n        }\r\n        instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n        if (options.colors) {\r\n            const colors = <FloatArray>instance.getVerticesData(VertexBuffer.ColorKind);\r\n            for (let c = 0, colorIndex = 0; c < options.colors.length; c++, colorIndex += 4) {\r\n                const color = options.colors[c];\r\n                colors[colorIndex] = color.r;\r\n                colors[colorIndex + 1] = color.g;\r\n                colors[colorIndex + 2] = color.b;\r\n                colors[colorIndex + 3] = color.a;\r\n            }\r\n            instance.updateVerticesData(VertexBuffer.ColorKind, colors, false, false);\r\n        }\r\n        if (options.uvs) {\r\n            const uvs = <FloatArray>instance.getVerticesData(VertexBuffer.UVKind);\r\n            for (let i = 0; i < options.uvs.length; i++) {\r\n                uvs[i * 2] = options.uvs[i].x;\r\n                uvs[i * 2 + 1] = useOpenGLOrientationForUV ? 1.0 - options.uvs[i].y : options.uvs[i].y;\r\n            }\r\n            instance.updateVerticesData(VertexBuffer.UVKind, uvs, false, false);\r\n        }\r\n        if (!instance.areNormalsFrozen || instance.isFacetDataEnabled) {\r\n            const indices = instance.getIndices();\r\n            const normals = <FloatArray>instance.getVerticesData(VertexBuffer.NormalKind);\r\n            const params = instance.isFacetDataEnabled ? instance.getFacetDataParameters() : null;\r\n            VertexData.ComputeNormals(positions, indices, normals, params);\r\n\r\n            if (instance._creationDataStorage && instance._creationDataStorage.closePath) {\r\n                let indexFirst: number = 0;\r\n                let indexLast: number = 0;\r\n                for (let p = 0; p < pathArray.length; p++) {\r\n                    indexFirst = instance._creationDataStorage!.idx[p] * 3;\r\n                    if (p + 1 < pathArray.length) {\r\n                        indexLast = (instance._creationDataStorage!.idx[p + 1] - 1) * 3;\r\n                    } else {\r\n                        indexLast = normals.length - 3;\r\n                    }\r\n                    normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\r\n                    normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\r\n                    normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\r\n                    normals[indexLast] = normals[indexFirst];\r\n                    normals[indexLast + 1] = normals[indexFirst + 1];\r\n                    normals[indexLast + 2] = normals[indexFirst + 2];\r\n                }\r\n            }\r\n            if (!instance.areNormalsFrozen) {\r\n                instance.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);\r\n            }\r\n        }\r\n\r\n        return instance;\r\n    } else {\r\n        // new ribbon creation\r\n\r\n        const ribbon = new Mesh(name, scene);\r\n        ribbon._originalBuilderSideOrientation = sideOrientation;\r\n        ribbon._creationDataStorage = new _CreationDataStorage();\r\n\r\n        const vertexData = CreateRibbonVertexData(options);\r\n        if (closePath) {\r\n            ribbon._creationDataStorage.idx = (<any>vertexData)._idx;\r\n        }\r\n        ribbon._creationDataStorage.closePath = closePath;\r\n        ribbon._creationDataStorage.closeArray = closeArray;\r\n\r\n        vertexData.applyToMesh(ribbon, updatable);\r\n\r\n        return ribbon;\r\n    }\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateRibbon directly\r\n */\r\nexport const RibbonBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateRibbon,\r\n};\r\n\r\nVertexData.CreateRibbon = CreateRibbonVertexData;\r\n\r\nMesh.CreateRibbon = (\r\n    name: string,\r\n    pathArray: Vector3[][],\r\n    closeArray: boolean = false,\r\n    closePath: boolean,\r\n    offset: number,\r\n    scene?: Scene,\r\n    updatable: boolean = false,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n) => {\r\n    return CreateRibbon(\r\n        name,\r\n        {\r\n            pathArray: pathArray,\r\n            closeArray: closeArray,\r\n            closePath: closePath,\r\n            offset: offset,\r\n            updatable: updatable,\r\n            sideOrientation: sideOrientation,\r\n            instance: instance,\r\n        },\r\n        scene\r\n    );\r\n};\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { useOpenGLOrientationForUV } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData of the Disc or regular Polygon\r\n * @param options an object used to set the following optional parameters for the disc, required but can be empty\r\n * * radius the radius of the disc, optional default 0.5\r\n * * tessellation the number of polygon sides, optional, default 64\r\n * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @returns the VertexData of the box\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function CreateDiscVertexData(options: {\r\n    radius?: number;\r\n    tessellation?: number;\r\n    arc?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const positions: number[] = [];\r\n    const indices: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n\r\n    const radius = options.radius || 0.5;\r\n    const tessellation = options.tessellation || 64;\r\n    const arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // positions and uvs\r\n    positions.push(0, 0, 0); // disc center first\r\n    uvs.push(0.5, 0.5);\r\n\r\n    const theta = Math.PI * 2 * arc;\r\n    const step = arc === 1 ? theta / tessellation : theta / (tessellation - 1);\r\n    let a = 0;\r\n    for (let t = 0; t < tessellation; t++) {\r\n        const x = Math.cos(a);\r\n        const y = Math.sin(a);\r\n        const u = (x + 1) / 2;\r\n        const v = (1 - y) / 2;\r\n        positions.push(radius * x, radius * y, 0);\r\n        uvs.push(u, useOpenGLOrientationForUV ? 1 - v : v);\r\n        a += step;\r\n    }\r\n    if (arc === 1) {\r\n        positions.push(positions[3], positions[4], positions[5]); // close the circle\r\n        uvs.push(uvs[2], useOpenGLOrientationForUV ? 1 - uvs[3] : uvs[3]);\r\n    }\r\n\r\n    //indices\r\n    const vertexNb = positions.length / 3;\r\n    for (let i = 1; i < vertexNb - 1; i++) {\r\n        indices.push(i + 1, 0, i);\r\n    }\r\n\r\n    // result\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a plane polygonal mesh.  By default, this is a disc\r\n * * The parameter `radius` sets the radius size (float) of the polygon (default 0.5)\r\n * * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc\r\n * * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the plane polygonal mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#disc-or-regular-polygon\r\n */\r\nexport function CreateDisc(\r\n    name: string,\r\n    options: { radius?: number; tessellation?: number; arc?: number; updatable?: boolean; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const disc = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    disc._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateDiscVertexData(options);\r\n\r\n    vertexData.applyToMesh(disc, options.updatable);\r\n\r\n    return disc;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated please use CreateDisc directly\r\n */\r\nexport const DiscBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateDisc,\r\n};\r\n\r\nVertexData.CreateDisc = CreateDiscVertexData;\r\n\r\nMesh.CreateDisc = (name: string, radius: number, tessellation: number, scene: Nullable<Scene> = null, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        radius,\r\n        tessellation,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateDisc(name, options, scene);\r\n};\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\n\r\n/**\r\n * Creates the VertexData for a tiled plane\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_plane\r\n * @param options an object used to set the following optional parameters for the tiled plane, required but can be empty\r\n * * pattern a limited pattern arrangement depending on the number\r\n * * size of the box\r\n * * width of the box, overwrites size\r\n * * height of the box, overwrites size\r\n * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\r\n * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\r\n * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\r\n * * alignVertical places whole tiles aligned to the center, left or right of a column\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.pattern\r\n * @param options.tileSize\r\n * @param options.tileWidth\r\n * @param options.tileHeight\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.alignHorizontal\r\n * @param options.alignVertical\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @returns the VertexData of the tiled plane\r\n */\r\nexport function CreateTiledPlaneVertexData(options: {\r\n    pattern?: number;\r\n    tileSize?: number;\r\n    tileWidth?: number;\r\n    tileHeight?: number;\r\n    size?: number;\r\n    width?: number;\r\n    height?: number;\r\n    alignHorizontal?: number;\r\n    alignVertical?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const flipTile = options.pattern || Mesh.NO_FLIP;\r\n    const tileWidth = options.tileWidth || options.tileSize || 1;\r\n    const tileHeight = options.tileHeight || options.tileSize || 1;\r\n    const alignH = options.alignHorizontal || 0;\r\n    const alignV = options.alignVertical || 0;\r\n\r\n    const width = options.width || options.size || 1;\r\n    const tilesX = Math.floor(width / tileWidth);\r\n    let offsetX = width - tilesX * tileWidth;\r\n\r\n    const height = options.height || options.size || 1;\r\n    const tilesY = Math.floor(height / tileHeight);\r\n    let offsetY = height - tilesY * tileHeight;\r\n\r\n    const halfWidth = (tileWidth * tilesX) / 2;\r\n    const halfHeight = (tileHeight * tilesY) / 2;\r\n\r\n    let adjustX = 0;\r\n    let adjustY = 0;\r\n    let startX = 0;\r\n    let startY = 0;\r\n    let endX = 0;\r\n    let endY = 0;\r\n\r\n    //Part Tiles\r\n    if (offsetX > 0 || offsetY > 0) {\r\n        startX = -halfWidth;\r\n        startY = -halfHeight;\r\n        endX = halfWidth;\r\n        endY = halfHeight;\r\n\r\n        switch (alignH) {\r\n            case Mesh.CENTER:\r\n                offsetX /= 2;\r\n                startX -= offsetX;\r\n                endX += offsetX;\r\n                break;\r\n            case Mesh.LEFT:\r\n                endX += offsetX;\r\n                adjustX = -offsetX / 2;\r\n                break;\r\n            case Mesh.RIGHT:\r\n                startX -= offsetX;\r\n                adjustX = offsetX / 2;\r\n                break;\r\n        }\r\n\r\n        switch (alignV) {\r\n            case Mesh.CENTER:\r\n                offsetY /= 2;\r\n                startY -= offsetY;\r\n                endY += offsetY;\r\n                break;\r\n            case Mesh.BOTTOM:\r\n                endY += offsetY;\r\n                adjustY = -offsetY / 2;\r\n                break;\r\n            case Mesh.TOP:\r\n                startY -= offsetY;\r\n                adjustY = offsetY / 2;\r\n                break;\r\n        }\r\n    }\r\n\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvBase = [];\r\n    uvBase[0] = [0, 0, 1, 0, 1, 1, 0, 1];\r\n    uvBase[1] = [0, 0, 1, 0, 1, 1, 0, 1];\r\n    if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n        uvBase[1] = [1, 1, 0, 1, 0, 0, 1, 0];\r\n    }\r\n    if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n        uvBase[1] = [1, 0, 0, 0, 0, 1, 1, 1];\r\n    }\r\n    if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n        uvBase[1] = [0, 1, 1, 1, 1, 0, 0, 0];\r\n    }\r\n    let uvs: Array<number> = [];\r\n    const colors = [];\r\n    const indices = [];\r\n    let index = 0;\r\n    for (let y = 0; y < tilesY; y++) {\r\n        for (let x = 0; x < tilesX; x++) {\r\n            positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n            positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n            positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n            positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                uvs = uvs.concat(uvBase[((x % 2) + (y % 2)) % 2]);\r\n            } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvs = uvs.concat(uvBase[y % 2]);\r\n            } else {\r\n                uvs = uvs.concat(uvBase[0]);\r\n            }\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            index += 4;\r\n        }\r\n    }\r\n\r\n    //Part Tiles\r\n    if (offsetX > 0 || offsetY > 0) {\r\n        const partialBottomRow: boolean = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.TOP);\r\n        const partialTopRow: boolean = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.BOTTOM);\r\n        const partialLeftCol: boolean = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.RIGHT);\r\n        const partialRightCol: boolean = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.LEFT);\r\n        let uvPart: Array<number> = [];\r\n        let a, b, c, d: number;\r\n\r\n        //corners\r\n        if (partialBottomRow && partialLeftCol) {\r\n            //bottom left corner\r\n            positions.push(startX + adjustX, startY + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, startY + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, startY + offsetY + adjustY, 0);\r\n            positions.push(startX + adjustX, startY + offsetY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 1 - offsetX / tileWidth;\r\n            b = 1 - offsetY / tileHeight;\r\n            c = 1;\r\n            d = 1;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_ROW) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_ROW) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        if (partialBottomRow && partialRightCol) {\r\n            //bottom right corner\r\n            positions.push(halfWidth + adjustX, startY + adjustY, 0);\r\n            positions.push(endX + adjustX, startY + adjustY, 0);\r\n            positions.push(endX + adjustX, startY + offsetY + adjustY, 0);\r\n            positions.push(halfWidth + adjustX, startY + offsetY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 0;\r\n            b = 1 - offsetY / tileHeight;\r\n            c = offsetX / tileWidth;\r\n            d = 1;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_ROW || (flipTile === Mesh.ROTATE_TILE && tilesX % 2 === 0)) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_ROW || (flipTile === Mesh.FLIP_TILE && tilesX % 2 === 0)) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_ROW || (flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesX % 2 === 0)) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        if (partialTopRow && partialLeftCol) {\r\n            //top left corner\r\n            positions.push(startX + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, endY + adjustY, 0);\r\n            positions.push(startX + adjustX, endY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 1 - offsetX / tileWidth;\r\n            b = 0;\r\n            c = 1;\r\n            d = offsetY / tileHeight;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if ((flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.ROTATE_TILE && tilesY % 1 === 0)) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_TILE && tilesY % 2 === 0)) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesY % 2 === 0)) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        if (partialTopRow && partialRightCol) {\r\n            //top right corner\r\n            positions.push(halfWidth + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(endX + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(endX + adjustX, endY + adjustY, 0);\r\n            positions.push(halfWidth + adjustX, endY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 0;\r\n            b = 0;\r\n            c = offsetX / tileWidth;\r\n            d = offsetY / tileHeight;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if ((flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.ROTATE_TILE && (tilesY + tilesX) % 2 === 1)) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_TILE && (tilesY + tilesX) % 2 === 1)) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_N_ROTATE_TILE && (tilesY + tilesX) % 2 === 1)) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        //part rows\r\n        if (partialBottomRow) {\r\n            const uvBaseBR = [];\r\n            a = 0;\r\n            b = 1 - offsetY / tileHeight;\r\n            c = 1;\r\n            d = 1;\r\n            uvBaseBR[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseBR[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseBR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseBR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseBR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (let x = 0; x < tilesX; x++) {\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, startY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + offsetY + adjustY, 0);\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, startY + offsetY + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseBR[(x + 1) % 2]);\r\n                } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseBR[1]);\r\n                } else {\r\n                    uvs = uvs.concat(uvBaseBR[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n\r\n        if (partialTopRow) {\r\n            const uvBaseTR = [];\r\n            a = 0;\r\n            b = 0;\r\n            c = 1;\r\n            d = offsetY / tileHeight;\r\n            uvBaseTR[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseTR[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseTR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseTR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseTR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (let x = 0; x < tilesX; x++) {\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, endY - offsetY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY - offsetY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY + adjustY, 0);\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, endY + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseTR[(x + tilesY) % 2]);\r\n                } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseTR[tilesY % 2]);\r\n                } else {\r\n                    uvs = uvs.concat(uvBaseTR[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n\r\n        if (partialLeftCol) {\r\n            const uvBaseLC = [];\r\n            a = 1 - offsetX / tileWidth;\r\n            b = 0;\r\n            c = 1;\r\n            d = 1;\r\n            uvBaseLC[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseLC[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseLC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseLC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseLC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (let y = 0; y < tilesY; y++) {\r\n                positions.push(startX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(startX + offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(startX + offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                positions.push(startX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseLC[(y + 1) % 2]);\r\n                } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseLC[y % 2]);\r\n                } else {\r\n                    uvs = uvs.concat(uvBaseLC[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n\r\n        if (partialRightCol) {\r\n            const uvBaseRC = [];\r\n            a = 0;\r\n            b = 0;\r\n            c = offsetX / tileHeight;\r\n            d = 1;\r\n            uvBaseRC[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseRC[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseRC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseRC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseRC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (let y = 0; y < tilesY; y++) {\r\n                positions.push(endX - offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(endX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(endX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                positions.push(endX - offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseRC[(y + tilesX) % 2]);\r\n                } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseRC[y % 2]);\r\n                } else {\r\n                    uvs = uvs.concat(uvBaseRC[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n    }\r\n\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\r\n    vertexData.colors = totalColors;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a tiled plane mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_plane\r\n * @param name defines the name of the mesh\r\n * @param options an object used to set the following optional parameters for the tiled plane, required but can be empty\r\n * * pattern a limited pattern arrangement depending on the number\r\n * * size of the box\r\n * * width of the box, overwrites size\r\n * * height of the box, overwrites size\r\n * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\r\n * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\r\n * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\r\n * * alignVertical places whole tiles aligned to the center, left or right of a column\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.pattern\r\n * @param options.tileSize\r\n * @param options.tileWidth\r\n * @param options.tileHeight\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.alignHorizontal\r\n * @param options.alignVertical\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the box mesh\r\n */\r\nexport function CreateTiledPlane(\r\n    name: string,\r\n    options: {\r\n        pattern?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        updatable?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const plane = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    plane._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateTiledPlaneVertexData(options);\r\n\r\n    vertexData.applyToMesh(plane, options.updatable);\r\n\r\n    return plane;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTiledPlane instead\r\n */\r\nexport const TiledPlaneBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTiledPlane,\r\n};\r\n\r\nVertexData.CreateTiledPlane = CreateTiledPlaneVertexData;\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3, Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { CreateTiledPlaneVertexData } from \"./tiledPlaneBuilder\";\r\nimport { useOpenGLOrientationForUV } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a tiled box\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_box\r\n * @param options an object used to set the following optional parameters for the tiled box, required but can be empty\r\n * * pattern sets the rotation or reflection pattern for the tiles,\r\n * * size of the box\r\n * * width of the box, overwrites size\r\n * * height of the box, overwrites size\r\n * * depth of the box, overwrites size\r\n * * tileSize sets the size of a tile\r\n * * tileWidth sets the tile width and overwrites tileSize\r\n * * tileHeight sets the tile width and overwrites tileSize\r\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\r\n * * alignVertical places whole tiles aligned to the center, left or right of a column\r\n * @param options.pattern\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.tileSize\r\n * @param options.tileWidth\r\n * @param options.tileHeight\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.alignHorizontal\r\n * @param options.alignVertical\r\n * @param options.sideOrientation\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * @returns the VertexData of the TiledBox\r\n */\r\nexport function CreateTiledBoxVertexData(options: {\r\n    pattern?: number;\r\n    size?: number;\r\n    width?: number;\r\n    height?: number;\r\n    depth?: number;\r\n    tileSize?: number;\r\n    tileWidth?: number;\r\n    tileHeight?: number;\r\n    faceUV?: Vector4[];\r\n    faceColors?: Color4[];\r\n    alignHorizontal?: number;\r\n    alignVertical?: number;\r\n    sideOrientation?: number;\r\n}): VertexData {\r\n    const nbFaces = 6;\r\n\r\n    const faceUV: Vector4[] = options.faceUV || new Array<Vector4>(6);\r\n    const faceColors = options.faceColors;\r\n\r\n    const flipTile = options.pattern || Mesh.NO_FLIP;\r\n\r\n    const width = options.width || options.size || 1;\r\n    const height = options.height || options.size || 1;\r\n    const depth = options.depth || options.size || 1;\r\n    const tileWidth = options.tileWidth || options.tileSize || 1;\r\n    const tileHeight = options.tileHeight || options.tileSize || 1;\r\n    const alignH = options.alignHorizontal || 0;\r\n    const alignV = options.alignVertical || 0;\r\n\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // default face colors and UV if undefined\r\n    for (let f = 0; f < nbFaces; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n\r\n    const halfWidth = width / 2;\r\n    const halfHeight = height / 2;\r\n    const halfDepth = depth / 2;\r\n\r\n    const faceVertexData: Array<VertexData> = [];\r\n\r\n    for (let f = 0; f < 2; f++) {\r\n        //front and back\r\n        faceVertexData[f] = CreateTiledPlaneVertexData({\r\n            pattern: flipTile,\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: width,\r\n            height: height,\r\n            alignVertical: alignV,\r\n            alignHorizontal: alignH,\r\n            sideOrientation: sideOrientation,\r\n        });\r\n    }\r\n\r\n    for (let f = 2; f < 4; f++) {\r\n        //sides\r\n        faceVertexData[f] = CreateTiledPlaneVertexData({\r\n            pattern: flipTile,\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: depth,\r\n            height: height,\r\n            alignVertical: alignV,\r\n            alignHorizontal: alignH,\r\n            sideOrientation: sideOrientation,\r\n        });\r\n    }\r\n\r\n    let baseAlignV = alignV;\r\n    if (alignV === Mesh.BOTTOM) {\r\n        baseAlignV = Mesh.TOP;\r\n    } else if (alignV === Mesh.TOP) {\r\n        baseAlignV = Mesh.BOTTOM;\r\n    }\r\n\r\n    for (let f = 4; f < 6; f++) {\r\n        //top and bottom\r\n        faceVertexData[f] = CreateTiledPlaneVertexData({\r\n            pattern: flipTile,\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: width,\r\n            height: depth,\r\n            alignVertical: baseAlignV,\r\n            alignHorizontal: alignH,\r\n            sideOrientation: sideOrientation,\r\n        });\r\n    }\r\n\r\n    let positions: Array<number> = [];\r\n    let normals: Array<number> = [];\r\n    let uvs: Array<number> = [];\r\n    let indices: Array<number> = [];\r\n    const colors: Array<number> = [];\r\n    const facePositions: Array<Array<Vector3>> = [];\r\n    const faceNormals: Array<Array<Vector3>> = [];\r\n\r\n    const newFaceUV: Array<Array<number>> = [];\r\n    let lu: number = 0;\r\n\r\n    let li: number = 0;\r\n\r\n    for (let f = 0; f < nbFaces; f++) {\r\n        const len = faceVertexData[f].positions!.length;\r\n        facePositions[f] = [];\r\n        faceNormals[f] = [];\r\n        for (let p = 0; p < len / 3; p++) {\r\n            facePositions[f].push(new Vector3(faceVertexData[f].positions![3 * p], faceVertexData[f].positions![3 * p + 1], faceVertexData[f].positions![3 * p + 2]));\r\n            faceNormals[f].push(new Vector3(faceVertexData[f].normals![3 * p], faceVertexData[f].normals![3 * p + 1], faceVertexData[f].normals![3 * p + 2]));\r\n        }\r\n        // uvs\r\n        lu = faceVertexData[f].uvs!.length;\r\n        newFaceUV[f] = [];\r\n        for (let i = 0; i < lu; i += 2) {\r\n            newFaceUV[f][i] = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * faceVertexData[f].uvs![i];\r\n            newFaceUV[f][i + 1] = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * faceVertexData[f].uvs![i + 1];\r\n\r\n            if (useOpenGLOrientationForUV) {\r\n                newFaceUV[f][i + 1] = 1.0 - newFaceUV[f][i + 1];\r\n            }\r\n        }\r\n        uvs = uvs.concat(newFaceUV[f]);\r\n\r\n        indices = indices.concat(<Array<number>>faceVertexData[f].indices!.map((x: number) => x + li));\r\n        li += facePositions[f].length;\r\n        if (faceColors) {\r\n            for (let c = 0; c < 4; c++) {\r\n                colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);\r\n            }\r\n        }\r\n    }\r\n\r\n    const vec0 = new Vector3(0, 0, halfDepth);\r\n    const mtrx0 = Matrix.RotationY(Math.PI);\r\n    positions = facePositions[0]\r\n        .map((entry) => Vector3.TransformNormal(entry, mtrx0).add(vec0))\r\n        .map((entry) => [entry.x, entry.y, entry.z])\r\n        .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), []);\r\n    normals = faceNormals[0]\r\n        .map((entry) => Vector3.TransformNormal(entry, mtrx0))\r\n        .map((entry) => [entry.x, entry.y, entry.z])\r\n        .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), []);\r\n    positions = positions.concat(\r\n        facePositions[1]\r\n            .map((entry) => entry.subtract(vec0))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(faceNormals[1].map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), []));\r\n\r\n    const vec2 = new Vector3(halfWidth, 0, 0);\r\n    const mtrx2 = Matrix.RotationY(-Math.PI / 2);\r\n    positions = positions.concat(\r\n        facePositions[2]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx2).add(vec2))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(\r\n        faceNormals[2]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx2))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    const mtrx3 = Matrix.RotationY(Math.PI / 2);\r\n    positions = positions.concat(\r\n        facePositions[3]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx3).subtract(vec2))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(\r\n        faceNormals[3]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx3))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n\r\n    const vec4 = new Vector3(0, halfHeight, 0);\r\n    const mtrx4 = Matrix.RotationX(Math.PI / 2);\r\n    positions = positions.concat(\r\n        facePositions[4]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx4).add(vec4))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(\r\n        faceNormals[4]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx4))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    const mtrx5 = Matrix.RotationX(-Math.PI / 2);\r\n    positions = positions.concat(\r\n        facePositions[5]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx5).subtract(vec4))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(\r\n        faceNormals[5]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx5))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    if (faceColors) {\r\n        const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a tiled box mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_box\r\n * @param name defines the name of the mesh\r\n * @param options an object used to set the following optional parameters for the tiled box, required but can be empty\r\n * * pattern sets the rotation or reflection pattern for the tiles,\r\n * * size of the box\r\n * * width of the box, overwrites size\r\n * * height of the box, overwrites size\r\n * * depth of the box, overwrites size\r\n * * tileSize sets the size of a tile\r\n * * tileWidth sets the tile width and overwrites tileSize\r\n * * tileHeight sets the tile width and overwrites tileSize\r\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\r\n * * alignVertical places whole tiles aligned to the center, left or right of a column\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * @param options.pattern\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.tileSize\r\n * @param options.tileWidth\r\n * @param options.tileHeight\r\n * @param options.alignHorizontal\r\n * @param options.alignVertical\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.sideOrientation\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the box mesh\r\n */\r\nexport function CreateTiledBox(\r\n    name: string,\r\n    options: {\r\n        pattern?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n        updatable?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const box = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    box._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateTiledBoxVertexData(options);\r\n\r\n    vertexData.applyToMesh(box, options.updatable);\r\n\r\n    return box;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTiledBox instead\r\n */\r\nexport const TiledBoxBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTiledBox,\r\n};\r\n\r\nVertexData.CreateTiledBox = CreateTiledBoxVertexData;\r\n", "import type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { useOpenGLOrientationForUV } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for an ellipsoid, defaults to a sphere\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * segments sets the number of horizontal strips optional, default 32\r\n * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\r\n * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\r\n * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\r\n * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\r\n * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\r\n * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @returns the VertexData of the ellipsoid\r\n */\r\nexport function CreateSphereVertexData(options: {\r\n    segments?: number;\r\n    diameter?: number;\r\n    diameterX?: number;\r\n    diameterY?: number;\r\n    diameterZ?: number;\r\n    arc?: number;\r\n    slice?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    dedupTopBottomIndices?: boolean;\r\n}): VertexData {\r\n    const segments: number = (options.segments || 32) | 0;\r\n    const diameterX: number = options.diameterX || options.diameter || 1;\r\n    const diameterY: number = options.diameterY || options.diameter || 1;\r\n    const diameterZ: number = options.diameterZ || options.diameter || 1;\r\n    const arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    const slice: number = options.slice && options.slice <= 0 ? 1.0 : options.slice || 1.0;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const dedupTopBottomIndices = !!options.dedupTopBottomIndices;\r\n\r\n    const radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\r\n\r\n    const totalZRotationSteps = 2 + segments;\r\n    const totalYRotationSteps = 2 * totalZRotationSteps;\r\n\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    for (let zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\r\n        const normalizedZ = zRotationStep / totalZRotationSteps;\r\n        const angleZ = normalizedZ * Math.PI * slice;\r\n\r\n        for (let yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\r\n            const normalizedY = yRotationStep / totalYRotationSteps;\r\n\r\n            const angleY = normalizedY * Math.PI * 2 * arc;\r\n\r\n            const rotationZ = Matrix.RotationZ(-angleZ);\r\n            const rotationY = Matrix.RotationY(angleY);\r\n            const afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);\r\n            const complete = Vector3.TransformCoordinates(afterRotZ, rotationY);\r\n\r\n            const vertex = complete.multiply(radius);\r\n            const normal = complete.divide(radius).normalize();\r\n\r\n            positions.push(vertex.x, vertex.y, vertex.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(normalizedY, useOpenGLOrientationForUV ? 1.0 - normalizedZ : normalizedZ);\r\n        }\r\n\r\n        if (zRotationStep > 0) {\r\n            const verticesCount = positions.length / 3;\r\n            for (let firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {\r\n                if (dedupTopBottomIndices) {\r\n                    if (zRotationStep > 1) {\r\n                        indices.push(firstIndex);\r\n                        indices.push(firstIndex + 1);\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    }\r\n                    if (zRotationStep < totalZRotationSteps || slice < 1.0) {\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                        indices.push(firstIndex + 1);\r\n                        indices.push(firstIndex + totalYRotationSteps + 2);\r\n                    }\r\n                } else {\r\n                    indices.push(firstIndex);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 2);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a sphere mesh\r\n * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\r\n * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\r\n * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\r\n * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\r\n * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the sphere mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#sphere\r\n */\r\nexport function CreateSphere(\r\n    name: string,\r\n    options: {\r\n        segments?: number;\r\n        diameter?: number;\r\n        diameterX?: number;\r\n        diameterY?: number;\r\n        diameterZ?: number;\r\n        arc?: number;\r\n        slice?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        updatable?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const sphere = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    sphere._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateSphereVertexData(options);\r\n\r\n    vertexData.applyToMesh(sphere, options.updatable);\r\n\r\n    return sphere;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateSphere directly\r\n */\r\nexport const SphereBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateSphere,\r\n};\r\n\r\nVertexData.CreateSphere = CreateSphereVertexData;\r\n\r\nMesh.CreateSphere = (name: string, segments: number, diameter: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        segments: segments,\r\n        diameterX: diameter,\r\n        diameterY: diameter,\r\n        diameterZ: diameter,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return CreateSphere(name, options, scene);\r\n};\r\n", "import { Vector4, Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { useOpenGLOrientationForUV } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a cylinder, cone or prism\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * height sets the height (y direction) of the cylinder, optional, default 2\r\n * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\r\n * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\r\n * * diameter sets the diameter of the top and bottom of the cone, optional default 1\r\n * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n * * subdivisions` the number of rings along the cylinder height, optional, default 1\r\n * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\r\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\r\n * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @returns the VertexData of the cylinder, cone or prism\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function CreateCylinderVertexData(options: {\r\n    height?: number;\r\n    diameterTop?: number;\r\n    diameterBottom?: number;\r\n    diameter?: number;\r\n    tessellation?: number;\r\n    subdivisions?: number;\r\n    arc?: number;\r\n    faceColors?: Color4[];\r\n    faceUV?: Vector4[];\r\n    hasRings?: boolean;\r\n    enclose?: boolean;\r\n    cap?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const height: number = options.height || 2;\r\n    let diameterTop: number = options.diameterTop === 0 ? 0 : options.diameterTop || options.diameter || 1;\r\n    let diameterBottom: number = options.diameterBottom === 0 ? 0 : options.diameterBottom || options.diameter || 1;\r\n    diameterTop = diameterTop || 0.00001; // Prevent broken normals\r\n    diameterBottom = diameterBottom || 0.00001; // Prevent broken normals\r\n    const tessellation: number = (options.tessellation || 24) | 0;\r\n    const subdivisions: number = (options.subdivisions || 1) | 0;\r\n    const hasRings: boolean = options.hasRings ? true : false;\r\n    const enclose: boolean = options.enclose ? true : false;\r\n    const cap = options.cap === 0 ? 0 : options.cap || Mesh.CAP_ALL;\r\n    const arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    const sideOrientation: number = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const faceUV: Vector4[] = options.faceUV || new Array<Vector4>(3);\r\n    const faceColors = options.faceColors;\r\n    // default face colors and UV if undefined\r\n    const quadNb: number = arc !== 1 && enclose ? 2 : 0;\r\n    const ringNb: number = hasRings ? subdivisions : 1;\r\n    const surfaceNb: number = 2 + (1 + quadNb) * ringNb;\r\n    let f: number;\r\n\r\n    for (f = 0; f < surfaceNb; f++) {\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n    for (f = 0; f < surfaceNb; f++) {\r\n        if (faceUV && faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n    }\r\n\r\n    const indices: number[] = [];\r\n    const positions: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n    const colors: number[] = [];\r\n\r\n    const angleStep = (Math.PI * 2 * arc) / tessellation;\r\n    let angle: number;\r\n    let h: number;\r\n    let radius: number;\r\n    const tan = (diameterBottom - diameterTop) / 2 / height;\r\n    const ringVertex: Vector3 = Vector3.Zero();\r\n    const ringNormal: Vector3 = Vector3.Zero();\r\n    const ringFirstVertex: Vector3 = Vector3.Zero();\r\n    const ringFirstNormal: Vector3 = Vector3.Zero();\r\n    const quadNormal: Vector3 = Vector3.Zero();\r\n    const Y: Vector3 = Axis.Y;\r\n\r\n    // positions, normals, uvs\r\n    let i: number;\r\n    let j: number;\r\n    let r: number;\r\n    let ringIdx: number = 1;\r\n    let s: number = 1; // surface index\r\n    let cs: number = 0;\r\n    let v: number = 0;\r\n\r\n    for (i = 0; i <= subdivisions; i++) {\r\n        h = i / subdivisions;\r\n        radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;\r\n        ringIdx = hasRings && i !== 0 && i !== subdivisions ? 2 : 1;\r\n        for (r = 0; r < ringIdx; r++) {\r\n            if (hasRings) {\r\n                s += r;\r\n            }\r\n            if (enclose) {\r\n                s += 2 * r;\r\n            }\r\n            for (j = 0; j <= tessellation; j++) {\r\n                angle = j * angleStep;\r\n\r\n                // position\r\n                ringVertex.x = Math.cos(-angle) * radius;\r\n                ringVertex.y = -height / 2 + h * height;\r\n                ringVertex.z = Math.sin(-angle) * radius;\r\n\r\n                // normal\r\n                if (diameterTop === 0 && i === subdivisions) {\r\n                    // if no top cap, reuse former normals\r\n                    ringNormal.x = normals[normals.length - (tessellation + 1) * 3];\r\n                    ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];\r\n                    ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];\r\n                } else {\r\n                    ringNormal.x = ringVertex.x;\r\n                    ringNormal.z = ringVertex.z;\r\n                    ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;\r\n                    ringNormal.normalize();\r\n                }\r\n\r\n                // keep first ring vertex values for enclose\r\n                if (j === 0) {\r\n                    ringFirstVertex.copyFrom(ringVertex);\r\n                    ringFirstNormal.copyFrom(ringNormal);\r\n                }\r\n\r\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\r\n                normals.push(ringNormal.x, ringNormal.y, ringNormal.z);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s].y : faceUV[s].w;\r\n                } else {\r\n                    v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;\r\n                }\r\n                uvs.push(faceUV[s].x + ((faceUV[s].z - faceUV[s].x) * j) / tessellation, useOpenGLOrientationForUV ? 1 - v : v);\r\n                if (faceColors) {\r\n                    colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);\r\n                }\r\n            }\r\n\r\n            // if enclose, add four vertices and their dedicated normals\r\n            if (arc !== 1 && enclose) {\r\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\r\n                positions.push(0, ringVertex.y, 0);\r\n                positions.push(0, ringVertex.y, 0);\r\n                positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);\r\n                Vector3.CrossToRef(Y, ringNormal, quadNormal);\r\n                quadNormal.normalize();\r\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\r\n                Vector3.CrossToRef(ringFirstNormal, Y, quadNormal);\r\n                quadNormal.normalize();\r\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s + 1].y : faceUV[s + 1].w;\r\n                } else {\r\n                    v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;\r\n                }\r\n                uvs.push(faceUV[s + 1].x, useOpenGLOrientationForUV ? 1 - v : v);\r\n                uvs.push(faceUV[s + 1].z, useOpenGLOrientationForUV ? 1 - v : v);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s + 2].y : faceUV[s + 2].w;\r\n                } else {\r\n                    v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;\r\n                }\r\n                uvs.push(faceUV[s + 2].x, useOpenGLOrientationForUV ? 1 - v : v);\r\n                uvs.push(faceUV[s + 2].z, useOpenGLOrientationForUV ? 1 - v : v);\r\n                if (faceColors) {\r\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\r\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\r\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\r\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\r\n                }\r\n            }\r\n            if (cs !== s) {\r\n                cs = s;\r\n            }\r\n        }\r\n    }\r\n\r\n    // indices\r\n    const e: number = arc !== 1 && enclose ? tessellation + 4 : tessellation; // correction of number of iteration if enclose\r\n    i = 0;\r\n    for (s = 0; s < subdivisions; s++) {\r\n        let i0: number = 0;\r\n        let i1: number = 0;\r\n        let i2: number = 0;\r\n        let i3: number = 0;\r\n        for (j = 0; j < tessellation; j++) {\r\n            i0 = i * (e + 1) + j;\r\n            i1 = (i + 1) * (e + 1) + j;\r\n            i2 = i * (e + 1) + (j + 1);\r\n            i3 = (i + 1) * (e + 1) + (j + 1);\r\n            indices.push(i0, i1, i2);\r\n            indices.push(i3, i2, i1);\r\n        }\r\n        if (arc !== 1 && enclose) {\r\n            // if enclose, add two quads\r\n            indices.push(i0 + 2, i1 + 2, i2 + 2);\r\n            indices.push(i3 + 2, i2 + 2, i1 + 2);\r\n            indices.push(i0 + 4, i1 + 4, i2 + 4);\r\n            indices.push(i3 + 4, i2 + 4, i1 + 4);\r\n        }\r\n        i = hasRings ? i + 2 : i + 1;\r\n    }\r\n\r\n    // Caps\r\n    const createCylinderCap = (isTop: boolean) => {\r\n        const radius = isTop ? diameterTop / 2 : diameterBottom / 2;\r\n        if (radius === 0) {\r\n            return;\r\n        }\r\n\r\n        // Cap positions, normals & uvs\r\n        let angle;\r\n        let circleVector;\r\n        let i: number;\r\n        const u: Vector4 = isTop ? faceUV[surfaceNb - 1] : faceUV[0];\r\n        let c: Nullable<Color4> = null;\r\n        if (faceColors) {\r\n            c = isTop ? faceColors[surfaceNb - 1] : faceColors[0];\r\n        }\r\n        // cap center\r\n        const vbase = positions.length / 3;\r\n        const offset = isTop ? height / 2 : -height / 2;\r\n        const center = new Vector3(0, offset, 0);\r\n        positions.push(center.x, center.y, center.z);\r\n        normals.push(0, isTop ? 1 : -1, 0);\r\n        const v = u.y + (u.w - u.y) * 0.5;\r\n        uvs.push(u.x + (u.z - u.x) * 0.5, useOpenGLOrientationForUV ? 1 - v : v);\r\n        if (c) {\r\n            colors.push(c.r, c.g, c.b, c.a);\r\n        }\r\n\r\n        const textureScale = new Vector2(0.5, 0.5);\r\n        for (i = 0; i <= tessellation; i++) {\r\n            angle = (Math.PI * 2 * i * arc) / tessellation;\r\n            const cos = Math.cos(-angle);\r\n            const sin = Math.sin(-angle);\r\n            circleVector = new Vector3(cos * radius, offset, sin * radius);\r\n            const textureCoordinate = new Vector2(cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);\r\n            positions.push(circleVector.x, circleVector.y, circleVector.z);\r\n            normals.push(0, isTop ? 1 : -1, 0);\r\n            const v = u.y + (u.w - u.y) * textureCoordinate.y;\r\n            uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, useOpenGLOrientationForUV ? 1 - v : v);\r\n            if (c) {\r\n                colors.push(c.r, c.g, c.b, c.a);\r\n            }\r\n        }\r\n        // Cap indices\r\n        for (i = 0; i < tessellation; i++) {\r\n            if (!isTop) {\r\n                indices.push(vbase);\r\n                indices.push(vbase + (i + 1));\r\n                indices.push(vbase + (i + 2));\r\n            } else {\r\n                indices.push(vbase);\r\n                indices.push(vbase + (i + 2));\r\n                indices.push(vbase + (i + 1));\r\n            }\r\n        }\r\n    };\r\n\r\n    // add caps to geometry based on cap parameter\r\n    if (cap === Mesh.CAP_START || cap === Mesh.CAP_ALL) {\r\n        createCylinderCap(false);\r\n    }\r\n    if (cap === Mesh.CAP_END || cap === Mesh.CAP_ALL) {\r\n        createCylinderCap(true);\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    if (faceColors) {\r\n        vertexData.colors = colors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a cylinder or a cone mesh\r\n * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).\r\n * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).\r\n * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter \"diameterBottom\" can't be zero.\r\n * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.\r\n * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).\r\n * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.\r\n * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.\r\n * * The parameter `cap` sets the way the cylinder is capped. Possible values : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL (default).\r\n * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.\r\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).\r\n * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3\r\n * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7\r\n * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17\r\n * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.\r\n * * If `enclose` is false, a ring surface is one element.\r\n * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.\r\n * * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the cylinder mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#cylinder-or-cone\r\n */\r\nexport function CreateCylinder(\r\n    name: string,\r\n    options: {\r\n        height?: number;\r\n        diameterTop?: number;\r\n        diameterBottom?: number;\r\n        diameter?: number;\r\n        tessellation?: number;\r\n        subdivisions?: number;\r\n        arc?: number;\r\n        faceColors?: Color4[];\r\n        faceUV?: Vector4[];\r\n        updatable?: boolean;\r\n        hasRings?: boolean;\r\n        enclose?: boolean;\r\n        cap?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    } = {},\r\n    scene?: Nullable<Scene>\r\n): Mesh {\r\n    const cylinder = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    cylinder._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateCylinderVertexData(options);\r\n\r\n    vertexData.applyToMesh(cylinder, options.updatable);\r\n\r\n    return cylinder;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated Please use CreateCylinder directly\r\n */\r\nexport const CylinderBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateCylinder,\r\n};\r\n\r\nVertexData.CreateCylinder = CreateCylinderVertexData;\r\n\r\nMesh.CreateCylinder = (\r\n    name: string,\r\n    height: number,\r\n    diameterTop: number,\r\n    diameterBottom: number,\r\n    tessellation: number,\r\n    subdivisions: any,\r\n    scene?: Scene,\r\n    updatable?: any,\r\n    sideOrientation?: number\r\n): Mesh => {\r\n    if (scene === undefined || !(scene instanceof Scene)) {\r\n        if (scene !== undefined) {\r\n            sideOrientation = updatable || Mesh.DEFAULTSIDE;\r\n            updatable = scene;\r\n        }\r\n        scene = <Scene>subdivisions;\r\n        subdivisions = 1;\r\n    }\r\n\r\n    const options = {\r\n        height,\r\n        diameterTop,\r\n        diameterBottom,\r\n        tessellation,\r\n        subdivisions,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateCylinder(name, options, scene);\r\n};\r\n", "import type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Matrix, Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { useOpenGLOrientationForUV } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a torus\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * diameter the diameter of the torus, optional default 1\r\n * * thickness the diameter of the tube forming the torus, optional default 0.5\r\n * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.diameter\r\n * @param options.thickness\r\n * @param options.tessellation\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the torus\r\n */\r\nexport function CreateTorusVertexData(options: { diameter?: number; thickness?: number; tessellation?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }) {\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    const diameter = options.diameter || 1;\r\n    const thickness = options.thickness || 0.5;\r\n    const tessellation = (options.tessellation || 16) | 0;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    const stride = tessellation + 1;\r\n\r\n    for (let i = 0; i <= tessellation; i++) {\r\n        const u = i / tessellation;\r\n\r\n        const outerAngle = (i * Math.PI * 2.0) / tessellation - Math.PI / 2.0;\r\n\r\n        const transform = Matrix.Translation(diameter / 2.0, 0, 0).multiply(Matrix.RotationY(outerAngle));\r\n\r\n        for (let j = 0; j <= tessellation; j++) {\r\n            const v = 1 - j / tessellation;\r\n\r\n            const innerAngle = (j * Math.PI * 2.0) / tessellation + Math.PI;\r\n            const dx = Math.cos(innerAngle);\r\n            const dy = Math.sin(innerAngle);\r\n\r\n            // Create a vertex.\r\n            let normal = new Vector3(dx, dy, 0);\r\n            let position = normal.scale(thickness / 2);\r\n            const textureCoordinate = new Vector2(u, v);\r\n\r\n            position = Vector3.TransformCoordinates(position, transform);\r\n            normal = Vector3.TransformNormal(normal, transform);\r\n\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(textureCoordinate.x, useOpenGLOrientationForUV ? 1.0 - textureCoordinate.y : textureCoordinate.y);\r\n\r\n            // And create indices for two triangles.\r\n            const nextI = (i + 1) % stride;\r\n            const nextJ = (j + 1) % stride;\r\n\r\n            indices.push(i * stride + j);\r\n            indices.push(i * stride + nextJ);\r\n            indices.push(nextI * stride + j);\r\n\r\n            indices.push(i * stride + nextJ);\r\n            indices.push(nextI * stride + nextJ);\r\n            indices.push(nextI * stride + j);\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a torus mesh\r\n * * The parameter `diameter` sets the diameter size (float) of the torus (default 1)\r\n * * The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5)\r\n * * The parameter `tessellation` sets the number of torus sides (positive integer, default 16)\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.diameter\r\n * @param options.thickness\r\n * @param options.tessellation\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param scene defines the hosting scene\r\n * @returns the torus mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#torus\r\n */\r\nexport function CreateTorus(\r\n    name: string,\r\n    options: { diameter?: number; thickness?: number; tessellation?: number; updatable?: boolean; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 } = {},\r\n    scene?: Scene\r\n): Mesh {\r\n    const torus = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    torus._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateTorusVertexData(options);\r\n\r\n    vertexData.applyToMesh(torus, options.updatable);\r\n\r\n    return torus;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTorus instead\r\n */\r\nexport const TorusBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTorus,\r\n};\r\n\r\nVertexData.CreateTorus = CreateTorusVertexData;\r\n\r\nMesh.CreateTorus = (name: string, diameter: number, thickness: number, tessellation: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        diameter,\r\n        thickness,\r\n        tessellation,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateTorus(name, options, scene);\r\n};\r\n", "import type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { useOpenGLOrientationForUV } from \"../../Compat/compatibilityOptions\";\r\n\r\n// based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n/**\r\n * Creates the VertexData for a TorusKnot\r\n * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\r\n * * radius the radius of the torus knot, optional, default 2\r\n * * tube the thickness of the tube, optional, default 0.5\r\n * * radialSegments the number of sides on each tube segments, optional, default 32\r\n * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\r\n * * p the number of windings around the z axis, optional,  default 2\r\n * * q the number of windings around the x axis, optional,  default 3\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.radius\r\n * @param options.tube\r\n * @param options.radialSegments\r\n * @param options.tubularSegments\r\n * @param options.p\r\n * @param options.q\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the Torus Knot\r\n */\r\nexport function CreateTorusKnotVertexData(options: {\r\n    radius?: number;\r\n    tube?: number;\r\n    radialSegments?: number;\r\n    tubularSegments?: number;\r\n    p?: number;\r\n    q?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const indices: number[] = [];\r\n    const positions: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n\r\n    const radius = options.radius || 2;\r\n    const tube = options.tube || 0.5;\r\n    const radialSegments = options.radialSegments || 32;\r\n    const tubularSegments = options.tubularSegments || 32;\r\n    const p = options.p || 2;\r\n    const q = options.q || 3;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // Helper\r\n    const getPos = (angle: number) => {\r\n        const cu = Math.cos(angle);\r\n        const su = Math.sin(angle);\r\n        const quOverP = (q / p) * angle;\r\n        const cs = Math.cos(quOverP);\r\n\r\n        const tx = radius * (2 + cs) * 0.5 * cu;\r\n        const ty = radius * (2 + cs) * su * 0.5;\r\n        const tz = radius * Math.sin(quOverP) * 0.5;\r\n\r\n        return new Vector3(tx, ty, tz);\r\n    };\r\n\r\n    // Vertices\r\n    let i: number;\r\n    let j: number;\r\n    for (i = 0; i <= radialSegments; i++) {\r\n        const modI = i % radialSegments;\r\n        const u = (modI / radialSegments) * 2 * p * Math.PI;\r\n        const p1 = getPos(u);\r\n        const p2 = getPos(u + 0.01);\r\n        const tang = p2.subtract(p1);\r\n        let n = p2.add(p1);\r\n\r\n        const bitan = Vector3.Cross(tang, n);\r\n        n = Vector3.Cross(bitan, tang);\r\n\r\n        bitan.normalize();\r\n        n.normalize();\r\n\r\n        for (j = 0; j < tubularSegments; j++) {\r\n            const modJ = j % tubularSegments;\r\n            const v = (modJ / tubularSegments) * 2 * Math.PI;\r\n            const cx = -tube * Math.cos(v);\r\n            const cy = tube * Math.sin(v);\r\n\r\n            positions.push(p1.x + cx * n.x + cy * bitan.x);\r\n            positions.push(p1.y + cx * n.y + cy * bitan.y);\r\n            positions.push(p1.z + cx * n.z + cy * bitan.z);\r\n\r\n            uvs.push(i / radialSegments);\r\n            uvs.push(useOpenGLOrientationForUV ? 1.0 - j / tubularSegments : j / tubularSegments);\r\n        }\r\n    }\r\n\r\n    for (i = 0; i < radialSegments; i++) {\r\n        for (j = 0; j < tubularSegments; j++) {\r\n            const jNext = (j + 1) % tubularSegments;\r\n            const a = i * tubularSegments + j;\r\n            const b = (i + 1) * tubularSegments + j;\r\n            const c = (i + 1) * tubularSegments + jNext;\r\n            const d = i * tubularSegments + jNext;\r\n\r\n            indices.push(d);\r\n            indices.push(b);\r\n            indices.push(a);\r\n            indices.push(d);\r\n            indices.push(c);\r\n            indices.push(b);\r\n        }\r\n    }\r\n\r\n    // Normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a torus knot mesh\r\n * * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)\r\n * * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)\r\n * * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)\r\n * * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.radius\r\n * @param options.tube\r\n * @param options.radialSegments\r\n * @param options.tubularSegments\r\n * @param options.p\r\n * @param options.q\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param scene defines the hosting scene\r\n * @returns the torus knot mesh\r\n * @see  https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#torus-knot\r\n */\r\nexport function CreateTorusKnot(\r\n    name: string,\r\n    options: {\r\n        radius?: number;\r\n        tube?: number;\r\n        radialSegments?: number;\r\n        tubularSegments?: number;\r\n        p?: number;\r\n        q?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    } = {},\r\n    scene?: Scene\r\n): Mesh {\r\n    const torusKnot = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    torusKnot._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateTorusKnotVertexData(options);\r\n\r\n    vertexData.applyToMesh(torusKnot, options.updatable);\r\n\r\n    return torusKnot;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTorusKnot instead\r\n */\r\nexport const TorusKnotBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTorusKnot,\r\n};\r\n\r\nVertexData.CreateTorusKnot = CreateTorusKnotVertexData;\r\n\r\nMesh.CreateTorusKnot = (\r\n    name: string,\r\n    radius: number,\r\n    tube: number,\r\n    radialSegments: number,\r\n    tubularSegments: number,\r\n    p: number,\r\n    q: number,\r\n    scene?: Scene,\r\n    updatable?: boolean,\r\n    sideOrientation?: number\r\n): Mesh => {\r\n    const options = {\r\n        radius,\r\n        tube,\r\n        radialSegments,\r\n        tubularSegments,\r\n        p,\r\n        q,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateTorusKnot(name, options, scene);\r\n};\r\n", "import type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport { Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Node } from \"../node\";\r\nimport type { IMeshDataOptions } from \"../Meshes/abstractMesh\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport { TransformNode } from \"./transformNode\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { Geometry } from \"./geometry\";\r\n\r\nMesh._instancedMeshFactory = (name: string, mesh: Mesh): InstancedMesh => {\r\n    const instance = new InstancedMesh(name, mesh);\r\n\r\n    if (mesh.instancedBuffers) {\r\n        instance.instancedBuffers = {};\r\n\r\n        for (const key in mesh.instancedBuffers) {\r\n            instance.instancedBuffers[key] = mesh.instancedBuffers[key];\r\n        }\r\n    }\r\n\r\n    return instance;\r\n};\r\n\r\n/**\r\n * Creates an instance based on a source mesh.\r\n */\r\nexport class InstancedMesh extends AbstractMesh {\r\n    private _sourceMesh: Mesh;\r\n    private _currentLOD: Mesh;\r\n    private _billboardWorldMatrix: Matrix;\r\n\r\n    /** @internal */\r\n    public _indexInSourceMeshInstanceArray = -1;\r\n    /** @internal */\r\n    public _distanceToCamera: number = 0;\r\n    /** @internal */\r\n    public _previousWorldMatrix: Nullable<Matrix>;\r\n\r\n    /**\r\n     * Creates a new InstancedMesh object from the mesh source.\r\n     * @param name defines the name of the instance\r\n     * @param source the mesh to create the instance from\r\n     */\r\n    constructor(name: string, source: Mesh) {\r\n        super(name, source.getScene());\r\n\r\n        source.addInstance(this);\r\n\r\n        this._sourceMesh = source;\r\n\r\n        this._unIndexed = source._unIndexed;\r\n\r\n        this.position.copyFrom(source.position);\r\n        this.rotation.copyFrom(source.rotation);\r\n        this.scaling.copyFrom(source.scaling);\r\n\r\n        if (source.rotationQuaternion) {\r\n            this.rotationQuaternion = source.rotationQuaternion.clone();\r\n        }\r\n\r\n        this.animations = source.animations.slice();\r\n        for (const range of source.getAnimationRanges()) {\r\n            if (range != null) {\r\n                this.createAnimationRange(range.name, range.from, range.to);\r\n            }\r\n        }\r\n\r\n        this.infiniteDistance = source.infiniteDistance;\r\n\r\n        this.setPivotMatrix(source.getPivotMatrix());\r\n\r\n        this.refreshBoundingInfo(true, true);\r\n        this._syncSubMeshes();\r\n    }\r\n\r\n    /**\r\n     * @returns the string \"InstancedMesh\".\r\n     */\r\n    public override getClassName(): string {\r\n        return \"InstancedMesh\";\r\n    }\r\n\r\n    /** Gets the list of lights affecting that mesh */\r\n    public override get lightSources(): Light[] {\r\n        return this._sourceMesh._lightSources;\r\n    }\r\n\r\n    public override _resyncLightSources(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public override _resyncLightSource(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public override _removeLightSource(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * If the source mesh receives shadows\r\n     */\r\n    public override get receiveShadows(): boolean {\r\n        return this._sourceMesh.receiveShadows;\r\n    }\r\n\r\n    public override set receiveShadows(_value: boolean) {\r\n        if (this._sourceMesh?.receiveShadows !== _value) {\r\n            Tools.Warn(\"Setting receiveShadows on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The material of the source mesh\r\n     */\r\n    public override get material(): Nullable<Material> {\r\n        return this._sourceMesh.material;\r\n    }\r\n\r\n    public override set material(_value: Nullable<Material>) {\r\n        if (this._sourceMesh?.material !== _value) {\r\n            Tools.Warn(\"Setting material on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Visibility of the source mesh\r\n     */\r\n    public override get visibility(): number {\r\n        return this._sourceMesh.visibility;\r\n    }\r\n\r\n    public override set visibility(_value: number) {\r\n        if (this._sourceMesh?.visibility !== _value) {\r\n            Tools.Warn(\"Setting visibility on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Skeleton of the source mesh\r\n     */\r\n    public override get skeleton(): Nullable<Skeleton> {\r\n        return this._sourceMesh.skeleton;\r\n    }\r\n\r\n    public override set skeleton(_value: Nullable<Skeleton>) {\r\n        if (this._sourceMesh?.skeleton !== _value) {\r\n            Tools.Warn(\"Setting skeleton on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rendering ground id of the source mesh\r\n     */\r\n    public override get renderingGroupId(): number {\r\n        return this._sourceMesh.renderingGroupId;\r\n    }\r\n\r\n    public override set renderingGroupId(value: number) {\r\n        if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {\r\n            return;\r\n        }\r\n\r\n        //no-op with warning\r\n        Logger.Warn(\"Note - setting renderingGroupId of an instanced mesh has no effect on the scene\");\r\n    }\r\n\r\n    /**\r\n     * @returns the total number of vertices (integer).\r\n     */\r\n    public override getTotalVertices(): number {\r\n        return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;\r\n    }\r\n\r\n    /**\r\n     * Returns a positive integer : the total number of indices in this mesh geometry.\r\n     * @returns the number of indices or zero if the mesh has no geometry.\r\n     */\r\n    public override getTotalIndices(): number {\r\n        return this._sourceMesh.getTotalIndices();\r\n    }\r\n\r\n    /**\r\n     * The source mesh of the instance\r\n     */\r\n    public get sourceMesh(): Mesh {\r\n        return this._sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Gets the mesh internal Geometry object\r\n     */\r\n    public get geometry(): Nullable<Geometry> {\r\n        return this._sourceMesh._geometry;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedMesh\r\n     */\r\n    public createInstance(name: string): InstancedMesh {\r\n        return this._sourceMesh.createInstance(name);\r\n    }\r\n\r\n    /**\r\n     * Is this node ready to be used/rendered\r\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\r\n     * @returns {boolean} is it ready\r\n     */\r\n    public override isReady(completeCheck = false): boolean {\r\n        return this._sourceMesh.isReady(completeCheck, true);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param kind kind of verticies to retrieve (eg. positions, normals, uvs, etc.)\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is\r\n     * @returns a float array or a Float32Array of the requested kind of data : positions, normals, uvs, etc.\r\n     */\r\n    public override getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray> {\r\n        return this._sourceMesh.getVerticesData(kind, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    public override copyVerticesData(kind: string, vertexData: { [kind: string]: Float32Array }): void {\r\n        this._sourceMesh.copyVerticesData(kind, vertexData);\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initially none) or updater.\r\n     * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\r\n     * Note that a new underlying VertexBuffer object is created each call.\r\n     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     * @param kind defines vertex data kind\r\n     * @param data defines the data source\r\n     * @param updatable defines if the data must be flagged as updatable (false as default)\r\n     * @param stride defines the vertex stride (optional)\r\n     * @returns the current mesh\r\n     */\r\n    public override setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): AbstractMesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setVerticesData(kind, data, updatable, stride);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, it is simply returned as it is.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * No new underlying VertexBuffer object is created.\r\n     * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     * @param kind defines vertex data kind\r\n     * @param data defines the data source\r\n     * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for \"position\" kind\r\n     * @param makeItUnique defines it the updated vertex buffer must be flagged as unique (false by default)\r\n     * @returns the source mesh\r\n     */\r\n    public override updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh indices.\r\n     * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\r\n     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n     * This method creates a new index buffer each call.\r\n     * Returns the Mesh.\r\n     * @param indices the source data\r\n     * @param totalVertices defines the total number of vertices referenced by indices (could be null)\r\n     * @returns source mesh\r\n     */\r\n    public override setIndices(indices: IndicesArray, totalVertices: Nullable<number> = null): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setIndices(indices, totalVertices);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Boolean : True if the mesh owns the requested kind of data.\r\n     * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @returns true if data kind is present\r\n     */\r\n    public override isVerticesDataPresent(kind: string): boolean {\r\n        return this._sourceMesh.isVerticesDataPresent(kind);\r\n    }\r\n\r\n    /**\r\n     * @returns an array of indices (IndicesArray).\r\n     */\r\n    public override getIndices(): Nullable<IndicesArray> {\r\n        return this._sourceMesh.getIndices();\r\n    }\r\n\r\n    public override get _positions(): Nullable<Vector3[]> {\r\n        return this._sourceMesh._positions;\r\n    }\r\n\r\n    public override refreshBoundingInfo(applySkeletonOrOptions: boolean | IMeshDataOptions = false, applyMorph: boolean = false): InstancedMesh {\r\n        if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {\r\n            return this;\r\n        }\r\n\r\n        let options: IMeshDataOptions;\r\n        if (typeof applySkeletonOrOptions === \"object\") {\r\n            options = applySkeletonOrOptions;\r\n        } else {\r\n            options = {\r\n                applySkeleton: applySkeletonOrOptions,\r\n                applyMorph: applyMorph,\r\n            };\r\n        }\r\n\r\n        const bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;\r\n        this._refreshBoundingInfo(this._sourceMesh._getData(options, null, VertexBuffer.PositionKind), bias);\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _preActivate(): InstancedMesh {\r\n        if (this._currentLOD) {\r\n            this._currentLOD._preActivate();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _activate(renderId: number, intermediateRendering: boolean): boolean {\r\n        super._activate(renderId, intermediateRendering);\r\n\r\n        if (!this._sourceMesh.subMeshes) {\r\n            Logger.Warn(\"Instances should only be created for meshes with geometry.\");\r\n        }\r\n\r\n        if (this._currentLOD) {\r\n            const differentSign = this._currentLOD._getWorldMatrixDeterminant() >= 0 !== this._getWorldMatrixDeterminant() >= 0;\r\n            if (differentSign) {\r\n                this._internalAbstractMeshDataInfo._actAsRegularMesh = true;\r\n                return true;\r\n            }\r\n            this._internalAbstractMeshDataInfo._actAsRegularMesh = false;\r\n\r\n            this._currentLOD._registerInstanceForRenderId(this, renderId);\r\n\r\n            if (intermediateRendering) {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;\r\n                    return true;\r\n                }\r\n            } else {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _postActivate(): void {\r\n        if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer of the source mesh\r\n            this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);\r\n            this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());\r\n        } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer defined for this instance\r\n            this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);\r\n        }\r\n    }\r\n\r\n    public override getWorldMatrix(): Matrix {\r\n        if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {\r\n            if (!this._billboardWorldMatrix) {\r\n                this._billboardWorldMatrix = new Matrix();\r\n            }\r\n            const tempMaster = this._currentLOD._masterMesh;\r\n            this._currentLOD._masterMesh = this;\r\n            TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);\r\n            this._currentLOD.position.set(0, 0, 0);\r\n            this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(true));\r\n            this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);\r\n            this._currentLOD._masterMesh = tempMaster;\r\n            return this._billboardWorldMatrix;\r\n        }\r\n\r\n        return super.getWorldMatrix();\r\n    }\r\n\r\n    public override get isAnInstance(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the current associated LOD AbstractMesh.\r\n     * @param camera defines the camera to use to pick the LOD level\r\n     * @returns a Mesh or `null` if no LOD is associated with the AbstractMesh\r\n     */\r\n    public override getLOD(camera: Camera): AbstractMesh {\r\n        if (!camera) {\r\n            return this;\r\n        }\r\n\r\n        const sourceMeshLODLevels = this.sourceMesh.getLODLevels();\r\n        if (!sourceMeshLODLevels || sourceMeshLODLevels.length === 0) {\r\n            this._currentLOD = this.sourceMesh;\r\n        } else {\r\n            const boundingInfo = this.getBoundingInfo();\r\n            this._currentLOD = <Mesh>this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);\r\n        }\r\n\r\n        return this._currentLOD;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _preActivateForIntermediateRendering(renderId: number): Mesh {\r\n        return <Mesh>this.sourceMesh._preActivateForIntermediateRendering(renderId);\r\n    }\r\n\r\n    /** @internal */\r\n    public _syncSubMeshes(): InstancedMesh {\r\n        this.releaseSubMeshes();\r\n        if (this._sourceMesh.subMeshes) {\r\n            for (let index = 0; index < this._sourceMesh.subMeshes.length; index++) {\r\n                this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _generatePointsArray(): boolean {\r\n        return this._sourceMesh._generatePointsArray();\r\n    }\r\n\r\n    /** @internal */\r\n    public override _updateBoundingInfo(): AbstractMesh {\r\n        if (this.hasBoundingInfo) {\r\n            this.getBoundingInfo().update(this.worldMatrixFromCache);\r\n        } else {\r\n            this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache);\r\n        }\r\n        this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh from the current mesh.\r\n     *\r\n     * Returns the clone.\r\n     * @param name the cloned mesh name\r\n     * @param newParent the optional Node to parent the clone to.\r\n     * @param doNotCloneChildren if `true` the model children aren't cloned.\r\n     * @param newSourceMesh if set this mesh will be used as the source mesh instead of ths instance's one\r\n     * @returns the clone\r\n     */\r\n    public override clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean, newSourceMesh?: Mesh): InstancedMesh {\r\n        const result = (newSourceMesh || this._sourceMesh).createInstance(name);\r\n\r\n        // Deep copy\r\n        DeepCopier.DeepCopy(\r\n            this,\r\n            result,\r\n            [\r\n                \"name\",\r\n                \"subMeshes\",\r\n                \"uniqueId\",\r\n                \"parent\",\r\n                \"lightSources\",\r\n                \"receiveShadows\",\r\n                \"material\",\r\n                \"visibility\",\r\n                \"skeleton\",\r\n                \"sourceMesh\",\r\n                \"isAnInstance\",\r\n                \"facetNb\",\r\n                \"isFacetDataEnabled\",\r\n                \"isBlocked\",\r\n                \"useBones\",\r\n                \"hasInstances\",\r\n                \"collider\",\r\n                \"edgesRenderer\",\r\n                \"forward\",\r\n                \"up\",\r\n                \"right\",\r\n                \"absolutePosition\",\r\n                \"absoluteScaling\",\r\n                \"absoluteRotationQuaternion\",\r\n                \"isWorldMatrixFrozen\",\r\n                \"nonUniformScaling\",\r\n                \"behaviors\",\r\n                \"worldMatrixFromCache\",\r\n                \"hasThinInstances\",\r\n                \"hasBoundingInfo\",\r\n            ],\r\n            []\r\n        );\r\n\r\n        // Bounding info\r\n        this.refreshBoundingInfo();\r\n\r\n        // Parent\r\n        if (newParent) {\r\n            result.parent = newParent;\r\n        }\r\n\r\n        if (!doNotCloneChildren) {\r\n            // Children\r\n            for (let index = 0; index < this.getScene().meshes.length; index++) {\r\n                const mesh = this.getScene().meshes[index];\r\n\r\n                if (mesh.parent === this) {\r\n                    mesh.clone(mesh.name, result);\r\n                }\r\n            }\r\n        }\r\n\r\n        result.computeWorldMatrix(true);\r\n\r\n        this.onClonedObservable.notifyObservers(result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the InstancedMesh.\r\n     * Returns nothing.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public override dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        // Remove from mesh\r\n        this._sourceMesh.removeInstance(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _serializeAsParent(serializationObject: any) {\r\n        super._serializeAsParent(serializationObject);\r\n\r\n        serializationObject.parentId = this._sourceMesh.uniqueId;\r\n        serializationObject.parentInstanceIndex = this._indexInSourceMeshInstanceArray;\r\n    }\r\n\r\n    /**\r\n     * Instantiate (when possible) or clone that node with its hierarchy\r\n     * @param newParent defines the new parent to use for the instance (or clone)\r\n     * @param options defines options to configure how copy is done\r\n     * @param options.doNotInstantiate defines if the model must be instantiated or just cloned\r\n     * @param options.newSourcedMesh newSourcedMesh the new source mesh for the instance (or clone)\r\n     * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created\r\n     * @returns an instance (or a clone) of the current node with its hierarchy\r\n     */\r\n    public override instantiateHierarchy(\r\n        newParent: Nullable<TransformNode> = null,\r\n        options?: { doNotInstantiate: boolean | ((node: TransformNode) => boolean); newSourcedMesh?: Mesh },\r\n        onNewNodeCreated?: (source: TransformNode, clone: TransformNode) => void\r\n    ): Nullable<TransformNode> {\r\n        const clone = this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true, options && options.newSourcedMesh);\r\n\r\n        if (clone) {\r\n            if (onNewNodeCreated) {\r\n                onNewNodeCreated(this, clone);\r\n            }\r\n        }\r\n\r\n        for (const child of this.getChildTransformNodes(true)) {\r\n            child.instantiateHierarchy(clone, options, onNewNodeCreated);\r\n        }\r\n\r\n        return clone;\r\n    }\r\n}\r\n\r\ndeclare module \"./mesh\" {\r\n    export interface Mesh {\r\n        /**\r\n         * Register a custom buffer that will be instanced\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances#custom-buffers\r\n         * @param kind defines the buffer kind\r\n         * @param stride defines the stride in floats\r\n         */\r\n        registerInstancedBuffer(kind: string, stride: number): void;\r\n\r\n        /**\r\n         * Invalidate VertexArrayObjects belonging to the mesh (but not to the Geometry of the mesh).\r\n         */\r\n        _invalidateInstanceVertexArrayObject(): void;\r\n\r\n        /**\r\n         * true to use the edge renderer for all instances of this mesh\r\n         */\r\n        edgesShareWithInstances: boolean;\r\n\r\n        /** @internal */\r\n        _userInstancedBuffersStorage: {\r\n            data: { [key: string]: Float32Array };\r\n            sizes: { [key: string]: number };\r\n            vertexBuffers: { [key: string]: Nullable<VertexBuffer> };\r\n            strides: { [key: string]: number };\r\n            vertexArrayObjects?: { [key: string]: WebGLVertexArrayObject };\r\n        };\r\n    }\r\n}\r\n\r\ndeclare module \"./abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /**\r\n         * Object used to store instanced buffers defined by user\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances#custom-buffers\r\n         */\r\n        instancedBuffers: { [key: string]: any };\r\n    }\r\n}\r\n\r\nMesh.prototype.registerInstancedBuffer = function (kind: string, stride: number): void {\r\n    // Remove existing one\r\n    this._userInstancedBuffersStorage?.vertexBuffers[kind]?.dispose();\r\n\r\n    // Creates the instancedBuffer field if not present\r\n    if (!this.instancedBuffers) {\r\n        this.instancedBuffers = {};\r\n\r\n        for (const instance of this.instances) {\r\n            instance.instancedBuffers = {};\r\n        }\r\n    }\r\n\r\n    if (!this._userInstancedBuffersStorage) {\r\n        this._userInstancedBuffersStorage = {\r\n            data: {},\r\n            vertexBuffers: {},\r\n            strides: {},\r\n            sizes: {},\r\n            vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : undefined,\r\n        };\r\n    }\r\n\r\n    // Creates an empty property for this kind\r\n    this.instancedBuffers[kind] = null;\r\n\r\n    this._userInstancedBuffersStorage.strides[kind] = stride;\r\n    this._userInstancedBuffersStorage.sizes[kind] = stride * 32; // Initial size\r\n    this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);\r\n    this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\r\n\r\n    for (const instance of this.instances) {\r\n        instance.instancedBuffers[kind] = null;\r\n    }\r\n\r\n    this._invalidateInstanceVertexArrayObject();\r\n\r\n    this._markSubMeshesAsAttributesDirty();\r\n};\r\n\r\nMesh.prototype._processInstancedBuffers = function (visibleInstances: Nullable<InstancedMesh[]>, renderSelf: boolean) {\r\n    const instanceCount = visibleInstances ? visibleInstances.length : 0;\r\n\r\n    for (const kind in this.instancedBuffers) {\r\n        let size = this._userInstancedBuffersStorage.sizes[kind];\r\n        const stride = this._userInstancedBuffersStorage.strides[kind];\r\n\r\n        // Resize if required\r\n        const expectedSize = (instanceCount + 1) * stride;\r\n\r\n        while (size < expectedSize) {\r\n            size *= 2;\r\n        }\r\n\r\n        if (this._userInstancedBuffersStorage.data[kind].length != size) {\r\n            this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);\r\n            this._userInstancedBuffersStorage.sizes[kind] = size;\r\n            if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\r\n            }\r\n        }\r\n\r\n        const data = this._userInstancedBuffersStorage.data[kind];\r\n\r\n        // Update data buffer\r\n        let offset = 0;\r\n        if (renderSelf) {\r\n            const value = this.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else if (value.copyToArray) {\r\n                value.copyToArray(data, offset);\r\n            } else {\r\n                data[offset] = value;\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        for (let instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {\r\n            const instance = visibleInstances![instanceIndex]!;\r\n\r\n            const value = instance.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else if (value.copyToArray) {\r\n                value.copyToArray(data, offset);\r\n            } else {\r\n                data[offset] = value;\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        // Update vertex buffer\r\n        if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(\r\n                this.getEngine(),\r\n                this._userInstancedBuffersStorage.data[kind],\r\n                kind,\r\n                true,\r\n                false,\r\n                stride,\r\n                true\r\n            );\r\n            this._invalidateInstanceVertexArrayObject();\r\n        } else {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.updateDirectly(data, 0);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype._invalidateInstanceVertexArrayObject = function () {\r\n    if (!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === undefined) {\r\n        return;\r\n    }\r\n\r\n    for (const kind in this._userInstancedBuffersStorage.vertexArrayObjects) {\r\n        (this.getEngine() as ThinEngine).releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[kind]);\r\n    }\r\n\r\n    this._userInstancedBuffersStorage.vertexArrayObjects = {};\r\n};\r\n\r\nMesh.prototype._disposeInstanceSpecificData = function () {\r\n    if (this._instanceDataStorage.instancesBuffer) {\r\n        this._instanceDataStorage.instancesBuffer.dispose();\r\n        this._instanceDataStorage.instancesBuffer = null;\r\n    }\r\n\r\n    while (this.instances.length) {\r\n        this.instances[0].dispose();\r\n    }\r\n\r\n    for (const kind in this.instancedBuffers) {\r\n        if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n        }\r\n    }\r\n\r\n    this._invalidateInstanceVertexArrayObject();\r\n\r\n    this.instancedBuffers = {};\r\n};\r\n\r\n// Register Class Name\r\nRegisterClass(\"BABYLON.InstancedMesh\", InstancedMesh);\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport type { Node } from \"../node\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { InstancedMesh } from \"../Meshes/instancedMesh\";\r\nimport { Material } from \"../Materials/material\";\r\nimport type { IShaderMaterialOptions } from \"../Materials/shaderMaterial\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\nMesh._LinesMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return LinesMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Line mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n */\r\nexport class LinesMesh extends Mesh {\r\n    /**\r\n     * Force all the LineMeshes to compile their default color material to glsl even on WebGPU engines.\r\n     * False by default. This is mostly meant for backward compatibility.\r\n     */\r\n    public static ForceGLSL = false;\r\n\r\n    /**\r\n     * Color of the line (Default: White)\r\n     */\r\n    public color = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * Alpha of the line (Default: 1)\r\n     */\r\n    public alpha = 1;\r\n\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Default value is 0.1\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    private _lineMaterial: Material;\r\n\r\n    private _isShaderMaterial(shader: Material): shader is ShaderMaterial {\r\n        return shader.getClassName() === \"ShaderMaterial\";\r\n    }\r\n\r\n    private _color4: Color4;\r\n\r\n    /** Shader language used by the material */\r\n    protected _shaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    /**\r\n     * Creates a new LinesMesh\r\n     * @param name defines the name\r\n     * @param scene defines the hosting scene\r\n     * @param parent defines the parent mesh if any\r\n     * @param source defines the optional source LinesMesh used to clone data from\r\n     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\r\n     * When false, achieved by calling a clone(), also passing False.\r\n     * This will make creation of children, recursive.\r\n     * @param useVertexColor defines if this LinesMesh supports vertex color\r\n     * @param useVertexAlpha defines if this LinesMesh supports vertex alpha\r\n     * @param material material to use to draw the line. If not provided, will create a new one\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Nullable<Scene> = null,\r\n        parent: Nullable<Node> = null,\r\n        source: Nullable<LinesMesh> = null,\r\n        doNotCloneChildren?: boolean,\r\n        /**\r\n         * If vertex color should be applied to the mesh\r\n         */\r\n        public readonly useVertexColor?: boolean,\r\n        /**\r\n         * If vertex alpha should be applied to the mesh\r\n         */\r\n        public readonly useVertexAlpha?: boolean,\r\n        material?: Material\r\n    ) {\r\n        super(name, scene, parent, source, doNotCloneChildren);\r\n\r\n        if (source) {\r\n            this.color = source.color.clone();\r\n            this.alpha = source.alpha;\r\n            this.useVertexColor = source.useVertexColor;\r\n            this.useVertexAlpha = source.useVertexAlpha;\r\n        }\r\n\r\n        this.intersectionThreshold = 0.1;\r\n\r\n        const defines: string[] = [];\r\n        const options: Partial<IShaderMaterialOptions> = {\r\n            attributes: [VertexBuffer.PositionKind],\r\n            uniforms: [\"world\", \"viewProjection\"],\r\n            needAlphaBlending: true,\r\n            defines: defines,\r\n            useClipPlane: null,\r\n            shaderLanguage: ShaderLanguage.GLSL,\r\n        };\r\n\r\n        if (!this.useVertexAlpha) {\r\n            options.needAlphaBlending = false;\r\n        } else {\r\n            options.defines!.push(\"#define VERTEXALPHA\");\r\n        }\r\n\r\n        if (!this.useVertexColor) {\r\n            options.uniforms!.push(\"color\");\r\n            this._color4 = new Color4();\r\n        } else {\r\n            options.defines!.push(\"#define VERTEXCOLOR\");\r\n            options.attributes!.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        if (material) {\r\n            this.material = material;\r\n        } else {\r\n            const engine = this.getScene().getEngine();\r\n\r\n            if (engine.isWebGPU && !LinesMesh.ForceGLSL) {\r\n                this._shaderLanguage = ShaderLanguage.WGSL;\r\n            }\r\n\r\n            options.shaderLanguage = this._shaderLanguage;\r\n            options.extraInitializationsAsync = async () => {\r\n                if (this._shaderLanguage === ShaderLanguage.WGSL) {\r\n                    await Promise.all([import(\"../ShadersWGSL/color.vertex\"), import(\"../ShadersWGSL/color.fragment\")]);\r\n                } else {\r\n                    await Promise.all([import(\"../Shaders/color.vertex\"), import(\"../Shaders/color.fragment\")]);\r\n                }\r\n            };\r\n\r\n            this.material = new ShaderMaterial(\"colorShader\", this.getScene(), \"color\", options, false);\r\n            this.material.doNotSerialize = true;\r\n        }\r\n    }\r\n\r\n    public override isReady() {\r\n        if (!this._lineMaterial.isReady(this, !!this._userInstancedBuffersStorage || this.hasThinInstances)) {\r\n            return false;\r\n        }\r\n\r\n        return super.isReady();\r\n    }\r\n\r\n    /**\r\n     * @returns the string \"LineMesh\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"LinesMesh\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override get material(): Material {\r\n        return this._lineMaterial;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override set material(value: Material) {\r\n        this._lineMaterial = value;\r\n        this._lineMaterial.fillMode = Material.LineListDrawMode;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override get checkCollisions(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public override set checkCollisions(value: boolean) {\r\n        // Just ignore it\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _bind(_subMesh: SubMesh, colorEffect: Effect): Mesh {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n\r\n        // VBOs\r\n        const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();\r\n        if (!this._userInstancedBuffersStorage || this.hasThinInstances) {\r\n            this._geometry._bind(colorEffect, indexToBind);\r\n        } else {\r\n            this._geometry._bind(colorEffect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);\r\n        }\r\n\r\n        // Color\r\n        if (!this.useVertexColor && this._isShaderMaterial(this._lineMaterial)) {\r\n            const { r, g, b } = this.color;\r\n            this._color4.set(r, g, b, this.alpha);\r\n            this._lineMaterial.setColor4(\"color\", this._color4);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _draw(subMesh: SubMesh, fillMode: number, instancesCount?: number): Mesh {\r\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\r\n            return this;\r\n        }\r\n\r\n        const engine = this.getScene().getEngine();\r\n\r\n        // Draw order\r\n\r\n        if (this._unIndexed) {\r\n            engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\r\n        } else {\r\n            engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the line mesh\r\n     * @param doNotRecurse If children should be disposed\r\n     * @param disposeMaterialAndTextures This parameter is not used by the LineMesh class\r\n     * @param doNotDisposeMaterial If the material should not be disposed (default: false, meaning the material is disposed)\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public override dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false, doNotDisposeMaterial?: boolean): void {\r\n        if (!doNotDisposeMaterial) {\r\n            this._lineMaterial.dispose(false, false, true);\r\n        }\r\n        super.dispose(doNotRecurse);\r\n    }\r\n\r\n    /**\r\n     * Returns a new LineMesh object cloned from the current one.\r\n     * @param name defines the cloned mesh name\r\n     * @param newParent defines the new mesh parent\r\n     * @param doNotCloneChildren if set to true, none of the mesh children are cloned (false by default)\r\n     * @returns the new mesh\r\n     */\r\n    public override clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean): LinesMesh {\r\n        return new LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedLinesMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedLinesMesh\r\n     */\r\n    public override createInstance(name: string): InstancedLinesMesh {\r\n        const instance = new InstancedLinesMesh(name, this);\r\n\r\n        if (this.instancedBuffers) {\r\n            instance.instancedBuffers = {};\r\n\r\n            for (const key in this.instancedBuffers) {\r\n                instance.instancedBuffers[key] = this.instancedBuffers[key];\r\n            }\r\n        }\r\n\r\n        return instance;\r\n    }\r\n\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public override serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.color = this.color.asArray();\r\n        serializationObject.alpha = this.alpha;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    public static override Parse(parsedMesh: any, scene: Scene): LinesMesh {\r\n        const result = new LinesMesh(parsedMesh.name, scene);\r\n\r\n        result.color = Color3.FromArray(parsedMesh.color);\r\n        result.alpha = parsedMesh.alpha;\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates an instance based on a source LinesMesh\r\n */\r\nexport class InstancedLinesMesh extends InstancedMesh {\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Initialized with the intersectionThreshold value of the source LinesMesh\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    constructor(name: string, source: LinesMesh) {\r\n        super(name, source);\r\n        this.intersectionThreshold = source.intersectionThreshold;\r\n    }\r\n\r\n    /**\r\n     * @returns the string \"InstancedLinesMesh\".\r\n     */\r\n    public override getClassName(): string {\r\n        return \"InstancedLinesMesh\";\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport { _CreationDataStorage, Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { FloatArray, Nullable } from \"../../types\";\r\nimport { LinesMesh } from \"../../Meshes/linesMesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { Logger } from \"../../Misc/logger\";\r\n\r\nimport type { Material } from \"../../Materials/material\";\r\n\r\n/**\r\n * Creates the VertexData of the LineSystem\r\n * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\r\n *  - lines an array of lines, each line being an array of successive Vector3\r\n *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\r\n * @returns the VertexData of the LineSystem\r\n */\r\nexport function CreateLineSystemVertexData(options: { lines: Vector3[][]; colors?: Nullable<Color4[][]> }): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const lines = options.lines;\r\n    const colors = options.colors;\r\n    const vertexColors = [];\r\n    let idx = 0;\r\n\r\n    for (let l = 0; l < lines.length; l++) {\r\n        const points = lines[l];\r\n        for (let index = 0; index < points.length; index++) {\r\n            const { x, y, z } = points[index];\r\n            positions.push(x, y, z);\r\n            if (colors) {\r\n                const color = colors[l];\r\n                const { r, g, b, a } = color[index];\r\n                vertexColors.push(r, g, b, a);\r\n            }\r\n            if (index > 0) {\r\n                indices.push(idx - 1);\r\n                indices.push(idx);\r\n            }\r\n            idx++;\r\n        }\r\n    }\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    if (colors) {\r\n        vertexData.colors = vertexColors;\r\n    }\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Create the VertexData for a DashedLines\r\n * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\r\n *  - points an array successive Vector3\r\n *  - dashSize the size of the dashes relative to the dash number, optional, default 3\r\n *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\r\n *  - dashNb the intended total number of dashes, optional, default 200\r\n * @returns the VertexData for the DashedLines\r\n */\r\nexport function CreateDashedLinesVertexData(options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number }): VertexData {\r\n    const dashSize = options.dashSize || 3;\r\n    const gapSize = options.gapSize || 1;\r\n    const dashNb = options.dashNb || 200;\r\n    const points = options.points;\r\n\r\n    const positions: number[] = [];\r\n    const indices: number[] = [];\r\n\r\n    const curvect = Vector3.Zero();\r\n    let lg = 0;\r\n    let nb = 0;\r\n    let shft = 0;\r\n    let dashshft = 0;\r\n    let curshft = 0;\r\n    let idx = 0;\r\n    let i = 0;\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        lg += curvect.length();\r\n    }\r\n    shft = lg / dashNb;\r\n    dashshft = (dashSize * shft) / (dashSize + gapSize);\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        nb = Math.floor(curvect.length() / shft);\r\n        curvect.normalize();\r\n        for (let j = 0; j < nb; j++) {\r\n            curshft = shft * j;\r\n            positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);\r\n            positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);\r\n            indices.push(idx, idx + 1);\r\n            idx += 2;\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    vertexData.positions = positions;\r\n    vertexData.indices = indices;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\r\n * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\r\n * * The parameter `lines` is an array of lines, each line being an array of successive Vector3\r\n * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\r\n * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#line-system\r\n * @param name defines the name of the new line system\r\n * @param options defines the options used to create the line system\r\n * @param scene defines the hosting scene\r\n * @returns a new line system mesh\r\n */\r\nexport function CreateLineSystem(\r\n    name: string,\r\n    options: { lines: Vector3[][]; updatable?: boolean; instance?: Nullable<LinesMesh>; colors?: Nullable<Color4[][]>; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const instance = options.instance;\r\n    const lines = options.lines;\r\n    const colors = options.colors;\r\n\r\n    if (instance) {\r\n        // lines update\r\n        const positions = instance.getVerticesData(VertexBuffer.PositionKind)!;\r\n        let vertexColor;\r\n        let lineColors;\r\n        if (colors) {\r\n            vertexColor = instance.getVerticesData(VertexBuffer.ColorKind)!;\r\n        }\r\n        let i = 0;\r\n        let c = 0;\r\n        for (let l = 0; l < lines.length; l++) {\r\n            const points = lines[l];\r\n            for (let p = 0; p < points.length; p++) {\r\n                positions[i] = points[p].x;\r\n                positions[i + 1] = points[p].y;\r\n                positions[i + 2] = points[p].z;\r\n                if (colors && vertexColor) {\r\n                    lineColors = colors[l];\r\n                    vertexColor[c] = lineColors[p].r;\r\n                    vertexColor[c + 1] = lineColors[p].g;\r\n                    vertexColor[c + 2] = lineColors[p].b;\r\n                    vertexColor[c + 3] = lineColors[p].a;\r\n                    c += 4;\r\n                }\r\n                i += 3;\r\n            }\r\n        }\r\n        instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n        if (colors && vertexColor) {\r\n            instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);\r\n        }\r\n        instance.refreshBoundingInfo();\r\n        return instance;\r\n    }\r\n\r\n    // line system creation\r\n    const useVertexColor = colors ? true : false;\r\n    const lineSystem = new LinesMesh(name, scene, null, undefined, undefined, useVertexColor, options.useVertexAlpha, options.material);\r\n    const vertexData = CreateLineSystemVertexData(options);\r\n    vertexData.applyToMesh(lineSystem, options.updatable);\r\n    return lineSystem;\r\n}\r\n\r\n/**\r\n * Creates a line mesh\r\n * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n * * The parameter `points` is an array successive Vector3\r\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * The optional parameter `colors` is an array of successive Color4, one per line point\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * When updating an instance, remember that only point positions can change, not the number of points\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#lines\r\n * @param name defines the name of the new line system\r\n * @param options defines the options used to create the line system\r\n * @param scene defines the hosting scene\r\n * @returns a new line mesh\r\n */\r\nexport function CreateLines(\r\n    name: string,\r\n    options: { points: Vector3[]; updatable?: boolean; instance?: Nullable<LinesMesh>; colors?: Color4[]; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const colors = options.colors ? [options.colors] : null;\r\n    const lines = CreateLineSystem(\r\n        name,\r\n        { lines: [options.points], updatable: options.updatable, instance: options.instance, colors: colors, useVertexAlpha: options.useVertexAlpha, material: options.material },\r\n        scene\r\n    );\r\n    return lines;\r\n}\r\n\r\n/**\r\n * Creates a dashed line mesh\r\n * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n * * The parameter `points` is an array successive Vector3\r\n * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\r\n * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\r\n * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\r\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * When updating an instance, remember that only point positions can change, not the number of points\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the dashed line mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#dashed-lines\r\n */\r\nexport function CreateDashedLines(\r\n    name: string,\r\n    options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number; updatable?: boolean; instance?: LinesMesh; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const points = options.points;\r\n    const instance = options.instance;\r\n    const gapSize = options.gapSize || 1;\r\n    const dashSize = options.dashSize || 3;\r\n\r\n    if (instance) {\r\n        //  dashed lines update\r\n        const positionFunction = (positions: FloatArray): void => {\r\n            const curvect = Vector3.Zero();\r\n            const nbSeg = positions.length / 6;\r\n            let lg = 0;\r\n            let nb = 0;\r\n            let shft = 0;\r\n            let dashshft = 0;\r\n            let curshft = 0;\r\n            let p = 0;\r\n            let i = 0;\r\n            let j = 0;\r\n            for (i = 0; i < points.length - 1; i++) {\r\n                points[i + 1].subtractToRef(points[i], curvect);\r\n                lg += curvect.length();\r\n            }\r\n            shft = lg / nbSeg;\r\n            const dashSize = instance!._creationDataStorage!.dashSize;\r\n            const gapSize = instance!._creationDataStorage!.gapSize;\r\n            dashshft = (dashSize * shft) / (dashSize + gapSize);\r\n            for (i = 0; i < points.length - 1; i++) {\r\n                points[i + 1].subtractToRef(points[i], curvect);\r\n                nb = Math.floor(curvect.length() / shft);\r\n                curvect.normalize();\r\n                j = 0;\r\n                while (j < nb && p < positions.length) {\r\n                    curshft = shft * j;\r\n                    positions[p] = points[i].x + curshft * curvect.x;\r\n                    positions[p + 1] = points[i].y + curshft * curvect.y;\r\n                    positions[p + 2] = points[i].z + curshft * curvect.z;\r\n                    positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;\r\n                    positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;\r\n                    positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;\r\n                    p += 6;\r\n                    j++;\r\n                }\r\n            }\r\n            while (p < positions.length) {\r\n                positions[p] = points[i].x;\r\n                positions[p + 1] = points[i].y;\r\n                positions[p + 2] = points[i].z;\r\n                p += 3;\r\n            }\r\n        };\r\n        if (options.dashNb || options.dashSize || options.gapSize || options.useVertexAlpha || options.material) {\r\n            Logger.Warn(\"You have used an option other than points with the instance option. Please be aware that these other options will be ignored.\");\r\n        }\r\n        instance.updateMeshPositions(positionFunction, false);\r\n        return instance;\r\n    }\r\n    // dashed lines creation\r\n    const dashedLines = new LinesMesh(name, scene, null, undefined, undefined, undefined, options.useVertexAlpha, options.material);\r\n    const vertexData = CreateDashedLinesVertexData(options);\r\n    vertexData.applyToMesh(dashedLines, options.updatable);\r\n\r\n    dashedLines._creationDataStorage = new _CreationDataStorage();\r\n    dashedLines._creationDataStorage.dashSize = dashSize;\r\n    dashedLines._creationDataStorage.gapSize = gapSize;\r\n    return dashedLines;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the functions directly from the module\r\n */\r\nexport const LinesBuilder = {\r\n    CreateDashedLines,\r\n    CreateLineSystem,\r\n    CreateLines,\r\n};\r\n\r\nVertexData.CreateLineSystem = CreateLineSystemVertexData;\r\nVertexData.CreateDashedLines = CreateDashedLinesVertexData;\r\n\r\nMesh.CreateLines = (name: string, points: Vector3[], scene: Nullable<Scene> = null, updatable: boolean = false, instance: Nullable<LinesMesh> = null): LinesMesh => {\r\n    const options = {\r\n        points,\r\n        updatable,\r\n        instance,\r\n    };\r\n    return CreateLines(name, options, scene);\r\n};\r\n\r\nMesh.CreateDashedLines = (\r\n    name: string,\r\n    points: Vector3[],\r\n    dashSize: number,\r\n    gapSize: number,\r\n    dashNb: number,\r\n    scene: Nullable<Scene> = null,\r\n    updatable?: boolean,\r\n    instance?: LinesMesh\r\n): LinesMesh => {\r\n    const options = {\r\n        points,\r\n        dashSize,\r\n        gapSize,\r\n        dashNb,\r\n        updatable,\r\n        instance,\r\n    };\r\n    return CreateDashedLines(name, options, scene);\r\n};\r\n", "import { Logger } from \"../Misc/logger\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Path2 } from \"../Maths/math.path\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\ndeclare let earcut: any;\r\n/**\r\n * Vector2 wth index property\r\n */\r\nclass IndexedVector2 extends Vector2 {\r\n    constructor(\r\n        original: Vector2,\r\n        /** Index of the vector2 */\r\n        public index: number\r\n    ) {\r\n        super(original.x, original.y);\r\n    }\r\n}\r\n\r\n/**\r\n * Defines points to create a polygon\r\n */\r\nclass PolygonPoints {\r\n    elements = [] as IndexedVector2[];\r\n\r\n    add(originalPoints: Array<Vector2>): Array<IndexedVector2> {\r\n        const result: IndexedVector2[] = [];\r\n        originalPoints.forEach((point) => {\r\n            const newPoint = new IndexedVector2(point, this.elements.length);\r\n            result.push(newPoint);\r\n            this.elements.push(newPoint);\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    computeBounds(): { min: Vector2; max: Vector2; width: number; height: number } {\r\n        const lmin = new Vector2(this.elements[0].x, this.elements[0].y);\r\n        const lmax = new Vector2(this.elements[0].x, this.elements[0].y);\r\n\r\n        this.elements.forEach((point) => {\r\n            // x\r\n            if (point.x < lmin.x) {\r\n                lmin.x = point.x;\r\n            } else if (point.x > lmax.x) {\r\n                lmax.x = point.x;\r\n            }\r\n\r\n            // y\r\n            if (point.y < lmin.y) {\r\n                lmin.y = point.y;\r\n            } else if (point.y > lmax.y) {\r\n                lmax.y = point.y;\r\n            }\r\n        });\r\n\r\n        return {\r\n            min: lmin,\r\n            max: lmax,\r\n            width: lmax.x - lmin.x,\r\n            height: lmax.y - lmin.y,\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Polygon\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#non-regular-polygon\r\n */\r\nexport class Polygon {\r\n    /**\r\n     * Creates a rectangle\r\n     * @param xmin bottom X coord\r\n     * @param ymin bottom Y coord\r\n     * @param xmax top X coord\r\n     * @param ymax top Y coord\r\n     * @returns points that make the resulting rectangle\r\n     */\r\n    static Rectangle(xmin: number, ymin: number, xmax: number, ymax: number): Vector2[] {\r\n        return [new Vector2(xmin, ymin), new Vector2(xmax, ymin), new Vector2(xmax, ymax), new Vector2(xmin, ymax)];\r\n    }\r\n\r\n    /**\r\n     * Creates a circle\r\n     * @param radius radius of circle\r\n     * @param cx scale in x\r\n     * @param cy scale in y\r\n     * @param numberOfSides number of sides that make up the circle\r\n     * @returns points that make the resulting circle\r\n     */\r\n    static Circle(radius: number, cx: number = 0, cy: number = 0, numberOfSides: number = 32): Vector2[] {\r\n        const result: Vector2[] = [];\r\n\r\n        let angle = 0;\r\n        const increment = (Math.PI * 2) / numberOfSides;\r\n\r\n        for (let i = 0; i < numberOfSides; i++) {\r\n            result.push(new Vector2(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius));\r\n            angle -= increment;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a polygon from input string\r\n     * @param input Input polygon data\r\n     * @returns the parsed points\r\n     */\r\n    static Parse(input: string): Vector2[] {\r\n        const floats = input\r\n            .split(/[^-+eE.\\d]+/)\r\n            .map(parseFloat)\r\n            .filter((val) => !isNaN(val));\r\n        let i: number;\r\n        const result = [];\r\n        for (i = 0; i < (floats.length & 0x7ffffffe); i += 2) {\r\n            result.push(new Vector2(floats[i], floats[i + 1]));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Starts building a polygon from x and y coordinates\r\n     * @param x x coordinate\r\n     * @param y y coordinate\r\n     * @returns the started path2\r\n     */\r\n    static StartingAt(x: number, y: number): Path2 {\r\n        return Path2.StartingAt(x, y);\r\n    }\r\n}\r\n\r\n/**\r\n * Builds a polygon\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/polyMeshBuilder\r\n */\r\nexport class PolygonMeshBuilder {\r\n    private _points = new PolygonPoints();\r\n    private _outlinepoints = new PolygonPoints();\r\n    private _holes = new Array<PolygonPoints>();\r\n\r\n    private _name: string;\r\n    private _scene: Nullable<Scene>;\r\n\r\n    private _epoints: number[] = new Array<number>();\r\n    private _eholes: number[] = new Array<number>();\r\n\r\n    private _addToepoint(points: Vector2[]) {\r\n        for (const p of points) {\r\n            this._epoints.push(p.x, p.y);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Babylon reference to the earcut plugin.\r\n     */\r\n    public bjsEarcut: any;\r\n\r\n    /**\r\n     * Creates a PolygonMeshBuilder\r\n     * @param name name of the builder\r\n     * @param contours Path of the polygon\r\n     * @param scene scene to add to when creating the mesh\r\n     * @param earcutInjection can be used to inject your own earcut reference\r\n     */\r\n    constructor(name: string, contours: Path2 | Vector2[] | any, scene?: Scene, earcutInjection = earcut) {\r\n        this.bjsEarcut = earcutInjection;\r\n        this._name = name;\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n\r\n        let points: Vector2[];\r\n        if (contours instanceof Path2) {\r\n            points = (<Path2>contours).getPoints();\r\n        } else {\r\n            points = <Vector2[]>contours;\r\n        }\r\n\r\n        this._addToepoint(points);\r\n\r\n        this._points.add(points);\r\n        this._outlinepoints.add(points);\r\n\r\n        if (typeof this.bjsEarcut === \"undefined\") {\r\n            Logger.Warn(\"Earcut was not found, the polygon will not be built.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a hole within the polygon\r\n     * @param hole Array of points defining the hole\r\n     * @returns this\r\n     */\r\n    addHole(hole: Vector2[]): PolygonMeshBuilder {\r\n        this._points.add(hole);\r\n        const holepoints = new PolygonPoints();\r\n        holepoints.add(hole);\r\n        this._holes.push(holepoints);\r\n\r\n        this._eholes.push(this._epoints.length / 2);\r\n        this._addToepoint(hole);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates the polygon\r\n     * @param updatable If the mesh should be updatable\r\n     * @param depth The depth of the mesh created\r\n     * @param smoothingThreshold Dot product threshold for smoothed normals\r\n     * @returns the created mesh\r\n     */\r\n    build(updatable: boolean = false, depth: number = 0, smoothingThreshold: number = 2): Mesh {\r\n        const result = new Mesh(this._name, this._scene);\r\n\r\n        const vertexData = this.buildVertexData(depth, smoothingThreshold);\r\n\r\n        result.setVerticesData(VertexBuffer.PositionKind, <number[]>vertexData.positions, updatable);\r\n        result.setVerticesData(VertexBuffer.NormalKind, <number[]>vertexData.normals, updatable);\r\n        result.setVerticesData(VertexBuffer.UVKind, <number[]>vertexData.uvs, updatable);\r\n        result.setIndices(<number[]>vertexData.indices);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates the polygon\r\n     * @param depth The depth of the mesh created\r\n     * @param smoothingThreshold Dot product threshold for smoothed normals\r\n     * @returns the created VertexData\r\n     */\r\n    buildVertexData(depth: number = 0, smoothingThreshold: number = 2): VertexData {\r\n        const result = new VertexData();\r\n\r\n        const normals: number[] = [];\r\n        const positions: number[] = [];\r\n        const uvs: number[] = [];\r\n\r\n        const bounds = this._points.computeBounds();\r\n        this._points.elements.forEach((p) => {\r\n            normals.push(0, 1.0, 0);\r\n            positions.push(p.x, 0, p.y);\r\n            uvs.push((p.x - bounds.min.x) / bounds.width, (p.y - bounds.min.y) / bounds.height);\r\n        });\r\n\r\n        const indices: number[] = [];\r\n\r\n        const res = this.bjsEarcut(this._epoints, this._eholes, 2);\r\n\r\n        for (let i = 0; i < res.length; i++) {\r\n            indices.push(res[i]);\r\n        }\r\n\r\n        if (depth > 0) {\r\n            const positionscount = positions.length / 3; //get the current pointcount\r\n\r\n            this._points.elements.forEach((p) => {\r\n                //add the elements at the depth\r\n                normals.push(0, -1.0, 0);\r\n                positions.push(p.x, -depth, p.y);\r\n                uvs.push(1 - (p.x - bounds.min.x) / bounds.width, 1 - (p.y - bounds.min.y) / bounds.height);\r\n            });\r\n\r\n            const totalCount = indices.length;\r\n            for (let i = 0; i < totalCount; i += 3) {\r\n                const i0 = indices[i + 0];\r\n                const i1 = indices[i + 1];\r\n                const i2 = indices[i + 2];\r\n\r\n                indices.push(i2 + positionscount);\r\n                indices.push(i1 + positionscount);\r\n                indices.push(i0 + positionscount);\r\n            }\r\n\r\n            //Add the sides\r\n            this._addSide(positions, normals, uvs, indices, bounds, this._outlinepoints, depth, false, smoothingThreshold);\r\n\r\n            this._holes.forEach((hole) => {\r\n                this._addSide(positions, normals, uvs, indices, bounds, hole, depth, true, smoothingThreshold);\r\n            });\r\n        }\r\n\r\n        result.indices = indices;\r\n        result.positions = positions;\r\n        result.normals = normals;\r\n        result.uvs = uvs;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Adds a side to the polygon\r\n     * @param positions points that make the polygon\r\n     * @param normals normals of the polygon\r\n     * @param uvs uvs of the polygon\r\n     * @param indices indices of the polygon\r\n     * @param bounds bounds of the polygon\r\n     * @param points points of the polygon\r\n     * @param depth depth of the polygon\r\n     * @param flip flip of the polygon\r\n     * @param smoothingThreshold\r\n     */\r\n    private _addSide(positions: any[], normals: any[], uvs: any[], indices: any[], bounds: any, points: PolygonPoints, depth: number, flip: boolean, smoothingThreshold: number) {\r\n        let startIndex: number = positions.length / 3;\r\n        let ulength: number = 0;\r\n        for (let i: number = 0; i < points.elements.length; i++) {\r\n            const p: IndexedVector2 = points.elements[i];\r\n            const p1: IndexedVector2 = points.elements[(i + 1) % points.elements.length];\r\n\r\n            positions.push(p.x, 0, p.y);\r\n            positions.push(p.x, -depth, p.y);\r\n            positions.push(p1.x, 0, p1.y);\r\n            positions.push(p1.x, -depth, p1.y);\r\n\r\n            const p0: IndexedVector2 = points.elements[(i + points.elements.length - 1) % points.elements.length];\r\n            const p2: IndexedVector2 = points.elements[(i + 2) % points.elements.length];\r\n\r\n            let vc = new Vector3(-(p1.y - p.y), 0, p1.x - p.x);\r\n            let vp = new Vector3(-(p.y - p0.y), 0, p.x - p0.x);\r\n            let vn = new Vector3(-(p2.y - p1.y), 0, p2.x - p1.x);\r\n\r\n            if (!flip) {\r\n                vc = vc.scale(-1);\r\n                vp = vp.scale(-1);\r\n                vn = vn.scale(-1);\r\n            }\r\n\r\n            const vc_norm = vc.normalizeToNew();\r\n            let vp_norm = vp.normalizeToNew();\r\n            let vn_norm = vn.normalizeToNew();\r\n\r\n            const dotp = Vector3.Dot(vp_norm, vc_norm);\r\n            if (dotp > smoothingThreshold) {\r\n                if (dotp < Epsilon - 1) {\r\n                    vp_norm = new Vector3(p.x, 0, p.y).subtract(new Vector3(p1.x, 0, p1.y)).normalize();\r\n                } else {\r\n                    // cheap average weighed by side length\r\n                    vp_norm = vp.add(vc).normalize();\r\n                }\r\n            } else {\r\n                vp_norm = vc_norm;\r\n            }\r\n\r\n            const dotn = Vector3.Dot(vn, vc);\r\n            if (dotn > smoothingThreshold) {\r\n                if (dotn < Epsilon - 1) {\r\n                    // back to back\r\n                    vn_norm = new Vector3(p1.x, 0, p1.y).subtract(new Vector3(p.x, 0, p.y)).normalize();\r\n                } else {\r\n                    // cheap average weighed by side length\r\n                    vn_norm = vn.add(vc).normalize();\r\n                }\r\n            } else {\r\n                vn_norm = vc_norm;\r\n            }\r\n\r\n            uvs.push(ulength / bounds.width, 0);\r\n            uvs.push(ulength / bounds.width, 1);\r\n            ulength += vc.length();\r\n            uvs.push(ulength / bounds.width, 0);\r\n            uvs.push(ulength / bounds.width, 1);\r\n\r\n            normals.push(vp_norm.x, vp_norm.y, vp_norm.z);\r\n            normals.push(vp_norm.x, vp_norm.y, vp_norm.z);\r\n            normals.push(vn_norm.x, vn_norm.y, vn_norm.z);\r\n            normals.push(vn_norm.x, vn_norm.y, vn_norm.z);\r\n\r\n            if (!flip) {\r\n                indices.push(startIndex);\r\n                indices.push(startIndex + 1);\r\n                indices.push(startIndex + 2);\r\n\r\n                indices.push(startIndex + 1);\r\n                indices.push(startIndex + 3);\r\n                indices.push(startIndex + 2);\r\n            } else {\r\n                indices.push(startIndex);\r\n                indices.push(startIndex + 2);\r\n                indices.push(startIndex + 1);\r\n\r\n                indices.push(startIndex + 1);\r\n                indices.push(startIndex + 2);\r\n                indices.push(startIndex + 3);\r\n            }\r\n            startIndex += 4;\r\n        }\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Vector2, Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { PolygonMeshBuilder } from \"../polygonMesh\";\r\nimport type { FloatArray, IndicesArray, Nullable } from \"../../types\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport { useOpenGLOrientationForUV } from \"../../Compat/compatibilityOptions\";\r\n\r\ndeclare let earcut: any;\r\n\r\n/**\r\n * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\r\n * All parameters are provided by CreatePolygon as needed\r\n * @param polygon a mesh built from polygonTriangulation.build()\r\n * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param wrp a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\r\n * @returns the VertexData of the Polygon\r\n */\r\nexport function CreatePolygonVertexData(polygon: Mesh, sideOrientation: number, fUV?: Vector4[], fColors?: Color4[], frontUVs?: Vector4, backUVs?: Vector4, wrp?: boolean) {\r\n    const faceUV: Vector4[] = fUV || new Array<Vector4>(3);\r\n    const faceColors = fColors;\r\n    const colors = [];\r\n    const wrap: boolean = wrp || false;\r\n\r\n    // default face colors and UV if undefined\r\n    for (let f = 0; f < 3; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n\r\n    const positions = <FloatArray>polygon.getVerticesData(VertexBuffer.PositionKind);\r\n    const normals = <FloatArray>polygon.getVerticesData(VertexBuffer.NormalKind);\r\n    const uvs = <FloatArray>polygon.getVerticesData(VertexBuffer.UVKind);\r\n    const indices = <IndicesArray>polygon.getIndices();\r\n    const startIndex = positions.length / 9;\r\n    let disp = 0;\r\n    let distX = 0;\r\n    let distZ = 0;\r\n    let dist = 0;\r\n    let totalLen = 0;\r\n    const cumulate = [0];\r\n    if (wrap) {\r\n        for (let idx = startIndex; idx < positions.length / 3; idx += 4) {\r\n            distX = positions[3 * (idx + 2)] - positions[3 * idx];\r\n            distZ = positions[3 * (idx + 2) + 2] - positions[3 * idx + 2];\r\n            dist = Math.sqrt(distX * distX + distZ * distZ);\r\n            totalLen += dist;\r\n            cumulate.push(totalLen);\r\n        }\r\n    }\r\n    // set face colours and textures\r\n    let idx: number = 0;\r\n    let face: number = 0;\r\n    for (let index = 0; index < normals.length; index += 3) {\r\n        //Edge Face  no. 1\r\n        if (Math.abs(normals[index + 1]) < 0.001) {\r\n            face = 1;\r\n        }\r\n        //Top Face  no. 0\r\n        if (Math.abs(normals[index + 1] - 1) < 0.001) {\r\n            face = 0;\r\n        }\r\n        //Bottom Face  no. 2\r\n        if (Math.abs(normals[index + 1] + 1) < 0.001) {\r\n            face = 2;\r\n        }\r\n        idx = index / 3;\r\n        if (face === 1) {\r\n            disp = idx - startIndex;\r\n            if (disp % 4 < 1.5) {\r\n                if (wrap) {\r\n                    uvs[2 * idx] = faceUV[face].x + ((faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4)]) / totalLen;\r\n                } else {\r\n                    uvs[2 * idx] = faceUV[face].x;\r\n                }\r\n            } else {\r\n                if (wrap) {\r\n                    uvs[2 * idx] = faceUV[face].x + ((faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4) + 1]) / totalLen;\r\n                } else {\r\n                    uvs[2 * idx] = faceUV[face].z;\r\n                }\r\n            }\r\n            if (disp % 2 === 0) {\r\n                uvs[2 * idx + 1] = useOpenGLOrientationForUV ? 1.0 - faceUV[face].w : faceUV[face].w;\r\n            } else {\r\n                uvs[2 * idx + 1] = useOpenGLOrientationForUV ? 1.0 - faceUV[face].y : faceUV[face].y;\r\n            }\r\n        } else {\r\n            uvs[2 * idx] = (1 - uvs[2 * idx]) * faceUV[face].x + uvs[2 * idx] * faceUV[face].z;\r\n            uvs[2 * idx + 1] = (1 - uvs[2 * idx + 1]) * faceUV[face].y + uvs[2 * idx + 1] * faceUV[face].w;\r\n\r\n            if (useOpenGLOrientationForUV) {\r\n                uvs[2 * idx + 1] = 1.0 - uvs[2 * idx + 1];\r\n            }\r\n        }\r\n        if (faceColors) {\r\n            colors.push(faceColors[face].r, faceColors[face].g, faceColors[face].b, faceColors[face].a);\r\n        }\r\n    }\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    if (faceColors) {\r\n        const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a polygon mesh\r\n * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh\r\n * * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors\r\n * * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)\r\n * * Remember you can only change the shape positions, not their number when updating a polygon\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @param earcutInjection can be used to inject your own earcut reference\r\n * @returns the polygon mesh\r\n */\r\nexport function CreatePolygon(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        holes?: Vector3[][];\r\n        depth?: number;\r\n        smoothingThreshold?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        wrap?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null,\r\n    earcutInjection = earcut\r\n): Mesh {\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const shape = options.shape;\r\n    const holes = options.holes || [];\r\n    const depth = options.depth || 0;\r\n    const smoothingThreshold = options.smoothingThreshold || 2;\r\n    const contours: Array<Vector2> = [];\r\n    let hole: Array<Vector2> = [];\r\n\r\n    for (let i = 0; i < shape.length; i++) {\r\n        contours[i] = new Vector2(shape[i].x, shape[i].z);\r\n    }\r\n    const epsilon = 0.00000001;\r\n    if (contours[0].equalsWithEpsilon(contours[contours.length - 1], epsilon)) {\r\n        contours.pop();\r\n    }\r\n\r\n    const polygonTriangulation = new PolygonMeshBuilder(name, contours, scene || EngineStore.LastCreatedScene!, earcutInjection);\r\n    for (let hNb = 0; hNb < holes.length; hNb++) {\r\n        hole = [];\r\n        for (let hPoint = 0; hPoint < holes[hNb].length; hPoint++) {\r\n            hole.push(new Vector2(holes[hNb][hPoint].x, holes[hNb][hPoint].z));\r\n        }\r\n        polygonTriangulation.addHole(hole);\r\n    }\r\n    //updatability is set during applyToMesh; setting to true in triangulation build produces errors\r\n    const polygon = polygonTriangulation.build(false, depth, smoothingThreshold);\r\n    polygon._originalBuilderSideOrientation = options.sideOrientation;\r\n    const vertexData = CreatePolygonVertexData(polygon, options.sideOrientation, options.faceUV, options.faceColors, options.frontUVs, options.backUVs, options.wrap);\r\n    vertexData.applyToMesh(polygon, options.updatable);\r\n\r\n    return polygon;\r\n}\r\n\r\n/**\r\n * Creates an extruded polygon mesh, with depth in the Y direction.\r\n * * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/texturePerBoxFace\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @param earcutInjection can be used to inject your own earcut reference\r\n * @returns the polygon mesh\r\n */\r\nexport function ExtrudePolygon(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        holes?: Vector3[][];\r\n        depth?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        wrap?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null,\r\n    earcutInjection = earcut\r\n): Mesh {\r\n    return CreatePolygon(name, options, scene, earcutInjection);\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the functions directly from the module\r\n */\r\nexport const PolygonBuilder = {\r\n    ExtrudePolygon,\r\n    CreatePolygon,\r\n};\r\n\r\nVertexData.CreatePolygon = CreatePolygonVertexData;\r\nMesh.CreatePolygon = (name: string, shape: Vector3[], scene: Scene, holes?: Vector3[][], updatable?: boolean, sideOrientation?: number, earcutInjection = earcut): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        holes: holes,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation,\r\n    };\r\n    return CreatePolygon(name, options, scene, earcutInjection);\r\n};\r\n\r\nMesh.ExtrudePolygon = (\r\n    name: string,\r\n    shape: Vector3[],\r\n    depth: number,\r\n    scene: Scene,\r\n    holes?: Vector3[][],\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    earcutInjection = earcut\r\n): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        holes: holes,\r\n        depth: depth,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation,\r\n    };\r\n    return ExtrudePolygon(name, options, scene, earcutInjection);\r\n};\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, TmpVectors, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { CreateRibbon } from \"./ribbonBuilder\";\r\nimport { Path3D } from \"../../Maths/math.path\";\r\n\r\n/**\r\n * Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n * * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.\r\n * * The parameter `scale` (float, default 1) is the value to scale the shape.\r\n * * The parameter `closeShape` (boolean, default false) closes the shape when true, since v5.0.0.\r\n * * The parameter `closePath` (boolean, default false) closes the path when true and no caps, since v5.0.0.\r\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#extruded-shape\r\n * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * * The optional parameter `firstNormal` (Vector3) defines the direction of the first normal of the supplied path. Consider using this for any path that is straight, and particular for paths in the xy plane.\r\n * * The optional `adjustFrame` (boolean, default false) will cause the internally generated Path3D tangents, normals, and binormals to be adjusted so that a) they are always well-defined, and b) they do not reverse from one path point to the next. This prevents the extruded shape from being flipped and/or rotated with resulting mesh self-intersections. This is primarily useful for straight paths that can reverse direction.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the extruded shape mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#extruded-shapes\r\n */\r\nexport function ExtrudeShape(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        path: Vector3[];\r\n        scale?: number;\r\n        rotation?: number;\r\n        closeShape?: boolean;\r\n        closePath?: boolean;\r\n        cap?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        instance?: Mesh;\r\n        invertUV?: boolean;\r\n        firstNormal?: Vector3;\r\n        adjustFrame?: boolean;\r\n        capFunction?: Nullable<{ (shapePath: Vector3[]): Vector3[] }>;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const path = options.path;\r\n    const shape = options.shape;\r\n    const scale = options.scale || 1;\r\n    const rotation = options.rotation || 0;\r\n    const cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\r\n    const updatable = options.updatable;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const instance = options.instance || null;\r\n    const invertUV = options.invertUV || false;\r\n    const closeShape = options.closeShape || false;\r\n    const closePath = options.closePath || false;\r\n    const capFunction = options.capFunction || null;\r\n\r\n    return _ExtrudeShapeGeneric(\r\n        name,\r\n        shape,\r\n        path,\r\n        scale,\r\n        rotation,\r\n        null,\r\n        null,\r\n        closePath,\r\n        closeShape,\r\n        cap,\r\n        false,\r\n        scene,\r\n        updatable ? true : false,\r\n        sideOrientation,\r\n        instance,\r\n        invertUV,\r\n        options.frontUVs || null,\r\n        options.backUVs || null,\r\n        options.firstNormal || null,\r\n        options.adjustFrame ? true : false,\r\n        capFunction\r\n    );\r\n}\r\n\r\n/**\r\n * Creates an custom extruded shape mesh.\r\n * The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n * * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the beginning of the path\r\n * * It must returns a float value that will be the rotation in radians applied to the shape on each path point.\r\n * * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the beginning of the path\r\n * * It must returns a float value that will be the scale value applied to the shape on each path point\r\n * * The parameter `closeShape` (boolean, default false) closes the shape when true, since v5.0.0.\r\n * * The parameter `closePath` (boolean, default false) closes the path when true and no caps, since v5.0.0.\r\n * * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray` - depreciated in favor of closeShape\r\n * * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray` - depreciated in favor of closePath\r\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#extruded-shape\r\n * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * * The optional parameter `firstNormal` (Vector3) defines the direction of the first normal of the supplied path. It should be supplied when the path is in the xy plane, and particularly if these sections are straight, because the underlying Path3D object will pick a normal in the xy plane that causes the extrusion to be collapsed into the plane. This should be used for any path that is straight.\r\n * * The optional `adjustFrame` (boolean, default false) will cause the internally generated Path3D tangents, normals, and binormals to be adjusted so that a) they are always well-defined, and b) they do not reverse from one path point to the next. This prevents the extruded shape from being flipped and/or rotated with resulting mesh self-intersections. This is primarily useful for straight paths that can reverse direction.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the custom extruded shape mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#custom-extruded-shapes\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#extruded-shapes\r\n */\r\nexport function ExtrudeShapeCustom(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        path: Vector3[];\r\n        scaleFunction?: Nullable<{ (i: number, distance: number): number }>;\r\n        rotationFunction?: Nullable<{ (i: number, distance: number): number }>;\r\n        ribbonCloseArray?: boolean;\r\n        ribbonClosePath?: boolean;\r\n        closeShape?: boolean;\r\n        closePath?: boolean;\r\n        cap?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        instance?: Mesh;\r\n        invertUV?: boolean;\r\n        firstNormal?: Vector3;\r\n        adjustFrame?: boolean;\r\n        capFunction?: Nullable<{ (shapePath: Vector3[]): Vector3[] }>;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const path = options.path;\r\n    const shape = options.shape;\r\n    const scaleFunction =\r\n        options.scaleFunction ||\r\n        (() => {\r\n            return 1;\r\n        });\r\n    const rotationFunction =\r\n        options.rotationFunction ||\r\n        (() => {\r\n            return 0;\r\n        });\r\n    const ribbonCloseArray = options.closePath || options.ribbonCloseArray || false;\r\n    const ribbonClosePath = options.closeShape || options.ribbonClosePath || false;\r\n    const cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\r\n    const updatable = options.updatable;\r\n    const firstNormal = options.firstNormal || null;\r\n    const adjustFrame = options.adjustFrame || false;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const instance = options.instance;\r\n    const invertUV = options.invertUV || false;\r\n    const capFunction = options.capFunction || null;\r\n    return _ExtrudeShapeGeneric(\r\n        name,\r\n        shape,\r\n        path,\r\n        null,\r\n        null,\r\n        scaleFunction,\r\n        rotationFunction,\r\n        ribbonCloseArray,\r\n        ribbonClosePath,\r\n        cap,\r\n        true,\r\n        scene,\r\n        updatable ? true : false,\r\n        sideOrientation,\r\n        instance || null,\r\n        invertUV,\r\n        options.frontUVs || null,\r\n        options.backUVs || null,\r\n        firstNormal,\r\n        adjustFrame,\r\n        capFunction || null\r\n    );\r\n}\r\n\r\nfunction _ExtrudeShapeGeneric(\r\n    name: string,\r\n    shape: Vector3[],\r\n    curve: Vector3[],\r\n    scale: Nullable<number>,\r\n    rotation: Nullable<number>,\r\n    scaleFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    rotateFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    rbCA: boolean,\r\n    rbCP: boolean,\r\n    cap: number,\r\n    custom: boolean,\r\n    scene: Nullable<Scene>,\r\n    updtbl: boolean,\r\n    side: number,\r\n    instance: Nullable<Mesh>,\r\n    invertUV: boolean,\r\n    frontUVs: Nullable<Vector4>,\r\n    backUVs: Nullable<Vector4>,\r\n    firstNormal: Nullable<Vector3>,\r\n    adjustFrame: boolean,\r\n    capFunction: Nullable<{ (shapePath: Vector3[]): Vector3[] }>\r\n): Mesh {\r\n    // extrusion geometry\r\n    const extrusionPathArray = (\r\n        shape: Vector3[],\r\n        curve: Vector3[],\r\n        path3D: Path3D,\r\n        shapePaths: Vector3[][],\r\n        scale: Nullable<number>,\r\n        rotation: Nullable<number>,\r\n        scaleFunction: Nullable<{ (i: number, distance: number): number }>,\r\n        rotateFunction: Nullable<{ (i: number, distance: number): number }>,\r\n        cap: number,\r\n        custom: boolean,\r\n        adjustFrame: boolean\r\n    ) => {\r\n        const tangents = path3D.getTangents();\r\n        const normals = path3D.getNormals();\r\n        const binormals = path3D.getBinormals();\r\n        const distances = path3D.getDistances();\r\n        if (adjustFrame) {\r\n            /* fix tangents,normals, binormals */\r\n            for (let i = 0; i < tangents.length; i++) {\r\n                if (tangents[i].x == 0 && tangents[i].y == 0 && tangents[i].z == 0) {\r\n                    tangents[i].copyFrom(tangents[i - 1]);\r\n                }\r\n                if (normals[i].x == 0 && normals[i].y == 0 && normals[i].z == 0) {\r\n                    normals[i].copyFrom(normals[i - 1]);\r\n                }\r\n                if (binormals[i].x == 0 && binormals[i].y == 0 && binormals[i].z == 0) {\r\n                    binormals[i].copyFrom(binormals[i - 1]);\r\n                }\r\n                if (i > 0) {\r\n                    let v = tangents[i - 1];\r\n                    if (Vector3.Dot(v, tangents[i]) < 0) {\r\n                        tangents[i].scaleInPlace(-1);\r\n                    }\r\n                    v = normals[i - 1];\r\n                    if (Vector3.Dot(v, normals[i]) < 0) {\r\n                        normals[i].scaleInPlace(-1);\r\n                    }\r\n                    v = binormals[i - 1];\r\n                    if (Vector3.Dot(v, binormals[i]) < 0) {\r\n                        binormals[i].scaleInPlace(-1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        let angle = 0;\r\n        const returnScale = () => {\r\n            return scale !== null ? scale : 1;\r\n        };\r\n        const returnRotation = () => {\r\n            return rotation !== null ? rotation : 0;\r\n        };\r\n        const rotate: { (i: number, distance: number): number } = custom && rotateFunction ? rotateFunction : returnRotation;\r\n        const scl: { (i: number, distance: number): number } = custom && scaleFunction ? scaleFunction : returnScale;\r\n        let index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\r\n        const rotationMatrix: Matrix = TmpVectors.Matrix[0];\r\n\r\n        for (let i = 0; i < curve.length; i++) {\r\n            const shapePath: Vector3[] = [];\r\n            const angleStep = rotate(i, distances[i]);\r\n            const scaleRatio = scl(i, distances[i]);\r\n            Matrix.RotationAxisToRef(tangents[i], angle, rotationMatrix);\r\n            for (let p = 0; p < shape.length; p++) {\r\n                const planed = tangents[i].scale(shape[p].z).add(normals[i].scale(shape[p].x)).add(binormals[i].scale(shape[p].y));\r\n                const rotated = Vector3.Zero();\r\n                Vector3.TransformCoordinatesToRef(planed, rotationMatrix, rotated);\r\n                rotated.scaleInPlace(scaleRatio).addInPlace(curve[i]);\r\n                shapePath[p] = rotated;\r\n            }\r\n            shapePaths[index] = shapePath;\r\n            angle += angleStep;\r\n            index++;\r\n        }\r\n        // cap\r\n        const defaultCapPath = (shapePath: Vector3[]) => {\r\n            const pointCap = Array<Vector3>();\r\n            const barycenter = Vector3.Zero();\r\n            let i: number;\r\n            for (i = 0; i < shapePath.length; i++) {\r\n                barycenter.addInPlace(shapePath[i]);\r\n            }\r\n            barycenter.scaleInPlace(1.0 / shapePath.length);\r\n            for (i = 0; i < shapePath.length; i++) {\r\n                pointCap.push(barycenter);\r\n            }\r\n            return pointCap;\r\n        };\r\n        const capPath = capFunction || defaultCapPath;\r\n        switch (cap) {\r\n            case Mesh.NO_CAP:\r\n                break;\r\n            case Mesh.CAP_START:\r\n                shapePaths[0] = capPath(shapePaths[2]);\r\n                shapePaths[1] = shapePaths[2];\r\n                break;\r\n            case Mesh.CAP_END:\r\n                shapePaths[index] = shapePaths[index - 1];\r\n                shapePaths[index + 1] = capPath(shapePaths[index - 1]);\r\n                break;\r\n            case Mesh.CAP_ALL:\r\n                shapePaths[0] = capPath(shapePaths[2]);\r\n                shapePaths[1] = shapePaths[2];\r\n                shapePaths[index] = shapePaths[index - 1];\r\n                shapePaths[index + 1] = capPath(shapePaths[index - 1]);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        return shapePaths;\r\n    };\r\n    let path3D;\r\n    let pathArray;\r\n    if (instance) {\r\n        // instance update\r\n        const storage = instance._creationDataStorage!;\r\n        path3D = firstNormal ? storage.path3D.update(curve, firstNormal) : storage.path3D.update(curve);\r\n        pathArray = extrusionPathArray(shape, curve, storage.path3D, storage.pathArray, scale, rotation, scaleFunction, rotateFunction, storage.cap, custom, adjustFrame);\r\n        instance = CreateRibbon(\"\", { pathArray, closeArray: false, closePath: false, offset: 0, updatable: false, sideOrientation: 0, instance }, scene || undefined);\r\n\r\n        return instance;\r\n    }\r\n    // extruded shape creation\r\n    path3D = firstNormal ? new Path3D(curve, firstNormal) : new Path3D(curve);\r\n    const newShapePaths = new Array<Array<Vector3>>();\r\n    cap = cap < 0 || cap > 3 ? 0 : cap;\r\n    pathArray = extrusionPathArray(shape, curve, path3D, newShapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom, adjustFrame);\r\n    const extrudedGeneric = CreateRibbon(\r\n        name,\r\n        {\r\n            pathArray: pathArray,\r\n            closeArray: rbCA,\r\n            closePath: rbCP,\r\n            updatable: updtbl,\r\n            sideOrientation: side,\r\n            invertUV: invertUV,\r\n            frontUVs: frontUVs || undefined,\r\n            backUVs: backUVs || undefined,\r\n        },\r\n        scene\r\n    );\r\n    extrudedGeneric._creationDataStorage!.pathArray = pathArray;\r\n    extrudedGeneric._creationDataStorage!.path3D = path3D;\r\n    extrudedGeneric._creationDataStorage!.cap = cap;\r\n\r\n    return extrudedGeneric;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated please use the functions directly from the module\r\n */\r\nexport const ShapeBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    ExtrudeShape,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    ExtrudeShapeCustom,\r\n};\r\n\r\nMesh.ExtrudeShape = (\r\n    name: string,\r\n    shape: Vector3[],\r\n    path: Vector3[],\r\n    scale: number,\r\n    rotation: number,\r\n    cap: number,\r\n    scene: Nullable<Scene> = null,\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        path: path,\r\n        scale: scale,\r\n        rotation: rotation,\r\n        cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return ExtrudeShape(name, options, scene);\r\n};\r\n\r\nMesh.ExtrudeShapeCustom = (\r\n    name: string,\r\n    shape: Vector3[],\r\n    path: Vector3[],\r\n    scaleFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    rotationFunction: Nullable<{ (i: number, distance: number): number }>,\r\n    ribbonCloseArray: boolean,\r\n    ribbonClosePath: boolean,\r\n    cap: number,\r\n    scene: Scene,\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        path: path,\r\n        scaleFunction: scaleFunction,\r\n        rotationFunction: rotationFunction,\r\n        ribbonCloseArray: ribbonCloseArray,\r\n        ribbonClosePath: ribbonClosePath,\r\n        cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return ExtrudeShapeCustom(name, options, scene);\r\n};\r\n", "import type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { CreateRibbon } from \"./ribbonBuilder\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Creates lathe mesh.\r\n * The lathe is a shape with a symmetry axis : a 2D model shape is rotated around this axis to design the lathe\r\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero\r\n * * The parameter `radius` (positive float, default 1) is the radius value of the lathe\r\n * * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe\r\n * * The parameter `clip` (positive integer, default 0) is the number of sides to not create without effecting the general shape of the sides\r\n * * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape\r\n * * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter \"arc\"\r\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the lathe mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#lathe\r\n */\r\nexport function CreateLathe(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        radius?: number;\r\n        tessellation?: number;\r\n        clip?: number;\r\n        arc?: number;\r\n        closed?: boolean;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        cap?: number;\r\n        invertUV?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const arc: number = options.arc ? (options.arc <= 0 || options.arc > 1 ? 1.0 : options.arc) : 1.0;\r\n    const closed: boolean = options.closed === undefined ? true : options.closed;\r\n    const shape = options.shape;\r\n    const radius = options.radius || 1;\r\n    const tessellation = options.tessellation || 64;\r\n    const clip = options.clip || 0;\r\n    const updatable = options.updatable;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const cap = options.cap || Mesh.NO_CAP;\r\n    const pi2 = Math.PI * 2;\r\n    const paths = [];\r\n    const invertUV = options.invertUV || false;\r\n\r\n    let i = 0;\r\n    let p = 0;\r\n    const step = (pi2 / tessellation) * arc;\r\n    let rotated;\r\n    let path: Array<Vector3>;\r\n    for (i = 0; i <= tessellation - clip; i++) {\r\n        path = [];\r\n        if (cap == Mesh.CAP_START || cap == Mesh.CAP_ALL) {\r\n            path.push(new Vector3(0, shape[0].y, 0));\r\n            path.push(new Vector3(Math.cos(i * step) * shape[0].x * radius, shape[0].y, Math.sin(i * step) * shape[0].x * radius));\r\n        }\r\n        for (p = 0; p < shape.length; p++) {\r\n            rotated = new Vector3(Math.cos(i * step) * shape[p].x * radius, shape[p].y, Math.sin(i * step) * shape[p].x * radius);\r\n            path.push(rotated);\r\n        }\r\n        if (cap == Mesh.CAP_END || cap == Mesh.CAP_ALL) {\r\n            path.push(new Vector3(Math.cos(i * step) * shape[shape.length - 1].x * radius, shape[shape.length - 1].y, Math.sin(i * step) * shape[shape.length - 1].x * radius));\r\n            path.push(new Vector3(0, shape[shape.length - 1].y, 0));\r\n        }\r\n        paths.push(path);\r\n    }\r\n\r\n    // lathe ribbon\r\n    const lathe = CreateRibbon(\r\n        name,\r\n        { pathArray: paths, closeArray: closed, sideOrientation: sideOrientation, updatable: updatable, invertUV: invertUV, frontUVs: options.frontUVs, backUVs: options.backUVs },\r\n        scene\r\n    );\r\n    return lathe;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function direction from the module\r\n */\r\nexport const LatheBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateLathe,\r\n};\r\n\r\nMesh.CreateLathe = (name: string, shape: Vector3[], radius: number, tessellation: number, scene: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        radius: radius,\r\n        tessellation: tessellation,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return CreateLathe(name, options, scene);\r\n};\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, TmpVectors, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { CreateRibbon } from \"./ribbonBuilder\";\r\nimport { Path3D } from \"../../Maths/math.path\";\r\n\r\n/**\r\n * Creates a tube mesh.\r\n * The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters\r\n * * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube\r\n * * The parameter `radius` (positive float, default 1) sets the tube radius size\r\n * * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface\r\n * * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overrides the parameter `radius`\r\n * * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)\r\n * * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc\r\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n * * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter. The `path`Array HAS to have the SAME number of points as the previous one: https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#tube\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created. The NUMBER of points CAN'T CHANGE, only their positions.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.path\r\n * @param options.radius\r\n * @param options.tessellation\r\n * @param options.radiusFunction\r\n * @param options.cap\r\n * @param options.arc\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.instance\r\n * @param options.invertUV\r\n * @param scene defines the hosting scene\r\n * @returns the tube mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#tube\r\n */\r\nexport function CreateTube(\r\n    name: string,\r\n    options: {\r\n        path: Vector3[];\r\n        radius?: number;\r\n        tessellation?: number;\r\n        radiusFunction?: { (i: number, distance: number): number };\r\n        cap?: number;\r\n        arc?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        instance?: Mesh;\r\n        invertUV?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const path = options.path;\r\n    let instance = options.instance;\r\n    let radius = 1.0;\r\n\r\n    if (options.radius !== undefined) {\r\n        radius = options.radius;\r\n    } else if (instance) {\r\n        radius = instance._creationDataStorage!.radius;\r\n    }\r\n\r\n    const tessellation = options.tessellation || 64 | 0;\r\n    const radiusFunction = options.radiusFunction || null;\r\n    let cap = options.cap || Mesh.NO_CAP;\r\n    const invertUV = options.invertUV || false;\r\n    const updatable = options.updatable;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    options.arc = options.arc && (options.arc <= 0.0 || options.arc > 1.0) ? 1.0 : options.arc || 1.0;\r\n\r\n    // tube geometry\r\n    const tubePathArray = (\r\n        path: Vector3[],\r\n        path3D: Path3D,\r\n        circlePaths: Vector3[][],\r\n        radius: number,\r\n        tessellation: number,\r\n        radiusFunction: Nullable<{ (i: number, distance: number): number }>,\r\n        cap: number,\r\n        arc: number\r\n    ) => {\r\n        const tangents = path3D.getTangents();\r\n        const normals = path3D.getNormals();\r\n        const distances = path3D.getDistances();\r\n        const pi2 = Math.PI * 2;\r\n        const step = (pi2 / tessellation) * arc;\r\n        const returnRadius: { (i: number, distance: number): number } = () => radius;\r\n        const radiusFunctionFinal: { (i: number, distance: number): number } = radiusFunction || returnRadius;\r\n\r\n        let circlePath: Vector3[];\r\n        let rad: number;\r\n        let normal: Vector3;\r\n        let rotated: Vector3;\r\n        const rotationMatrix: Matrix = TmpVectors.Matrix[0];\r\n        let index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\r\n        for (let i = 0; i < path.length; i++) {\r\n            rad = radiusFunctionFinal(i, distances[i]); // current radius\r\n            circlePath = Array<Vector3>(); // current circle array\r\n            normal = normals[i]; // current normal\r\n            for (let t = 0; t < tessellation; t++) {\r\n                Matrix.RotationAxisToRef(tangents[i], step * t, rotationMatrix);\r\n                rotated = circlePath[t] ? circlePath[t] : Vector3.Zero();\r\n                Vector3.TransformCoordinatesToRef(normal, rotationMatrix, rotated);\r\n                rotated.scaleInPlace(rad).addInPlace(path[i]);\r\n                circlePath[t] = rotated;\r\n            }\r\n            circlePaths[index] = circlePath;\r\n            index++;\r\n        }\r\n        // cap\r\n        const capPath = (nbPoints: number, pathIndex: number): Array<Vector3> => {\r\n            const pointCap = Array<Vector3>();\r\n            for (let i = 0; i < nbPoints; i++) {\r\n                pointCap.push(path[pathIndex]);\r\n            }\r\n            return pointCap;\r\n        };\r\n        switch (cap) {\r\n            case Mesh.NO_CAP:\r\n                break;\r\n            case Mesh.CAP_START:\r\n                circlePaths[0] = capPath(tessellation, 0);\r\n                circlePaths[1] = circlePaths[2].slice(0);\r\n                break;\r\n            case Mesh.CAP_END:\r\n                circlePaths[index] = circlePaths[index - 1].slice(0);\r\n                circlePaths[index + 1] = capPath(tessellation, path.length - 1);\r\n                break;\r\n            case Mesh.CAP_ALL:\r\n                circlePaths[0] = capPath(tessellation, 0);\r\n                circlePaths[1] = circlePaths[2].slice(0);\r\n                circlePaths[index] = circlePaths[index - 1].slice(0);\r\n                circlePaths[index + 1] = capPath(tessellation, path.length - 1);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        return circlePaths;\r\n    };\r\n\r\n    let path3D;\r\n    let pathArray;\r\n    if (instance) {\r\n        // tube update\r\n        const storage = instance._creationDataStorage!;\r\n        const arc = options.arc || storage.arc;\r\n        path3D = storage.path3D.update(path);\r\n        pathArray = tubePathArray(path, path3D, storage.pathArray, radius, storage.tessellation, radiusFunction, storage.cap, arc);\r\n        instance = CreateRibbon(\"\", { pathArray: pathArray, instance: instance });\r\n        // Update mode, no need to recreate the storage.\r\n        storage.path3D = path3D;\r\n        storage.pathArray = pathArray;\r\n        storage.arc = arc;\r\n        storage.radius = radius;\r\n\r\n        return instance;\r\n    }\r\n\r\n    // tube creation\r\n    path3D = <any>new Path3D(path);\r\n    const newPathArray = new Array<Array<Vector3>>();\r\n    cap = cap < 0 || cap > 3 ? 0 : cap;\r\n    pathArray = tubePathArray(path, path3D, newPathArray, radius, tessellation, radiusFunction, cap, options.arc);\r\n    const tube = CreateRibbon(\r\n        name,\r\n        {\r\n            pathArray: pathArray,\r\n            closePath: true,\r\n            closeArray: false,\r\n            updatable: updatable,\r\n            sideOrientation: sideOrientation,\r\n            invertUV: invertUV,\r\n            frontUVs: options.frontUVs,\r\n            backUVs: options.backUVs,\r\n        },\r\n        scene\r\n    );\r\n    tube._creationDataStorage!.pathArray = pathArray;\r\n    tube._creationDataStorage!.path3D = path3D;\r\n    tube._creationDataStorage!.tessellation = tessellation;\r\n    tube._creationDataStorage!.cap = cap;\r\n    tube._creationDataStorage!.arc = options.arc;\r\n    tube._creationDataStorage!.radius = radius;\r\n\r\n    return tube;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTube directly\r\n */\r\nexport const TubeBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTube,\r\n};\r\n\r\nMesh.CreateTube = (\r\n    name: string,\r\n    path: Vector3[],\r\n    radius: number,\r\n    tessellation: number,\r\n    radiusFunction: { (i: number, distance: number): number },\r\n    cap: number,\r\n    scene: Scene,\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n): Mesh => {\r\n    const options = {\r\n        path: path,\r\n        radius: radius,\r\n        tessellation: tessellation,\r\n        radiusFunction: radiusFunction,\r\n        arc: 1,\r\n        cap: cap,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n    };\r\n    return CreateTube(name, options, scene);\r\n};\r\n", "import type { Scene } from \"../../scene\";\r\nimport { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { useOpenGLOrientationForUV } from \"../../Compat/compatibilityOptions\";\r\n\r\n// inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html\r\n/**\r\n * Creates the VertexData for a Polyhedron\r\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n * * type provided types are:\r\n *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\r\n *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\r\n * * size the size of the IcoSphere, optional default 1\r\n * * sizeX allows stretching in the x direction, optional, default size\r\n * * sizeY allows stretching in the y direction, optional, default size\r\n * * sizeZ allows stretching in the z direction, optional, default size\r\n * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor\r\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n * * flat when true creates a flat shaded mesh, optional, default true\r\n * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @returns the VertexData of the Polyhedron\r\n */\r\nexport function CreatePolyhedronVertexData(options: {\r\n    type?: number;\r\n    size?: number;\r\n    sizeX?: number;\r\n    sizeY?: number;\r\n    sizeZ?: number;\r\n    custom?: any;\r\n    faceUV?: Vector4[];\r\n    faceColors?: Color4[];\r\n    flat?: boolean;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    // provided polyhedron types :\r\n    // 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\r\n    // 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\r\n    const polyhedra: { vertex: number[][]; face: number[][] }[] = [];\r\n    polyhedra[0] = {\r\n        vertex: [\r\n            [0, 0, 1.732051],\r\n            [1.632993, 0, -0.5773503],\r\n            [-0.8164966, 1.414214, -0.5773503],\r\n            [-0.8164966, -1.414214, -0.5773503],\r\n        ],\r\n        face: [\r\n            [0, 1, 2],\r\n            [0, 2, 3],\r\n            [0, 3, 1],\r\n            [1, 3, 2],\r\n        ],\r\n    };\r\n    polyhedra[1] = {\r\n        vertex: [\r\n            [0, 0, 1.414214],\r\n            [1.414214, 0, 0],\r\n            [0, 1.414214, 0],\r\n            [-1.414214, 0, 0],\r\n            [0, -1.414214, 0],\r\n            [0, 0, -1.414214],\r\n        ],\r\n        face: [\r\n            [0, 1, 2],\r\n            [0, 2, 3],\r\n            [0, 3, 4],\r\n            [0, 4, 1],\r\n            [1, 4, 5],\r\n            [1, 5, 2],\r\n            [2, 5, 3],\r\n            [3, 5, 4],\r\n        ],\r\n    };\r\n    polyhedra[2] = {\r\n        vertex: [\r\n            [0, 0, 1.070466],\r\n            [0.7136442, 0, 0.7978784],\r\n            [-0.3568221, 0.618034, 0.7978784],\r\n            [-0.3568221, -0.618034, 0.7978784],\r\n            [0.7978784, 0.618034, 0.3568221],\r\n            [0.7978784, -0.618034, 0.3568221],\r\n            [-0.9341724, 0.381966, 0.3568221],\r\n            [0.1362939, 1, 0.3568221],\r\n            [0.1362939, -1, 0.3568221],\r\n            [-0.9341724, -0.381966, 0.3568221],\r\n            [0.9341724, 0.381966, -0.3568221],\r\n            [0.9341724, -0.381966, -0.3568221],\r\n            [-0.7978784, 0.618034, -0.3568221],\r\n            [-0.1362939, 1, -0.3568221],\r\n            [-0.1362939, -1, -0.3568221],\r\n            [-0.7978784, -0.618034, -0.3568221],\r\n            [0.3568221, 0.618034, -0.7978784],\r\n            [0.3568221, -0.618034, -0.7978784],\r\n            [-0.7136442, 0, -0.7978784],\r\n            [0, 0, -1.070466],\r\n        ],\r\n        face: [\r\n            [0, 1, 4, 7, 2],\r\n            [0, 2, 6, 9, 3],\r\n            [0, 3, 8, 5, 1],\r\n            [1, 5, 11, 10, 4],\r\n            [2, 7, 13, 12, 6],\r\n            [3, 9, 15, 14, 8],\r\n            [4, 10, 16, 13, 7],\r\n            [5, 8, 14, 17, 11],\r\n            [6, 12, 18, 15, 9],\r\n            [10, 11, 17, 19, 16],\r\n            [12, 13, 16, 19, 18],\r\n            [14, 15, 18, 19, 17],\r\n        ],\r\n    };\r\n    polyhedra[3] = {\r\n        vertex: [\r\n            [0, 0, 1.175571],\r\n            [1.051462, 0, 0.5257311],\r\n            [0.3249197, 1, 0.5257311],\r\n            [-0.8506508, 0.618034, 0.5257311],\r\n            [-0.8506508, -0.618034, 0.5257311],\r\n            [0.3249197, -1, 0.5257311],\r\n            [0.8506508, 0.618034, -0.5257311],\r\n            [0.8506508, -0.618034, -0.5257311],\r\n            [-0.3249197, 1, -0.5257311],\r\n            [-1.051462, 0, -0.5257311],\r\n            [-0.3249197, -1, -0.5257311],\r\n            [0, 0, -1.175571],\r\n        ],\r\n        face: [\r\n            [0, 1, 2],\r\n            [0, 2, 3],\r\n            [0, 3, 4],\r\n            [0, 4, 5],\r\n            [0, 5, 1],\r\n            [1, 5, 7],\r\n            [1, 7, 6],\r\n            [1, 6, 2],\r\n            [2, 6, 8],\r\n            [2, 8, 3],\r\n            [3, 8, 9],\r\n            [3, 9, 4],\r\n            [4, 9, 10],\r\n            [4, 10, 5],\r\n            [5, 10, 7],\r\n            [6, 7, 11],\r\n            [6, 11, 8],\r\n            [7, 10, 11],\r\n            [8, 11, 9],\r\n            [9, 11, 10],\r\n        ],\r\n    };\r\n    polyhedra[4] = {\r\n        vertex: [\r\n            [0, 0, 1.070722],\r\n            [0.7148135, 0, 0.7971752],\r\n            [-0.104682, 0.7071068, 0.7971752],\r\n            [-0.6841528, 0.2071068, 0.7971752],\r\n            [-0.104682, -0.7071068, 0.7971752],\r\n            [0.6101315, 0.7071068, 0.5236279],\r\n            [1.04156, 0.2071068, 0.1367736],\r\n            [0.6101315, -0.7071068, 0.5236279],\r\n            [-0.3574067, 1, 0.1367736],\r\n            [-0.7888348, -0.5, 0.5236279],\r\n            [-0.9368776, 0.5, 0.1367736],\r\n            [-0.3574067, -1, 0.1367736],\r\n            [0.3574067, 1, -0.1367736],\r\n            [0.9368776, -0.5, -0.1367736],\r\n            [0.7888348, 0.5, -0.5236279],\r\n            [0.3574067, -1, -0.1367736],\r\n            [-0.6101315, 0.7071068, -0.5236279],\r\n            [-1.04156, -0.2071068, -0.1367736],\r\n            [-0.6101315, -0.7071068, -0.5236279],\r\n            [0.104682, 0.7071068, -0.7971752],\r\n            [0.6841528, -0.2071068, -0.7971752],\r\n            [0.104682, -0.7071068, -0.7971752],\r\n            [-0.7148135, 0, -0.7971752],\r\n            [0, 0, -1.070722],\r\n        ],\r\n        face: [\r\n            [0, 2, 3],\r\n            [1, 6, 5],\r\n            [4, 9, 11],\r\n            [7, 15, 13],\r\n            [8, 16, 10],\r\n            [12, 14, 19],\r\n            [17, 22, 18],\r\n            [20, 21, 23],\r\n            [0, 1, 5, 2],\r\n            [0, 3, 9, 4],\r\n            [0, 4, 7, 1],\r\n            [1, 7, 13, 6],\r\n            [2, 5, 12, 8],\r\n            [2, 8, 10, 3],\r\n            [3, 10, 17, 9],\r\n            [4, 11, 15, 7],\r\n            [5, 6, 14, 12],\r\n            [6, 13, 20, 14],\r\n            [8, 12, 19, 16],\r\n            [9, 17, 18, 11],\r\n            [10, 16, 22, 17],\r\n            [11, 18, 21, 15],\r\n            [13, 15, 21, 20],\r\n            [14, 20, 23, 19],\r\n            [16, 19, 23, 22],\r\n            [18, 22, 23, 21],\r\n        ],\r\n    };\r\n    polyhedra[5] = {\r\n        vertex: [\r\n            [0, 0, 1.322876],\r\n            [1.309307, 0, 0.1889822],\r\n            [-0.9819805, 0.8660254, 0.1889822],\r\n            [0.1636634, -1.299038, 0.1889822],\r\n            [0.3273268, 0.8660254, -0.9449112],\r\n            [-0.8183171, -0.4330127, -0.9449112],\r\n        ],\r\n        face: [\r\n            [0, 3, 1],\r\n            [2, 4, 5],\r\n            [0, 1, 4, 2],\r\n            [0, 2, 5, 3],\r\n            [1, 3, 5, 4],\r\n        ],\r\n    };\r\n    polyhedra[6] = {\r\n        vertex: [\r\n            [0, 0, 1.159953],\r\n            [1.013464, 0, 0.5642542],\r\n            [-0.3501431, 0.9510565, 0.5642542],\r\n            [-0.7715208, -0.6571639, 0.5642542],\r\n            [0.6633206, 0.9510565, -0.03144481],\r\n            [0.8682979, -0.6571639, -0.3996071],\r\n            [-1.121664, 0.2938926, -0.03144481],\r\n            [-0.2348831, -1.063314, -0.3996071],\r\n            [0.5181548, 0.2938926, -0.9953061],\r\n            [-0.5850262, -0.112257, -0.9953061],\r\n        ],\r\n        face: [\r\n            [0, 1, 4, 2],\r\n            [0, 2, 6, 3],\r\n            [1, 5, 8, 4],\r\n            [3, 6, 9, 7],\r\n            [5, 7, 9, 8],\r\n            [0, 3, 7, 5, 1],\r\n            [2, 4, 8, 9, 6],\r\n        ],\r\n    };\r\n    polyhedra[7] = {\r\n        vertex: [\r\n            [0, 0, 1.118034],\r\n            [0.8944272, 0, 0.6708204],\r\n            [-0.2236068, 0.8660254, 0.6708204],\r\n            [-0.7826238, -0.4330127, 0.6708204],\r\n            [0.6708204, 0.8660254, 0.2236068],\r\n            [1.006231, -0.4330127, -0.2236068],\r\n            [-1.006231, 0.4330127, 0.2236068],\r\n            [-0.6708204, -0.8660254, -0.2236068],\r\n            [0.7826238, 0.4330127, -0.6708204],\r\n            [0.2236068, -0.8660254, -0.6708204],\r\n            [-0.8944272, 0, -0.6708204],\r\n            [0, 0, -1.118034],\r\n        ],\r\n        face: [\r\n            [0, 1, 4, 2],\r\n            [0, 2, 6, 3],\r\n            [1, 5, 8, 4],\r\n            [3, 6, 10, 7],\r\n            [5, 9, 11, 8],\r\n            [7, 10, 11, 9],\r\n            [0, 3, 7, 9, 5, 1],\r\n            [2, 4, 8, 11, 10, 6],\r\n        ],\r\n    };\r\n    polyhedra[8] = {\r\n        vertex: [\r\n            [-0.729665, 0.670121, 0.319155],\r\n            [-0.655235, -0.29213, -0.754096],\r\n            [-0.093922, -0.607123, 0.537818],\r\n            [0.702196, 0.595691, 0.485187],\r\n            [0.776626, -0.36656, -0.588064],\r\n        ],\r\n        face: [\r\n            [1, 4, 2],\r\n            [0, 1, 2],\r\n            [3, 0, 2],\r\n            [4, 3, 2],\r\n            [4, 1, 0, 3],\r\n        ],\r\n    };\r\n    polyhedra[9] = {\r\n        vertex: [\r\n            [-0.868849, -0.100041, 0.61257],\r\n            [-0.329458, 0.976099, 0.28078],\r\n            [-0.26629, -0.013796, -0.477654],\r\n            [-0.13392, -1.034115, 0.229829],\r\n            [0.738834, 0.707117, -0.307018],\r\n            [0.859683, -0.535264, -0.338508],\r\n        ],\r\n        face: [\r\n            [3, 0, 2],\r\n            [5, 3, 2],\r\n            [4, 5, 2],\r\n            [1, 4, 2],\r\n            [0, 1, 2],\r\n            [0, 3, 5, 4, 1],\r\n        ],\r\n    };\r\n    polyhedra[10] = {\r\n        vertex: [\r\n            [-0.610389, 0.243975, 0.531213],\r\n            [-0.187812, -0.48795, -0.664016],\r\n            [-0.187812, 0.9759, -0.664016],\r\n            [0.187812, -0.9759, 0.664016],\r\n            [0.798201, 0.243975, 0.132803],\r\n        ],\r\n        face: [\r\n            [1, 3, 0],\r\n            [3, 4, 0],\r\n            [3, 1, 4],\r\n            [0, 2, 1],\r\n            [0, 4, 2],\r\n            [2, 4, 1],\r\n        ],\r\n    };\r\n    polyhedra[11] = {\r\n        vertex: [\r\n            [-1.028778, 0.392027, -0.048786],\r\n            [-0.640503, -0.646161, 0.621837],\r\n            [-0.125162, -0.395663, -0.540059],\r\n            [0.004683, 0.888447, -0.651988],\r\n            [0.125161, 0.395663, 0.540059],\r\n            [0.632925, -0.791376, 0.433102],\r\n            [1.031672, 0.157063, -0.354165],\r\n        ],\r\n        face: [\r\n            [3, 2, 0],\r\n            [2, 1, 0],\r\n            [2, 5, 1],\r\n            [0, 4, 3],\r\n            [0, 1, 4],\r\n            [4, 1, 5],\r\n            [2, 3, 6],\r\n            [3, 4, 6],\r\n            [5, 2, 6],\r\n            [4, 5, 6],\r\n        ],\r\n    };\r\n    polyhedra[12] = {\r\n        vertex: [\r\n            [-0.669867, 0.334933, -0.529576],\r\n            [-0.669867, 0.334933, 0.529577],\r\n            [-0.4043, 1.212901, 0],\r\n            [-0.334933, -0.669867, -0.529576],\r\n            [-0.334933, -0.669867, 0.529577],\r\n            [0.334933, 0.669867, -0.529576],\r\n            [0.334933, 0.669867, 0.529577],\r\n            [0.4043, -1.212901, 0],\r\n            [0.669867, -0.334933, -0.529576],\r\n            [0.669867, -0.334933, 0.529577],\r\n        ],\r\n        face: [\r\n            [8, 9, 7],\r\n            [6, 5, 2],\r\n            [3, 8, 7],\r\n            [5, 0, 2],\r\n            [4, 3, 7],\r\n            [0, 1, 2],\r\n            [9, 4, 7],\r\n            [1, 6, 2],\r\n            [9, 8, 5, 6],\r\n            [8, 3, 0, 5],\r\n            [3, 4, 1, 0],\r\n            [4, 9, 6, 1],\r\n        ],\r\n    };\r\n    polyhedra[13] = {\r\n        vertex: [\r\n            [-0.931836, 0.219976, -0.264632],\r\n            [-0.636706, 0.318353, 0.692816],\r\n            [-0.613483, -0.735083, -0.264632],\r\n            [-0.326545, 0.979634, 0],\r\n            [-0.318353, -0.636706, 0.692816],\r\n            [-0.159176, 0.477529, -0.856368],\r\n            [0.159176, -0.477529, -0.856368],\r\n            [0.318353, 0.636706, 0.692816],\r\n            [0.326545, -0.979634, 0],\r\n            [0.613482, 0.735082, -0.264632],\r\n            [0.636706, -0.318353, 0.692816],\r\n            [0.931835, -0.219977, -0.264632],\r\n        ],\r\n        face: [\r\n            [11, 10, 8],\r\n            [7, 9, 3],\r\n            [6, 11, 8],\r\n            [9, 5, 3],\r\n            [2, 6, 8],\r\n            [5, 0, 3],\r\n            [4, 2, 8],\r\n            [0, 1, 3],\r\n            [10, 4, 8],\r\n            [1, 7, 3],\r\n            [10, 11, 9, 7],\r\n            [11, 6, 5, 9],\r\n            [6, 2, 0, 5],\r\n            [2, 4, 1, 0],\r\n            [4, 10, 7, 1],\r\n        ],\r\n    };\r\n    polyhedra[14] = {\r\n        vertex: [\r\n            [-0.93465, 0.300459, -0.271185],\r\n            [-0.838689, -0.260219, -0.516017],\r\n            [-0.711319, 0.717591, 0.128359],\r\n            [-0.710334, -0.156922, 0.080946],\r\n            [-0.599799, 0.556003, -0.725148],\r\n            [-0.503838, -0.004675, -0.969981],\r\n            [-0.487004, 0.26021, 0.48049],\r\n            [-0.460089, -0.750282, -0.512622],\r\n            [-0.376468, 0.973135, -0.325605],\r\n            [-0.331735, -0.646985, 0.084342],\r\n            [-0.254001, 0.831847, 0.530001],\r\n            [-0.125239, -0.494738, -0.966586],\r\n            [0.029622, 0.027949, 0.730817],\r\n            [0.056536, -0.982543, -0.262295],\r\n            [0.08085, 1.087391, 0.076037],\r\n            [0.125583, -0.532729, 0.485984],\r\n            [0.262625, 0.599586, 0.780328],\r\n            [0.391387, -0.726999, -0.716259],\r\n            [0.513854, -0.868287, 0.139347],\r\n            [0.597475, 0.85513, 0.326364],\r\n            [0.641224, 0.109523, 0.783723],\r\n            [0.737185, -0.451155, 0.538891],\r\n            [0.848705, -0.612742, -0.314616],\r\n            [0.976075, 0.365067, 0.32976],\r\n            [1.072036, -0.19561, 0.084927],\r\n        ],\r\n        face: [\r\n            [15, 18, 21],\r\n            [12, 20, 16],\r\n            [6, 10, 2],\r\n            [3, 0, 1],\r\n            [9, 7, 13],\r\n            [2, 8, 4, 0],\r\n            [0, 4, 5, 1],\r\n            [1, 5, 11, 7],\r\n            [7, 11, 17, 13],\r\n            [13, 17, 22, 18],\r\n            [18, 22, 24, 21],\r\n            [21, 24, 23, 20],\r\n            [20, 23, 19, 16],\r\n            [16, 19, 14, 10],\r\n            [10, 14, 8, 2],\r\n            [15, 9, 13, 18],\r\n            [12, 15, 21, 20],\r\n            [6, 12, 16, 10],\r\n            [3, 6, 2, 0],\r\n            [9, 3, 1, 7],\r\n            [9, 15, 12, 6, 3],\r\n            [22, 17, 11, 5, 4, 8, 14, 19, 23, 24],\r\n        ],\r\n    };\r\n\r\n    const type: number = options.type && (options.type < 0 || options.type >= polyhedra.length) ? 0 : options.type || 0;\r\n    const size = options.size;\r\n    const sizeX: number = options.sizeX || size || 1;\r\n    const sizeY: number = options.sizeY || size || 1;\r\n    const sizeZ: number = options.sizeZ || size || 1;\r\n    const data: { vertex: number[][]; face: number[][]; name?: string; category?: string } = options.custom || polyhedra[type];\r\n    const nbfaces = data.face.length;\r\n    const faceUV = options.faceUV || new Array(nbfaces);\r\n    const faceColors = options.faceColors;\r\n    const flat = options.flat === undefined ? true : options.flat;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    const positions: number[] = [];\r\n    const indices: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n    const colors: number[] = [];\r\n    let index = 0;\r\n    let faceIdx = 0; // face cursor in the array \"indexes\"\r\n    const indexes: number[] = [];\r\n    let i = 0;\r\n    let f = 0;\r\n    let u: number, v: number, ang: number, x: number, y: number, tmp: number;\r\n\r\n    // default face colors and UV if undefined\r\n    if (flat) {\r\n        for (f = 0; f < nbfaces; f++) {\r\n            if (faceColors && faceColors[f] === undefined) {\r\n                faceColors[f] = new Color4(1, 1, 1, 1);\r\n            }\r\n            if (faceUV && faceUV[f] === undefined) {\r\n                faceUV[f] = new Vector4(0, 0, 1, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!flat) {\r\n        for (i = 0; i < data.vertex.length; i++) {\r\n            positions.push(data.vertex[i][0] * sizeX, data.vertex[i][1] * sizeY, data.vertex[i][2] * sizeZ);\r\n            uvs.push(0, useOpenGLOrientationForUV ? 1.0 : 0);\r\n        }\r\n        for (f = 0; f < nbfaces; f++) {\r\n            for (i = 0; i < data.face[f].length - 2; i++) {\r\n                indices.push(data.face[f][0], data.face[f][i + 2], data.face[f][i + 1]);\r\n            }\r\n        }\r\n    } else {\r\n        for (f = 0; f < nbfaces; f++) {\r\n            const fl = data.face[f].length; // number of vertices of the current face\r\n            ang = (2 * Math.PI) / fl;\r\n            x = 0.5 * Math.tan(ang / 2);\r\n            y = 0.5;\r\n\r\n            // positions, uvs, colors\r\n            for (i = 0; i < fl; i++) {\r\n                // positions\r\n                positions.push(data.vertex[data.face[f][i]][0] * sizeX, data.vertex[data.face[f][i]][1] * sizeY, data.vertex[data.face[f][i]][2] * sizeZ);\r\n                indexes.push(index);\r\n                index++;\r\n                // uvs\r\n                u = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * (0.5 + x);\r\n                v = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * (y - 0.5);\r\n                uvs.push(u, useOpenGLOrientationForUV ? 1.0 - v : v);\r\n                tmp = x * Math.cos(ang) - y * Math.sin(ang);\r\n                y = x * Math.sin(ang) + y * Math.cos(ang);\r\n                x = tmp;\r\n                // colors\r\n                if (faceColors) {\r\n                    colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);\r\n                }\r\n            }\r\n\r\n            // indices from indexes\r\n            for (i = 0; i < fl - 2; i++) {\r\n                indices.push(indexes[0 + faceIdx], indexes[i + 2 + faceIdx], indexes[i + 1 + faceIdx]);\r\n            }\r\n            faceIdx += fl;\r\n        }\r\n    }\r\n\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    const vertexData = new VertexData();\r\n    vertexData.positions = positions;\r\n    vertexData.indices = indices;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    if (faceColors && flat) {\r\n        vertexData.colors = colors;\r\n    }\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a polyhedron mesh\r\n * * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial to choose the wanted type\r\n * * The parameter `size` (positive float, default 1) sets the polygon size\r\n * * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)\r\n * * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overrides the parameter `type`\r\n * * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron\r\n * * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)\r\n * * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : https://doc.babylonjs.com/features/featuresDeepDive/materials/using/texturePerBoxFace\r\n * * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the polyhedron mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/polyhedra\r\n */\r\nexport function CreatePolyhedron(\r\n    name: string,\r\n    options: {\r\n        type?: number;\r\n        size?: number;\r\n        sizeX?: number;\r\n        sizeY?: number;\r\n        sizeZ?: number;\r\n        custom?: any;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        flat?: boolean;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const polyhedron = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    polyhedron._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreatePolyhedronVertexData(options);\r\n\r\n    vertexData.applyToMesh(polyhedron, options.updatable);\r\n\r\n    return polyhedron;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function directly from the module\r\n */\r\nexport const PolyhedronBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreatePolyhedron,\r\n};\r\n\r\nVertexData.CreatePolyhedron = CreatePolyhedronVertexData;\r\n\r\nMesh.CreatePolyhedron = (\r\n    name: string,\r\n    options: {\r\n        type?: number;\r\n        size?: number;\r\n        sizeX?: number;\r\n        sizeY?: number;\r\n        sizeZ?: number;\r\n        custom?: any;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n    },\r\n    scene: Scene\r\n): Mesh => {\r\n    return CreatePolyhedron(name, options, scene);\r\n};\r\n", "import type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { useOpenGLOrientationForUV } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData of the IcoSphere\r\n * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\r\n * * radius the radius of the IcoSphere, optional default 1\r\n * * radiusX allows stretching in the x direction, optional, default radius\r\n * * radiusY allows stretching in the y direction, optional, default radius\r\n * * radiusZ allows stretching in the z direction, optional, default radius\r\n * * flat when true creates a flat shaded mesh, optional, default true\r\n * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @returns the VertexData of the IcoSphere\r\n */\r\nexport function CreateIcoSphereVertexData(options: {\r\n    radius?: number;\r\n    radiusX?: number;\r\n    radiusY?: number;\r\n    radiusZ?: number;\r\n    flat?: boolean;\r\n    subdivisions?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const sideOrientation = options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const radius = options.radius || 1;\r\n    const flat = options.flat === undefined ? true : options.flat;\r\n    const subdivisions = (options.subdivisions || 4) | 0;\r\n    const radiusX = options.radiusX || radius;\r\n    const radiusY = options.radiusY || radius;\r\n    const radiusZ = options.radiusZ || radius;\r\n\r\n    const t = (1 + Math.sqrt(5)) / 2;\r\n\r\n    // 12 vertex x,y,z\r\n    const icoVertices = [\r\n        -1,\r\n        t,\r\n        -0,\r\n        1,\r\n        t,\r\n        0,\r\n        -1,\r\n        -t,\r\n        0,\r\n        1,\r\n        -t,\r\n        0, // v0-3\r\n        0,\r\n        -1,\r\n        -t,\r\n        0,\r\n        1,\r\n        -t,\r\n        0,\r\n        -1,\r\n        t,\r\n        0,\r\n        1,\r\n        t, // v4-7\r\n        t,\r\n        0,\r\n        1,\r\n        t,\r\n        0,\r\n        -1,\r\n        -t,\r\n        0,\r\n        1,\r\n        -t,\r\n        0,\r\n        -1, // v8-11\r\n    ];\r\n\r\n    // index of 3 vertex makes a face of icopshere\r\n    const ico_indices = [\r\n        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 12, 22, 23, 1, 5, 20, 5, 11, 4, 23, 22, 13, 22, 18, 6, 7, 1, 8, 14, 21, 4, 14, 4, 2, 16, 13, 6, 15, 6, 19, 3, 8, 9, 4, 21, 5, 13, 17,\r\n        23, 6, 13, 22, 19, 6, 18, 9, 8, 1,\r\n    ];\r\n    // vertex for uv have aliased position, not for UV\r\n    const vertices_unalias_id = [\r\n        0,\r\n        1,\r\n        2,\r\n        3,\r\n        4,\r\n        5,\r\n        6,\r\n        7,\r\n        8,\r\n        9,\r\n        10,\r\n        11,\r\n        // vertex alias\r\n        0, // 12: 0 + 12\r\n        2, // 13: 2 + 11\r\n        3, // 14: 3 + 11\r\n        3, // 15: 3 + 12\r\n        3, // 16: 3 + 13\r\n        4, // 17: 4 + 13\r\n        7, // 18: 7 + 11\r\n        8, // 19: 8 + 11\r\n        9, // 20: 9 + 11\r\n        9, // 21: 9 + 12\r\n        10, // 22: A + 12\r\n        11, // 23: B + 12\r\n    ];\r\n\r\n    // uv as integer step (not pixels !)\r\n    const ico_vertexuv = [\r\n        5,\r\n        1,\r\n        3,\r\n        1,\r\n        6,\r\n        4,\r\n        0,\r\n        0, // v0-3\r\n        5,\r\n        3,\r\n        4,\r\n        2,\r\n        2,\r\n        2,\r\n        4,\r\n        0, // v4-7\r\n        2,\r\n        0,\r\n        1,\r\n        1,\r\n        6,\r\n        0,\r\n        6,\r\n        2, // v8-11\r\n        // vertex alias (for same vertex on different faces)\r\n        0,\r\n        4, // 12: 0 + 12\r\n        3,\r\n        3, // 13: 2 + 11\r\n        4,\r\n        4, // 14: 3 + 11\r\n        3,\r\n        1, // 15: 3 + 12\r\n        4,\r\n        2, // 16: 3 + 13\r\n        4,\r\n        4, // 17: 4 + 13\r\n        0,\r\n        2, // 18: 7 + 11\r\n        1,\r\n        1, // 19: 8 + 11\r\n        2,\r\n        2, // 20: 9 + 11\r\n        3,\r\n        3, // 21: 9 + 12\r\n        1,\r\n        3, // 22: A + 12\r\n        2,\r\n        4, // 23: B + 12\r\n    ];\r\n\r\n    // Vertices[0, 1, ...9, A, B] : position on UV plane\r\n    // '+' indicate duplicate position to be fixed (3,9:0,2,3,4,7,8,A,B)\r\n    // First island of uv mapping\r\n    // v = 4h          3+  2\r\n    // v = 3h        9+  4\r\n    // v = 2h      9+  5   B\r\n    // v = 1h    9   1   0\r\n    // v = 0h  3   8   7   A\r\n    //     u = 0 1 2 3 4 5 6  *a\r\n\r\n    // Second island of uv mapping\r\n    // v = 4h  0+  B+  4+\r\n    // v = 3h    A+  2+\r\n    // v = 2h  7+  6   3+\r\n    // v = 1h    8+  3+\r\n    // v = 0h\r\n    //     u = 0 1 2 3 4 5 6  *a\r\n\r\n    // Face layout on texture UV mapping\r\n    // ============\r\n    // \\ 4  /\\ 16 /   ======\r\n    //  \\  /  \\  /   /\\ 11 /\r\n    //   \\/ 7  \\/   /  \\  /\r\n    //    =======  / 10 \\/\r\n    //   /\\ 17 /\\  =======\r\n    //  /  \\  /  \\ \\ 15 /\\\r\n    // / 8  \\/ 12 \\ \\  /  \\\r\n    // ============  \\/ 6  \\\r\n    // \\ 18 /\\  ============\r\n    //  \\  /  \\ \\ 5  /\\ 0  /\r\n    //   \\/ 13 \\ \\  /  \\  /\r\n    //   =======  \\/ 1  \\/\r\n    //       =============\r\n    //      /\\ 19 /\\  2 /\\\r\n    //     /  \\  /  \\  /  \\\r\n    //    / 14 \\/ 9  \\/  3 \\\r\n    //   ===================\r\n\r\n    // uv step is u:1 or 0.5, v:cos(30)=sqrt(3)/2, ratio approx is 84/97\r\n    const ustep = 138 / 1024;\r\n    const vstep = 239 / 1024;\r\n    const uoffset = 60 / 1024;\r\n    const voffset = 26 / 1024;\r\n    // Second island should have margin, not to touch the first island\r\n    // avoid any borderline artefact in pixel rounding\r\n    const island_u_offset = -40 / 1024;\r\n    const island_v_offset = +20 / 1024;\r\n    // face is either island 0 or 1 :\r\n    // second island is for faces : [4, 7, 8, 12, 13, 16, 17, 18]\r\n    const island = [\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        1, //  0 - 4\r\n        0,\r\n        0,\r\n        1,\r\n        1,\r\n        0, //  5 - 9\r\n        0,\r\n        0,\r\n        1,\r\n        1,\r\n        0, //  10 - 14\r\n        0,\r\n        1,\r\n        1,\r\n        1,\r\n        0, //  15 - 19\r\n    ];\r\n\r\n    const indices: number[] = [];\r\n    const positions: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n\r\n    let current_indice = 0;\r\n    // prepare array of 3 vector (empty) (to be worked in place, shared for each face)\r\n    const face_vertex_pos = new Array(3);\r\n    const face_vertex_uv = new Array(3);\r\n    let v012;\r\n    for (v012 = 0; v012 < 3; v012++) {\r\n        face_vertex_pos[v012] = Vector3.Zero();\r\n        face_vertex_uv[v012] = Vector2.Zero();\r\n    }\r\n    // create all with normals\r\n    for (let face = 0; face < 20; face++) {\r\n        // 3 vertex per face\r\n        for (v012 = 0; v012 < 3; v012++) {\r\n            // look up vertex 0,1,2 to its index in 0 to 11 (or 23 including alias)\r\n            const v_id = ico_indices[3 * face + v012];\r\n            // vertex have 3D position (x,y,z)\r\n            face_vertex_pos[v012].copyFromFloats(\r\n                icoVertices[3 * vertices_unalias_id[v_id]],\r\n                icoVertices[3 * vertices_unalias_id[v_id] + 1],\r\n                icoVertices[3 * vertices_unalias_id[v_id] + 2]\r\n            );\r\n            // Normalize to get normal\r\n            face_vertex_pos[v012].normalize();\r\n\r\n            // uv Coordinates from vertex ID\r\n            face_vertex_uv[v012].copyFromFloats(\r\n                ico_vertexuv[2 * v_id] * ustep + uoffset + island[face] * island_u_offset,\r\n                ico_vertexuv[2 * v_id + 1] * vstep + voffset + island[face] * island_v_offset\r\n            );\r\n        }\r\n\r\n        // Subdivide the face (interpolate pos, norm, uv)\r\n        // - pos is linear interpolation, then projected to sphere (converge polyhedron to sphere)\r\n        // - norm is linear interpolation of vertex corner normal\r\n        //   (to be checked if better to re-calc from face vertex, or if approximation is OK ??? )\r\n        // - uv is linear interpolation\r\n        //\r\n        // Topology is as below for sub-divide by 2\r\n        // vertex shown as v0,v1,v2\r\n        // interp index is i1 to progress in range [v0,v1[\r\n        // interp index is i2 to progress in range [v0,v2[\r\n        // face index as  (i1,i2)  for /\\  : (i1,i2),(i1+1,i2),(i1,i2+1)\r\n        //            and (i1,i2)' for \\/  : (i1+1,i2),(i1+1,i2+1),(i1,i2+1)\r\n        //\r\n        //\r\n        //                    i2    v2\r\n        //                    ^    ^\r\n        //                   /    / \\\r\n        //                  /    /   \\\r\n        //                 /    /     \\\r\n        //                /    / (0,1) \\\r\n        //               /    #---------\\\r\n        //              /    / \\ (0,0)'/ \\\r\n        //             /    /   \\     /   \\\r\n        //            /    /     \\   /     \\\r\n        //           /    / (0,0) \\ / (1,0) \\\r\n        //          /    #---------#---------\\\r\n        //              v0                    v1\r\n        //\r\n        //              --------------------> i1\r\n        //\r\n        // interp of (i1,i2):\r\n        //  along i2 :  x0=lerp(v0,v2, i2/S) <---> x1=lerp(v1,v2, i2/S)\r\n        //  along i1 :  lerp(x0,x1, i1/(S-i2))\r\n        //\r\n        // centroid of triangle is needed to get help normal computation\r\n        //  (c1,c2) are used for centroid location\r\n\r\n        const interp_vertex = (i1: number, i2: number, c1: number, c2: number) => {\r\n            // vertex is interpolated from\r\n            //   - face_vertex_pos[0..2]\r\n            //   - face_vertex_uv[0..2]\r\n            const pos_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], i2 / subdivisions);\r\n            const pos_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], i2 / subdivisions);\r\n            const pos_interp = subdivisions === i2 ? face_vertex_pos[2] : Vector3.Lerp(pos_x0, pos_x1, i1 / (subdivisions - i2));\r\n            pos_interp.normalize();\r\n\r\n            let vertex_normal;\r\n            if (flat) {\r\n                // in flat mode, recalculate normal as face centroid normal\r\n                const centroid_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], c2 / subdivisions);\r\n                const centroid_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], c2 / subdivisions);\r\n                vertex_normal = Vector3.Lerp(centroid_x0, centroid_x1, c1 / (subdivisions - c2));\r\n            } else {\r\n                // in smooth mode, recalculate normal from each single vertex position\r\n                vertex_normal = new Vector3(pos_interp.x, pos_interp.y, pos_interp.z);\r\n            }\r\n            // Vertex normal need correction due to X,Y,Z radius scaling\r\n            vertex_normal.x /= radiusX;\r\n            vertex_normal.y /= radiusY;\r\n            vertex_normal.z /= radiusZ;\r\n            vertex_normal.normalize();\r\n\r\n            const uv_x0 = Vector2.Lerp(face_vertex_uv[0], face_vertex_uv[2], i2 / subdivisions);\r\n            const uv_x1 = Vector2.Lerp(face_vertex_uv[1], face_vertex_uv[2], i2 / subdivisions);\r\n            const uv_interp = subdivisions === i2 ? face_vertex_uv[2] : Vector2.Lerp(uv_x0, uv_x1, i1 / (subdivisions - i2));\r\n            positions.push(pos_interp.x * radiusX, pos_interp.y * radiusY, pos_interp.z * radiusZ);\r\n            normals.push(vertex_normal.x, vertex_normal.y, vertex_normal.z);\r\n            uvs.push(uv_interp.x, useOpenGLOrientationForUV ? 1.0 - uv_interp.y : uv_interp.y);\r\n            // push each vertex has member of a face\r\n            // Same vertex can belong to multiple face, it is pushed multiple time (duplicate vertex are present)\r\n            indices.push(current_indice);\r\n            current_indice++;\r\n        };\r\n\r\n        for (let i2 = 0; i2 < subdivisions; i2++) {\r\n            for (let i1 = 0; i1 + i2 < subdivisions; i1++) {\r\n                // face : (i1,i2)  for /\\  :\r\n                // interp for : (i1,i2),(i1+1,i2),(i1,i2+1)\r\n                interp_vertex(i1, i2, i1 + 1.0 / 3, i2 + 1.0 / 3);\r\n                interp_vertex(i1 + 1, i2, i1 + 1.0 / 3, i2 + 1.0 / 3);\r\n                interp_vertex(i1, i2 + 1, i1 + 1.0 / 3, i2 + 1.0 / 3);\r\n                if (i1 + i2 + 1 < subdivisions) {\r\n                    // face : (i1,i2)' for \\/  :\r\n                    // interp for (i1+1,i2),(i1+1,i2+1),(i1,i2+1)\r\n                    interp_vertex(i1 + 1, i2, i1 + 2.0 / 3, i2 + 2.0 / 3);\r\n                    interp_vertex(i1 + 1, i2 + 1, i1 + 2.0 / 3, i2 + 2.0 / 3);\r\n                    interp_vertex(i1, i2 + 1, i1 + 2.0 / 3, i2 + 2.0 / 3);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided\r\n * * The parameter `radius` sets the radius size (float) of the icosphere (default 1)\r\n * * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value of `radius`)\r\n * * The parameter `subdivisions` sets the number of subdivisions (positive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size\r\n * * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the icosahedron mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/polyhedra#icosphere\r\n */\r\nexport function CreateIcoSphere(\r\n    name: string,\r\n    options: {\r\n        radius?: number;\r\n        radiusX?: number;\r\n        radiusY?: number;\r\n        radiusZ?: number;\r\n        flat?: boolean;\r\n        subdivisions?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        updatable?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const sphere = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    sphere._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateIcoSphereVertexData(options);\r\n\r\n    vertexData.applyToMesh(sphere, options.updatable);\r\n\r\n    return sphere;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function directly from the module\r\n */\r\nexport const IcoSphereBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateIcoSphere,\r\n};\r\n\r\nVertexData.CreateIcoSphere = CreateIcoSphereVertexData;\r\n\r\nMesh.CreateIcoSphere = (name: string, options: { radius?: number; flat?: boolean; subdivisions?: number; sideOrientation?: number; updatable?: boolean }, scene: Scene): Mesh => {\r\n    return CreateIcoSphere(name, options, scene);\r\n};\r\n", "import type { Nullable, IndicesArray, FloatArray } from \"../../types\";\r\nimport { Vector3, Matrix, Vector2, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Lerp } from \"../../Maths/math.scalar.functions\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { AbstractMesh } from \"../abstractMesh\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport { useOpenGLOrientationForUV } from \"../../Compat/compatibilityOptions\";\r\n\r\nconst xpAxis = new Vector3(1, 0, 0);\r\nconst xnAxis = new Vector3(-1, 0, 0);\r\nconst ypAxis = new Vector3(0, 1, 0);\r\nconst ynAxis = new Vector3(0, -1, 0);\r\nconst zpAxis = new Vector3(0, 0, 1);\r\nconst znAxis = new Vector3(0, 0, -1);\r\n\r\n/** @internal */\r\nclass DecalVertex {\r\n    constructor(\r\n        public position: Vector3 = Vector3.Zero(),\r\n        public normal: Vector3 = Vector3.Up(),\r\n        public uv: Vector2 = Vector2.Zero(),\r\n        public vertexIdx: number = 0,\r\n        public vertexIdxForBones: number = 0,\r\n        public localPositionOverride: Nullable<number[]> = null,\r\n        public localNormalOverride: Nullable<number[]> = null,\r\n        public matrixIndicesOverride: Nullable<number[]> = null,\r\n        public matrixWeightsOverride: Nullable<number[]> = null\r\n    ) {}\r\n    public clone(): DecalVertex {\r\n        return new DecalVertex(\r\n            this.position.clone(),\r\n            this.normal.clone(),\r\n            this.uv.clone(),\r\n            this.vertexIdx,\r\n            this.vertexIdxForBones,\r\n            this.localPositionOverride?.slice(),\r\n            this.localNormalOverride?.slice(),\r\n            this.matrixIndicesOverride?.slice(),\r\n            this.matrixWeightsOverride?.slice()\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a decal mesh.\r\n * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal\r\n * * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates\r\n * * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates\r\n * * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling\r\n * * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal\r\n * * The parameter `captureUVS` defines if we need to capture the uvs or compute them\r\n * * The parameter `cullBackFaces` defines if the back faces should be removed from the decal mesh\r\n * * The parameter `localMode` defines that the computations should be done with the local mesh coordinates instead of the world space coordinates.\r\n * *    Use this mode if you want the decal to be parented to the sourceMesh and move/rotate with it.\r\n * Note: Meshes with morph targets are not supported!\r\n * @param name defines the name of the mesh\r\n * @param sourceMesh defines the mesh where the decal must be applied\r\n * @param options defines the options used to create the mesh\r\n * @returns the decal mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/decals\r\n */\r\nexport function CreateDecal(\r\n    name: string,\r\n    sourceMesh: AbstractMesh,\r\n    options: { position?: Vector3; normal?: Vector3; size?: Vector3; angle?: number; captureUVS?: boolean; cullBackFaces?: boolean; localMode?: boolean }\r\n): Mesh {\r\n    const hasSkeleton = !!sourceMesh.skeleton;\r\n    const useLocalComputation = options.localMode || hasSkeleton;\r\n\r\n    const indices = <IndicesArray>sourceMesh.getIndices();\r\n    const positions = hasSkeleton ? sourceMesh.getPositionData(true, true) : sourceMesh.getVerticesData(VertexBuffer.PositionKind);\r\n    const normals = hasSkeleton ? sourceMesh.getNormalsData(true, true) : sourceMesh.getVerticesData(VertexBuffer.NormalKind);\r\n    const localPositions = useLocalComputation ? (hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.PositionKind) : positions) : null;\r\n    const localNormals = useLocalComputation ? (hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.NormalKind) : normals) : null;\r\n    const uvs = sourceMesh.getVerticesData(VertexBuffer.UVKind);\r\n    const matIndices = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesKind) : null;\r\n    const matWeights = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsKind) : null;\r\n    const matIndicesExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\r\n    const matWeightsExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\r\n\r\n    const position = options.position || Vector3.Zero();\r\n    let normal = options.normal || Vector3.Up();\r\n    const size = options.size || Vector3.One();\r\n    const angle = options.angle || 0;\r\n\r\n    // Getting correct rotation\r\n    if (!normal) {\r\n        const target = new Vector3(0, 0, 1);\r\n        const camera = <Camera>sourceMesh.getScene().activeCamera;\r\n        const cameraWorldTarget = Vector3.TransformCoordinates(target, camera.getWorldMatrix());\r\n\r\n        normal = camera.globalPosition.subtract(cameraWorldTarget);\r\n    }\r\n\r\n    const yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;\r\n    const len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);\r\n    const pitch = Math.atan2(normal.y, len);\r\n\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = [];\r\n    vertexData.positions = [];\r\n    vertexData.normals = [];\r\n    vertexData.uvs = [];\r\n    vertexData.matricesIndices = hasSkeleton ? [] : null;\r\n    vertexData.matricesWeights = hasSkeleton ? [] : null;\r\n    vertexData.matricesIndicesExtra = matIndicesExtra ? [] : null;\r\n    vertexData.matricesWeightsExtra = matWeightsExtra ? [] : null;\r\n\r\n    let currentVertexDataIndex = 0;\r\n\r\n    const extractDecalVector3 = (indexId: number, transformMatrix: Matrix): DecalVertex => {\r\n        const result = new DecalVertex();\r\n        if (!indices || !positions || !normals) {\r\n            return result;\r\n        }\r\n\r\n        const vertexId = indices[indexId];\r\n\r\n        result.vertexIdx = vertexId * 3;\r\n        result.vertexIdxForBones = vertexId * 4;\r\n\r\n        // Send vector to decal local world\r\n        result.position = new Vector3(positions[vertexId * 3], positions[vertexId * 3 + 1], positions[vertexId * 3 + 2]);\r\n        Vector3.TransformCoordinatesToRef(result.position, transformMatrix, result.position);\r\n\r\n        // Get normal\r\n        result.normal = new Vector3(normals[vertexId * 3], normals[vertexId * 3 + 1], normals[vertexId * 3 + 2]);\r\n        Vector3.TransformNormalToRef(result.normal, transformMatrix, result.normal);\r\n\r\n        if (options.captureUVS && uvs) {\r\n            const v = uvs[vertexId * 2 + 1];\r\n            result.uv = new Vector2(uvs[vertexId * 2], useOpenGLOrientationForUV ? 1 - v : v);\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    const emptyArray = [0, 0, 0, 0];\r\n\r\n    // Inspired by https://github.com/mrdoob/three.js/blob/eee231960882f6f3b6113405f524956145148146/examples/js/geometries/DecalGeometry.js\r\n    const clip = (vertices: DecalVertex[], axis: Vector3): Nullable<DecalVertex[]> => {\r\n        if (vertices.length === 0) {\r\n            return vertices;\r\n        }\r\n\r\n        const clipSize = 0.5 * Math.abs(Vector3.Dot(size, axis));\r\n\r\n        const indexOf = (arr: FloatArray | number[], val: number, start: number, num: number) => {\r\n            for (let i = 0; i < num; ++i) {\r\n                if (arr[start + i] === val) {\r\n                    return start + i;\r\n                }\r\n            }\r\n            return -1;\r\n        };\r\n\r\n        const clipVertices = (v0: DecalVertex, v1: DecalVertex): DecalVertex => {\r\n            const clipFactor = Vector3.GetClipFactor(v0.position, v1.position, axis, clipSize);\r\n\r\n            let indices = emptyArray;\r\n            let weights = emptyArray;\r\n\r\n            if (matIndices && matWeights) {\r\n                const mat0Index = v0.matrixIndicesOverride ? 0 : v0.vertexIdxForBones;\r\n                const v0Indices = v0.matrixIndicesOverride ?? matIndices;\r\n                const v0Weights = v0.matrixWeightsOverride ?? matWeights;\r\n\r\n                const mat1Index = v1.matrixIndicesOverride ? 0 : v1.vertexIdxForBones;\r\n                const v1Indices = v1.matrixIndicesOverride ?? matIndices;\r\n                const v1Weights = v1.matrixWeightsOverride ?? matWeights;\r\n\r\n                indices = [0, 0, 0, 0];\r\n                weights = [0, 0, 0, 0];\r\n\r\n                let index = 0;\r\n                for (let i = 0; i < 4; ++i) {\r\n                    if (v0Weights[mat0Index + i] > 0) {\r\n                        const idx = indexOf(v1Indices, v0Indices[mat0Index + i], mat1Index, 4);\r\n                        indices[index] = v0Indices[mat0Index + i];\r\n                        weights[index] = Lerp(v0Weights[mat0Index + i], idx >= 0 ? v1Weights[idx] : 0, clipFactor);\r\n                        index++;\r\n                    }\r\n                }\r\n\r\n                for (let i = 0; i < 4 && index < 4; ++i) {\r\n                    const ind = v1Indices[mat1Index + i];\r\n                    if (indexOf(v0Indices, ind, mat0Index, 4) !== -1) continue;\r\n\r\n                    indices[index] = ind;\r\n                    weights[index] = Lerp(0, v1Weights[mat1Index + i], clipFactor);\r\n                    index++;\r\n                }\r\n\r\n                const sumw = weights[0] + weights[1] + weights[2] + weights[3];\r\n\r\n                weights[0] /= sumw;\r\n                weights[1] /= sumw;\r\n                weights[2] /= sumw;\r\n                weights[3] /= sumw;\r\n            }\r\n\r\n            const v0LocalPositionX = v0.localPositionOverride ? v0.localPositionOverride[0] : (localPositions?.[v0.vertexIdx] ?? 0);\r\n            const v0LocalPositionY = v0.localPositionOverride ? v0.localPositionOverride[1] : (localPositions?.[v0.vertexIdx + 1] ?? 0);\r\n            const v0LocalPositionZ = v0.localPositionOverride ? v0.localPositionOverride[2] : (localPositions?.[v0.vertexIdx + 2] ?? 0);\r\n\r\n            const v1LocalPositionX = v1.localPositionOverride ? v1.localPositionOverride[0] : (localPositions?.[v1.vertexIdx] ?? 0);\r\n            const v1LocalPositionY = v1.localPositionOverride ? v1.localPositionOverride[1] : (localPositions?.[v1.vertexIdx + 1] ?? 0);\r\n            const v1LocalPositionZ = v1.localPositionOverride ? v1.localPositionOverride[2] : (localPositions?.[v1.vertexIdx + 2] ?? 0);\r\n\r\n            const v0LocalNormalX = v0.localNormalOverride ? v0.localNormalOverride[0] : (localNormals?.[v0.vertexIdx] ?? 0);\r\n            const v0LocalNormalY = v0.localNormalOverride ? v0.localNormalOverride[1] : (localNormals?.[v0.vertexIdx + 1] ?? 0);\r\n            const v0LocalNormalZ = v0.localNormalOverride ? v0.localNormalOverride[2] : (localNormals?.[v0.vertexIdx + 2] ?? 0);\r\n\r\n            const v1LocalNormalX = v1.localNormalOverride ? v1.localNormalOverride[0] : (localNormals?.[v1.vertexIdx] ?? 0);\r\n            const v1LocalNormalY = v1.localNormalOverride ? v1.localNormalOverride[1] : (localNormals?.[v1.vertexIdx + 1] ?? 0);\r\n            const v1LocalNormalZ = v1.localNormalOverride ? v1.localNormalOverride[2] : (localNormals?.[v1.vertexIdx + 2] ?? 0);\r\n\r\n            const interpNormalX = v0LocalNormalX + (v1LocalNormalX - v0LocalNormalX) * clipFactor;\r\n            const interpNormalY = v0LocalNormalY + (v1LocalNormalY - v0LocalNormalY) * clipFactor;\r\n            const interpNormalZ = v0LocalNormalZ + (v1LocalNormalZ - v0LocalNormalZ) * clipFactor;\r\n\r\n            const norm = Math.sqrt(interpNormalX * interpNormalX + interpNormalY * interpNormalY + interpNormalZ * interpNormalZ);\r\n\r\n            return new DecalVertex(\r\n                Vector3.Lerp(v0.position, v1.position, clipFactor),\r\n                Vector3.Lerp(v0.normal, v1.normal, clipFactor).normalize(),\r\n                Vector2.Lerp(v0.uv, v1.uv, clipFactor),\r\n                -1,\r\n                -1,\r\n                localPositions\r\n                    ? [\r\n                          v0LocalPositionX + (v1LocalPositionX - v0LocalPositionX) * clipFactor,\r\n                          v0LocalPositionY + (v1LocalPositionY - v0LocalPositionY) * clipFactor,\r\n                          v0LocalPositionZ + (v1LocalPositionZ - v0LocalPositionZ) * clipFactor,\r\n                      ]\r\n                    : null,\r\n                localNormals ? [interpNormalX / norm, interpNormalY / norm, interpNormalZ / norm] : null,\r\n                indices,\r\n                weights\r\n            );\r\n        };\r\n\r\n        let clipResult: Nullable<DecalVertex[]> = null;\r\n\r\n        if (vertices.length > 3) {\r\n            clipResult = [] as DecalVertex[];\r\n        }\r\n\r\n        for (let index = 0; index < vertices.length; index += 3) {\r\n            let total = 0;\r\n            let nV1: Nullable<DecalVertex> = null;\r\n            let nV2: Nullable<DecalVertex> = null;\r\n            let nV3: Nullable<DecalVertex> = null;\r\n            let nV4: Nullable<DecalVertex> = null;\r\n\r\n            const d1 = Vector3.Dot(vertices[index].position, axis) - clipSize;\r\n            const d2 = Vector3.Dot(vertices[index + 1].position, axis) - clipSize;\r\n            const d3 = Vector3.Dot(vertices[index + 2].position, axis) - clipSize;\r\n\r\n            const v1Out = d1 > 0;\r\n            const v2Out = d2 > 0;\r\n            const v3Out = d3 > 0;\r\n\r\n            total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\r\n\r\n            switch (total) {\r\n                case 0:\r\n                    if (vertices.length > 3) {\r\n                        clipResult!.push(vertices[index]);\r\n                        clipResult!.push(vertices[index + 1]);\r\n                        clipResult!.push(vertices[index + 2]);\r\n                    } else {\r\n                        clipResult = vertices;\r\n                    }\r\n                    break;\r\n                case 1:\r\n                    clipResult = clipResult ?? new Array<DecalVertex>();\r\n                    if (v1Out) {\r\n                        nV1 = vertices[index + 1];\r\n                        nV2 = vertices[index + 2];\r\n                        nV3 = clipVertices(vertices[index], nV1);\r\n                        nV4 = clipVertices(vertices[index], nV2);\r\n                    }\r\n\r\n                    if (v2Out) {\r\n                        nV1 = vertices[index];\r\n                        nV2 = vertices[index + 2];\r\n                        nV3 = clipVertices(vertices[index + 1], nV1);\r\n                        nV4 = clipVertices(vertices[index + 1], nV2);\r\n\r\n                        clipResult.push(nV3);\r\n                        clipResult.push(nV2.clone());\r\n                        clipResult.push(nV1.clone());\r\n\r\n                        clipResult.push(nV2.clone());\r\n                        clipResult.push(nV3.clone());\r\n                        clipResult.push(nV4);\r\n                        break;\r\n                    }\r\n                    if (v3Out) {\r\n                        nV1 = vertices[index];\r\n                        nV2 = vertices[index + 1];\r\n                        nV3 = clipVertices(vertices[index + 2], nV1);\r\n                        nV4 = clipVertices(vertices[index + 2], nV2);\r\n                    }\r\n\r\n                    if (nV1 && nV2 && nV3 && nV4) {\r\n                        clipResult.push(nV1.clone());\r\n                        clipResult.push(nV2.clone());\r\n                        clipResult.push(nV3);\r\n\r\n                        clipResult.push(nV4);\r\n                        clipResult.push(nV3.clone());\r\n                        clipResult.push(nV2.clone());\r\n                    }\r\n                    break;\r\n                case 2:\r\n                    clipResult = clipResult ?? new Array<DecalVertex>();\r\n                    if (!v1Out) {\r\n                        nV1 = vertices[index].clone();\r\n                        nV2 = clipVertices(nV1, vertices[index + 1]);\r\n                        nV3 = clipVertices(nV1, vertices[index + 2]);\r\n                        clipResult.push(nV1);\r\n                        clipResult.push(nV2);\r\n                        clipResult.push(nV3);\r\n                    }\r\n                    if (!v2Out) {\r\n                        nV1 = vertices[index + 1].clone();\r\n                        nV2 = clipVertices(nV1, vertices[index + 2]);\r\n                        nV3 = clipVertices(nV1, vertices[index]);\r\n                        clipResult.push(nV1);\r\n                        clipResult.push(nV2);\r\n                        clipResult.push(nV3);\r\n                    }\r\n                    if (!v3Out) {\r\n                        nV1 = vertices[index + 2].clone();\r\n                        nV2 = clipVertices(nV1, vertices[index]);\r\n                        nV3 = clipVertices(nV1, vertices[index + 1]);\r\n                        clipResult.push(nV1);\r\n                        clipResult.push(nV2);\r\n                        clipResult.push(nV3);\r\n                    }\r\n                    break;\r\n                case 3:\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return clipResult;\r\n    };\r\n\r\n    const sourceMeshAsMesh = sourceMesh instanceof Mesh ? sourceMesh : null;\r\n    const matrixData = sourceMeshAsMesh?._thinInstanceDataStorage.matrixData;\r\n\r\n    const numMatrices = sourceMeshAsMesh?.thinInstanceCount || 1;\r\n    const thinInstanceMatrix = TmpVectors.Matrix[0];\r\n\r\n    thinInstanceMatrix.copyFrom(Matrix.IdentityReadOnly);\r\n\r\n    for (let m = 0; m < numMatrices; ++m) {\r\n        if (sourceMeshAsMesh?.hasThinInstances && matrixData) {\r\n            const ofst = m * 16;\r\n\r\n            thinInstanceMatrix.setRowFromFloats(0, matrixData[ofst + 0], matrixData[ofst + 1], matrixData[ofst + 2], matrixData[ofst + 3]);\r\n            thinInstanceMatrix.setRowFromFloats(1, matrixData[ofst + 4], matrixData[ofst + 5], matrixData[ofst + 6], matrixData[ofst + 7]);\r\n            thinInstanceMatrix.setRowFromFloats(2, matrixData[ofst + 8], matrixData[ofst + 9], matrixData[ofst + 10], matrixData[ofst + 11]);\r\n            thinInstanceMatrix.setRowFromFloats(3, matrixData[ofst + 12], matrixData[ofst + 13], matrixData[ofst + 14], matrixData[ofst + 15]);\r\n        }\r\n\r\n        // Matrix\r\n        const decalWorldMatrix = Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(Matrix.Translation(position.x, position.y, position.z));\r\n        const inverseDecalWorldMatrix = Matrix.Invert(decalWorldMatrix);\r\n        const meshWorldMatrix = sourceMesh.getWorldMatrix();\r\n        const transformMatrix = thinInstanceMatrix.multiply(meshWorldMatrix).multiply(inverseDecalWorldMatrix);\r\n\r\n        const oneFaceVertices = new Array<DecalVertex>(3);\r\n\r\n        for (let index = 0; index < indices.length; index += 3) {\r\n            let faceVertices: Nullable<DecalVertex[]> = oneFaceVertices;\r\n\r\n            faceVertices[0] = extractDecalVector3(index, transformMatrix);\r\n            faceVertices[1] = extractDecalVector3(index + 1, transformMatrix);\r\n            faceVertices[2] = extractDecalVector3(index + 2, transformMatrix);\r\n\r\n            if (options.cullBackFaces) {\r\n                // If all the normals of the vertices of the face are pointing away from the view direction we discard the face.\r\n                // As computations are done in the decal coordinate space, the viewDirection is (0,0,1), so when dot(vertexNormal, -viewDirection) <= 0 the vertex is culled\r\n                if (-faceVertices[0].normal.z <= 0 && -faceVertices[1].normal.z <= 0 && -faceVertices[2].normal.z <= 0) {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            // Clip\r\n            faceVertices = clip(faceVertices, xpAxis);\r\n            if (!faceVertices) continue;\r\n            faceVertices = clip(faceVertices, xnAxis);\r\n            if (!faceVertices) continue;\r\n            faceVertices = clip(faceVertices, ypAxis);\r\n            if (!faceVertices) continue;\r\n            faceVertices = clip(faceVertices, ynAxis);\r\n            if (!faceVertices) continue;\r\n            faceVertices = clip(faceVertices, zpAxis);\r\n            if (!faceVertices) continue;\r\n            faceVertices = clip(faceVertices, znAxis);\r\n            if (!faceVertices) continue;\r\n\r\n            // Add UVs and get back to world\r\n            for (let vIndex = 0; vIndex < faceVertices.length; vIndex++) {\r\n                const vertex = faceVertices[vIndex];\r\n\r\n                //TODO check for Int32Array | Uint32Array | Uint16Array\r\n                (<number[]>vertexData.indices).push(currentVertexDataIndex);\r\n                if (useLocalComputation) {\r\n                    if (vertex.localPositionOverride) {\r\n                        vertexData.positions[currentVertexDataIndex * 3] = vertex.localPositionOverride[0];\r\n                        vertexData.positions[currentVertexDataIndex * 3 + 1] = vertex.localPositionOverride[1];\r\n                        vertexData.positions[currentVertexDataIndex * 3 + 2] = vertex.localPositionOverride[2];\r\n                    } else if (localPositions) {\r\n                        vertexData.positions[currentVertexDataIndex * 3] = localPositions[vertex.vertexIdx];\r\n                        vertexData.positions[currentVertexDataIndex * 3 + 1] = localPositions[vertex.vertexIdx + 1];\r\n                        vertexData.positions[currentVertexDataIndex * 3 + 2] = localPositions[vertex.vertexIdx + 2];\r\n                    }\r\n                    if (vertex.localNormalOverride) {\r\n                        vertexData.normals[currentVertexDataIndex * 3] = vertex.localNormalOverride[0];\r\n                        vertexData.normals[currentVertexDataIndex * 3 + 1] = vertex.localNormalOverride[1];\r\n                        vertexData.normals[currentVertexDataIndex * 3 + 2] = vertex.localNormalOverride[2];\r\n                    } else if (localNormals) {\r\n                        vertexData.normals[currentVertexDataIndex * 3] = localNormals[vertex.vertexIdx];\r\n                        vertexData.normals[currentVertexDataIndex * 3 + 1] = localNormals[vertex.vertexIdx + 1];\r\n                        vertexData.normals[currentVertexDataIndex * 3 + 2] = localNormals[vertex.vertexIdx + 2];\r\n                    }\r\n                } else {\r\n                    vertex.position.toArray(vertexData.positions, currentVertexDataIndex * 3);\r\n                    vertex.normal.toArray(vertexData.normals, currentVertexDataIndex * 3);\r\n                }\r\n                if (vertexData.matricesIndices && vertexData.matricesWeights) {\r\n                    if (vertex.matrixIndicesOverride) {\r\n                        vertexData.matricesIndices[currentVertexDataIndex * 4] = vertex.matrixIndicesOverride[0];\r\n                        vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = vertex.matrixIndicesOverride[1];\r\n                        vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = vertex.matrixIndicesOverride[2];\r\n                        vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = vertex.matrixIndicesOverride[3];\r\n                    } else {\r\n                        if (matIndices) {\r\n                            vertexData.matricesIndices[currentVertexDataIndex * 4] = matIndices[vertex.vertexIdxForBones];\r\n                            vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = matIndices[vertex.vertexIdxForBones + 1];\r\n                            vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = matIndices[vertex.vertexIdxForBones + 2];\r\n                            vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = matIndices[vertex.vertexIdxForBones + 3];\r\n                        }\r\n                        if (matIndicesExtra && vertexData.matricesIndicesExtra) {\r\n                            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4] = matIndicesExtra[vertex.vertexIdxForBones];\r\n                            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 1] = matIndicesExtra[vertex.vertexIdxForBones + 1];\r\n                            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 2] = matIndicesExtra[vertex.vertexIdxForBones + 2];\r\n                            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 3] = matIndicesExtra[vertex.vertexIdxForBones + 3];\r\n                        }\r\n                    }\r\n                    if (vertex.matrixWeightsOverride) {\r\n                        vertexData.matricesWeights[currentVertexDataIndex * 4] = vertex.matrixWeightsOverride[0];\r\n                        vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = vertex.matrixWeightsOverride[1];\r\n                        vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = vertex.matrixWeightsOverride[2];\r\n                        vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = vertex.matrixWeightsOverride[3];\r\n                    } else {\r\n                        if (matWeights) {\r\n                            vertexData.matricesWeights[currentVertexDataIndex * 4] = matWeights[vertex.vertexIdxForBones];\r\n                            vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = matWeights[vertex.vertexIdxForBones + 1];\r\n                            vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = matWeights[vertex.vertexIdxForBones + 2];\r\n                            vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = matWeights[vertex.vertexIdxForBones + 3];\r\n                        }\r\n                        if (matWeightsExtra && vertexData.matricesWeightsExtra) {\r\n                            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4] = matWeightsExtra[vertex.vertexIdxForBones];\r\n                            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 1] = matWeightsExtra[vertex.vertexIdxForBones + 1];\r\n                            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 2] = matWeightsExtra[vertex.vertexIdxForBones + 2];\r\n                            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 3] = matWeightsExtra[vertex.vertexIdxForBones + 3];\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!options.captureUVS) {\r\n                    (<number[]>vertexData.uvs).push(0.5 + vertex.position.x / size.x);\r\n                    const v = 0.5 + vertex.position.y / size.y;\r\n                    (<number[]>vertexData.uvs).push(useOpenGLOrientationForUV ? 1 - v : v);\r\n                } else {\r\n                    vertex.uv.toArray(vertexData.uvs, currentVertexDataIndex * 2);\r\n                }\r\n                currentVertexDataIndex++;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Avoid the \"Setting vertex data kind 'XXX' with an empty array\" warning when calling vertexData.applyToMesh\r\n    if (vertexData.indices.length === 0) vertexData.indices = null;\r\n    if (vertexData.positions.length === 0) vertexData.positions = null;\r\n    if (vertexData.normals.length === 0) vertexData.normals = null;\r\n    if (vertexData.uvs.length === 0) vertexData.uvs = null;\r\n    if (vertexData.matricesIndices?.length === 0) vertexData.matricesIndices = null;\r\n    if (vertexData.matricesWeights?.length === 0) vertexData.matricesWeights = null;\r\n    if (vertexData.matricesIndicesExtra?.length === 0) vertexData.matricesIndicesExtra = null;\r\n    if (vertexData.matricesWeightsExtra?.length === 0) vertexData.matricesWeightsExtra = null;\r\n\r\n    // Return mesh\r\n    const decal = new Mesh(name, sourceMesh.getScene());\r\n    vertexData.applyToMesh(decal);\r\n\r\n    if (useLocalComputation) {\r\n        decal.skeleton = sourceMesh.skeleton;\r\n        decal.parent = sourceMesh;\r\n    } else {\r\n        decal.position = position.clone();\r\n        decal.rotation = new Vector3(pitch, yaw, angle);\r\n    }\r\n\r\n    decal.computeWorldMatrix(true);\r\n    decal.refreshBoundingInfo(true, true);\r\n\r\n    return decal;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function directly from the module\r\n */\r\nexport const DecalBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateDecal,\r\n};\r\n\r\nMesh.CreateDecal = (name: string, sourceMesh: AbstractMesh, position: Vector3, normal: Vector3, size: Vector3, angle: number): Mesh => {\r\n    const options = {\r\n        position,\r\n        normal,\r\n        size,\r\n        angle,\r\n    };\r\n\r\n    return CreateDecal(name, sourceMesh, options);\r\n};\r\n", "import { VertexData } from \"../mesh.vertexData\";\r\nimport { Vector2, Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { useOpenGLOrientationForUV } from \"../../Compat/compatibilityOptions\";\r\n/**\r\n * Scripts based off of https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\r\n * @param options the constructors options used to shape the mesh.\r\n * @returns the capsule VertexData\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/capsule\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function CreateCapsuleVertexData(\r\n    options: ICreateCapsuleOptions = {\r\n        subdivisions: 2,\r\n        tessellation: 16,\r\n        height: 1,\r\n        radius: 0.25,\r\n        capSubdivisions: 6,\r\n    }\r\n): VertexData {\r\n    const subdivisions = Math.max(options.subdivisions ? options.subdivisions : 2, 1) | 0;\r\n    const tessellation = Math.max(options.tessellation ? options.tessellation : 16, 3) | 0;\r\n    const height = Math.max(options.height ? options.height : 1, 0);\r\n    const radius = Math.max(options.radius ? options.radius : 0.25, 0);\r\n    const capDetail = Math.max(options.capSubdivisions ? options.capSubdivisions : 6, 1) | 0;\r\n\r\n    const radialSegments = tessellation;\r\n    const heightSegments = subdivisions;\r\n\r\n    const radiusTop = Math.max(options.radiusTop ? options.radiusTop : radius, 0);\r\n    const radiusBottom = Math.max(options.radiusBottom ? options.radiusBottom : radius, 0);\r\n\r\n    const heightMinusCaps = height - (radiusTop + radiusBottom);\r\n\r\n    const thetaStart = 0.0;\r\n    const thetaLength = 2.0 * Math.PI;\r\n\r\n    const capsTopSegments = Math.max(options.topCapSubdivisions ? options.topCapSubdivisions : capDetail, 1);\r\n    const capsBottomSegments = Math.max(options.bottomCapSubdivisions ? options.bottomCapSubdivisions : capDetail, 1);\r\n\r\n    const alpha = Math.acos((radiusBottom - radiusTop) / height);\r\n\r\n    let indices = [];\r\n    const vertices = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    let index = 0;\r\n    const indexArray = [],\r\n        halfHeight = heightMinusCaps * 0.5;\r\n    const pi2 = Math.PI * 0.5;\r\n\r\n    let x, y;\r\n    const normal = Vector3.Zero();\r\n    const vertex = Vector3.Zero();\r\n\r\n    const cosAlpha = Math.cos(alpha);\r\n    const sinAlpha = Math.sin(alpha);\r\n\r\n    const coneLength = new Vector2(radiusTop * sinAlpha, halfHeight + radiusTop * cosAlpha)\r\n        .subtract(new Vector2(radiusBottom * sinAlpha, -halfHeight + radiusBottom * cosAlpha))\r\n        .length();\r\n\r\n    // Total length for v texture coord\r\n    const vl = radiusTop * alpha + coneLength + radiusBottom * (pi2 - alpha);\r\n\r\n    let v = 0;\r\n    for (y = 0; y <= capsTopSegments; y++) {\r\n        const indexRow = [];\r\n\r\n        const a = pi2 - alpha * (y / capsTopSegments);\r\n\r\n        v += (radiusTop * alpha) / capsTopSegments;\r\n\r\n        const cosA = Math.cos(a);\r\n        const sinA = Math.sin(a);\r\n\r\n        // calculate the radius of the current row\r\n        const _radius = cosA * radiusTop;\r\n\r\n        for (x = 0; x <= radialSegments; x++) {\r\n            const u = x / radialSegments;\r\n            const theta = u * thetaLength + thetaStart;\r\n            const sinTheta = Math.sin(theta);\r\n            const cosTheta = Math.cos(theta);\r\n            // vertex\r\n            vertex.x = _radius * sinTheta;\r\n            vertex.y = halfHeight + sinA * radiusTop;\r\n            vertex.z = _radius * cosTheta;\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // normal\r\n            normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            // uv\r\n            uvs.push(u, useOpenGLOrientationForUV ? v / vl : 1 - v / vl);\r\n            // save index of vertex in respective row\r\n            indexRow.push(index);\r\n            // increase index\r\n            index++;\r\n        }\r\n        // now save vertices of the row in our index array\r\n        indexArray.push(indexRow);\r\n    }\r\n\r\n    const coneHeight = height - radiusTop - radiusBottom + cosAlpha * radiusTop - cosAlpha * radiusBottom;\r\n    const slope = (sinAlpha * (radiusBottom - radiusTop)) / coneHeight;\r\n\r\n    for (y = 1; y <= heightSegments; y++) {\r\n        const indexRow = [];\r\n        v += coneLength / heightSegments;\r\n        // calculate the radius of the current row\r\n        const _radius = sinAlpha * ((y * (radiusBottom - radiusTop)) / heightSegments + radiusTop);\r\n        for (x = 0; x <= radialSegments; x++) {\r\n            const u = x / radialSegments;\r\n            const theta = u * thetaLength + thetaStart;\r\n            const sinTheta = Math.sin(theta);\r\n            const cosTheta = Math.cos(theta);\r\n            // vertex\r\n            vertex.x = _radius * sinTheta;\r\n            vertex.y = halfHeight + cosAlpha * radiusTop - (y * coneHeight) / heightSegments;\r\n            vertex.z = _radius * cosTheta;\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // normal\r\n            normal.set(sinTheta, slope, cosTheta).normalize();\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            // uv\r\n            uvs.push(u, useOpenGLOrientationForUV ? v / vl : 1 - v / vl);\r\n            // save index of vertex in respective row\r\n            indexRow.push(index);\r\n            // increase index\r\n            index++;\r\n        }\r\n        // now save vertices of the row in our index array\r\n        indexArray.push(indexRow);\r\n    }\r\n\r\n    for (y = 1; y <= capsBottomSegments; y++) {\r\n        const indexRow = [];\r\n        const a = pi2 - alpha - (Math.PI - alpha) * (y / capsBottomSegments);\r\n        v += (radiusBottom * alpha) / capsBottomSegments;\r\n        const cosA = Math.cos(a);\r\n        const sinA = Math.sin(a);\r\n        // calculate the radius of the current row\r\n        const _radius = cosA * radiusBottom;\r\n        for (x = 0; x <= radialSegments; x++) {\r\n            const u = x / radialSegments;\r\n            const theta = u * thetaLength + thetaStart;\r\n            const sinTheta = Math.sin(theta);\r\n            const cosTheta = Math.cos(theta);\r\n            // vertex\r\n            vertex.x = _radius * sinTheta;\r\n            vertex.y = -halfHeight + sinA * radiusBottom;\r\n            vertex.z = _radius * cosTheta;\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // normal\r\n            normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            // uv\r\n            uvs.push(u, useOpenGLOrientationForUV ? v / vl : 1 - v / vl);\r\n            // save index of vertex in respective row\r\n            indexRow.push(index);\r\n            // increase index\r\n            index++;\r\n        }\r\n        // now save vertices of the row in our index array\r\n        indexArray.push(indexRow);\r\n    }\r\n    // generate indices\r\n    for (x = 0; x < radialSegments; x++) {\r\n        for (y = 0; y < capsTopSegments + heightSegments + capsBottomSegments; y++) {\r\n            // we use the index array to access the correct indices\r\n            const i1 = indexArray[y][x];\r\n            const i2 = indexArray[y + 1][x];\r\n            const i3 = indexArray[y + 1][x + 1];\r\n            const i4 = indexArray[y][x + 1];\r\n            // face one\r\n            indices.push(i1);\r\n            indices.push(i2);\r\n            indices.push(i4);\r\n            // face two\r\n            indices.push(i2);\r\n            indices.push(i3);\r\n            indices.push(i4);\r\n        }\r\n    }\r\n\r\n    indices = indices.reverse();\r\n\r\n    if (options.orientation && !options.orientation.equals(Vector3.Up())) {\r\n        const m = new Matrix();\r\n        options.orientation\r\n            .clone()\r\n            .scale(Math.PI * 0.5)\r\n            .cross(Vector3.Up())\r\n            .toQuaternion()\r\n            .toRotationMatrix(m);\r\n        const v = Vector3.Zero();\r\n        for (let i = 0; i < vertices.length; i += 3) {\r\n            v.set(vertices[i], vertices[i + 1], vertices[i + 2]);\r\n            Vector3.TransformCoordinatesToRef(v.clone(), m, v);\r\n            vertices[i] = v.x;\r\n            vertices[i + 1] = v.y;\r\n            vertices[i + 2] = v.z;\r\n        }\r\n    }\r\n\r\n    const vDat = new VertexData();\r\n    vDat.positions = vertices;\r\n    vDat.normals = normals;\r\n    vDat.uvs = uvs;\r\n    vDat.indices = indices;\r\n\r\n    return vDat;\r\n}\r\n\r\n/**\r\n * The options Interface for creating a Capsule Mesh\r\n */\r\nexport interface ICreateCapsuleOptions {\r\n    /** The Orientation of the capsule.  Default : Vector3.Up() */\r\n    orientation?: Vector3;\r\n\r\n    /** Number of sub segments on the tube section of the capsule running parallel to orientation. */\r\n    subdivisions?: number;\r\n\r\n    /** Number of cylindrical segments on the capsule. */\r\n    tessellation?: number;\r\n\r\n    /** Height or Length of the capsule. */\r\n    height?: number;\r\n\r\n    /** Radius of the capsule. */\r\n    radius?: number;\r\n\r\n    /** Number of sub segments on the cap sections of the capsule running parallel to orientation. */\r\n    capSubdivisions?: number;\r\n\r\n    /** Overwrite for the top radius. */\r\n    radiusTop?: number;\r\n\r\n    /** Overwrite for the bottom radius. */\r\n    radiusBottom?: number;\r\n\r\n    /** Overwrite for the top capSubdivisions. */\r\n    topCapSubdivisions?: number;\r\n\r\n    /** Overwrite for the bottom capSubdivisions. */\r\n    bottomCapSubdivisions?: number;\r\n\r\n    /** Internal geometry is supposed to change once created. */\r\n    updatable?: boolean;\r\n}\r\n\r\n/**\r\n * Creates a capsule or a pill mesh\r\n * @param name defines the name of the mesh\r\n * @param options The constructors options.\r\n * @param scene The scene the mesh is scoped to.\r\n * @returns Capsule Mesh\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function CreateCapsule(\r\n    name: string,\r\n    options: ICreateCapsuleOptions = {\r\n        orientation: Vector3.Up(),\r\n        subdivisions: 2,\r\n        tessellation: 16,\r\n        height: 1,\r\n        radius: 0.25,\r\n        capSubdivisions: 6,\r\n        updatable: false,\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const capsule = new Mesh(name, scene);\r\n    const vertexData = CreateCapsuleVertexData(options);\r\n    vertexData.applyToMesh(capsule, options.updatable);\r\n    return capsule;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated please use CreateCapsule directly\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport const CapsuleBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateCapsule,\r\n};\r\n\r\n/**\r\n * Creates a capsule or a pill mesh\r\n * @param name defines the name of the mesh.\r\n * @param options the constructors options used to shape the mesh.\r\n * @param scene defines the scene the mesh is scoped to.\r\n * @returns the capsule mesh\r\n * @see https://doc.babylonjs.com/how_to/capsule_shape\r\n */\r\nMesh.CreateCapsule = (name: string, options: ICreateCapsuleOptions, scene?: Nullable<Scene>): Mesh => {\r\n    return CreateCapsule(name, options, scene);\r\n};\r\n\r\nVertexData.CreateCapsule = CreateCapsuleVertexData;\r\n", "import { Logger } from \"../Misc/logger\";\r\nimport { Vector3 } from \"./math.vector\";\r\n\r\n/**\r\n * Class representing an isovector a vector containing 2 INTEGER coordinates\r\n * x axis is horizontal\r\n * y axis is 60 deg counter clockwise from positive y axis\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _IsoVector {\r\n    /**\r\n     * Creates a new isovector from the given x and y coordinates\r\n     * @param x defines the first coordinate, must be an integer\r\n     * @param y defines the second coordinate, must be an integer\r\n     */\r\n    constructor(\r\n        /** [0] defines the first coordinate */\r\n        public x: number = 0,\r\n        /** [0] defines the second coordinate */\r\n        public y: number = 0\r\n    ) {\r\n        if (x !== Math.floor(x)) {\r\n            x = Math.floor(x);\r\n            Logger.Warn(\"x is not an integer, floor(x) used\");\r\n        }\r\n        if (y !== Math.floor(y)) {\r\n            y = Math.floor(y);\r\n            Logger.Warn(\"y is not an integer, floor(y) used\");\r\n        }\r\n    }\r\n\r\n    // Operators\r\n\r\n    /**\r\n     * Gets a new IsoVector copied from the IsoVector\r\n     * @returns a new IsoVector\r\n     */\r\n    public clone(): _IsoVector {\r\n        return new _IsoVector(this.x, this.y);\r\n    }\r\n\r\n    /**\r\n     * Rotates one IsoVector 60 degrees counter clockwise about another\r\n     * Please note that this is an in place operation\r\n     * @param other an IsoVector a center of rotation\r\n     * @returns the rotated IsoVector\r\n     */\r\n    public rotate60About(other: _IsoVector) {\r\n        //other IsoVector\r\n        const x: number = this.x;\r\n        this.x = other.x + other.y - this.y;\r\n        this.y = x + this.y - other.x;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Rotates one IsoVector 60 degrees clockwise about another\r\n     * Please note that this is an in place operation\r\n     * @param other an IsoVector as center of rotation\r\n     * @returns the rotated IsoVector\r\n     */\r\n    public rotateNeg60About(other: _IsoVector) {\r\n        const x = this.x;\r\n        this.x = x + this.y - other.y;\r\n        this.y = other.x + other.y - x;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * For an equilateral triangle OAB with O at isovector (0, 0) and A at isovector (m, n)\r\n     * Rotates one IsoVector 120 degrees counter clockwise about the center of the triangle\r\n     * Please note that this is an in place operation\r\n     * @param m integer a measure a Primary triangle of order (m, n) m > n\r\n     * @param n >= 0 integer a measure for a Primary triangle of order (m, n)\r\n     * @returns the rotated IsoVector\r\n     */\r\n    public rotate120(m: number, n: number) {\r\n        //m, n integers\r\n        if (m !== Math.floor(m)) {\r\n            m = Math.floor(m);\r\n            Logger.Warn(\"m not an integer only floor(m) used\");\r\n        }\r\n        if (n !== Math.floor(n)) {\r\n            n = Math.floor(n);\r\n            Logger.Warn(\"n not an integer only floor(n) used\");\r\n        }\r\n        const x = this.x;\r\n        this.x = m - x - this.y;\r\n        this.y = n + x;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * For an equilateral triangle OAB with O at isovector (0, 0) and A at isovector (m, n)\r\n     * Rotates one IsoVector 120 degrees clockwise about the center of the triangle\r\n     * Please note that this is an in place operation\r\n     * @param m integer a measure a Primary triangle of order (m, n) m > n\r\n     * @param n >= 0 integer a measure for a Primary triangle of order (m, n)\r\n     * @returns the rotated IsoVector\r\n     */\r\n    public rotateNeg120(m: number, n: number) {\r\n        //m, n integers\r\n        if (m !== Math.floor(m)) {\r\n            m = Math.floor(m);\r\n            Logger.Warn(\"m is not an integer, floor(m) used\");\r\n        }\r\n        if (n !== Math.floor(n)) {\r\n            n = Math.floor(n);\r\n            Logger.Warn(\"n is not an integer,   floor(n) used\");\r\n        }\r\n        const x = this.x;\r\n        this.x = this.y - n;\r\n        this.y = m + n - x - this.y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Transforms an IsoVector to one in Cartesian 3D space based on an isovector\r\n     * @param origin an IsoVector\r\n     * @param isoGridSize\r\n     * @returns Point as a Vector3\r\n     */\r\n    public toCartesianOrigin(origin: _IsoVector, isoGridSize: number) {\r\n        const point = Vector3.Zero();\r\n        point.x = origin.x + 2 * this.x * isoGridSize + this.y * isoGridSize;\r\n        point.y = origin.y + Math.sqrt(3) * this.y * isoGridSize;\r\n        return point;\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Gets a new IsoVector(0, 0)\r\n     * @returns a new IsoVector\r\n     */\r\n    public static Zero(): _IsoVector {\r\n        return new _IsoVector(0, 0);\r\n    }\r\n}\r\n", "import { Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport { HighestCommonFactor } from \"../Maths/math.scalar.functions\";\r\nimport { PHI } from \"../Maths/math.constants\";\r\nimport { _IsoVector } from \"../Maths/math.isovector\";\r\n\r\n/**\r\n * Class representing data for one face OAB of an equilateral icosahedron\r\n * When O is the isovector (0, 0), A is isovector (m, n)\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _PrimaryIsoTriangle {\r\n    //properties\r\n    public m: number;\r\n    public n: number;\r\n    public cartesian: Vector3[] = [];\r\n    public vertices: _IsoVector[] = [];\r\n    public max: number[] = [];\r\n    public min: number[] = [];\r\n    public vecToidx: { [key: string]: number };\r\n    public vertByDist: { [key: string]: number[] };\r\n    public closestTo: number[][] = [];\r\n\r\n    public innerFacets: string[][] = [];\r\n    public isoVecsABOB: _IsoVector[][] = [];\r\n    public isoVecsOBOA: _IsoVector[][] = [];\r\n    public isoVecsBAOA: _IsoVector[][] = [];\r\n    public vertexTypes: number[][] = [];\r\n\r\n    public coau: number;\r\n    public cobu: number;\r\n    public coav: number;\r\n    public cobv: number;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public IDATA: PolyhedronData = new PolyhedronData(\r\n        \"icosahedron\",\r\n        \"Regular\",\r\n        [\r\n            [0, PHI, -1],\r\n            [-PHI, 1, 0],\r\n            [-1, 0, -PHI],\r\n            [1, 0, -PHI],\r\n            [PHI, 1, 0],\r\n            [0, PHI, 1],\r\n            [-1, 0, PHI],\r\n            [-PHI, -1, 0],\r\n            [0, -PHI, -1],\r\n            [PHI, -1, 0],\r\n            [1, 0, PHI],\r\n            [0, -PHI, 1],\r\n        ],\r\n        [\r\n            [0, 2, 1],\r\n            [0, 3, 2],\r\n            [0, 4, 3],\r\n            [0, 5, 4],\r\n            [0, 1, 5],\r\n            [7, 6, 1],\r\n            [8, 7, 2],\r\n            [9, 8, 3],\r\n            [10, 9, 4],\r\n            [6, 10, 5],\r\n            [2, 7, 1],\r\n            [3, 8, 2],\r\n            [4, 9, 3],\r\n            [5, 10, 4],\r\n            [1, 6, 5],\r\n            [11, 6, 7],\r\n            [11, 7, 8],\r\n            [11, 8, 9],\r\n            [11, 9, 10],\r\n            [11, 10, 6],\r\n        ]\r\n    );\r\n\r\n    /**\r\n     * Creates the PrimaryIsoTriangle Triangle OAB\r\n     * @param m an integer\r\n     * @param n an integer\r\n     */\r\n\r\n    //operators\r\n    public setIndices() {\r\n        let indexCount = 12; // 12 vertices already assigned\r\n        const vecToidx: { [key: string]: number } = {}; //maps iso-vectors to indexCount;\r\n        const m = this.m;\r\n        const n = this.n;\r\n        let g = m; // hcf of m, n when n != 0\r\n        let m1 = 1;\r\n        let n1 = 0;\r\n        if (n !== 0) {\r\n            g = HighestCommonFactor(m, n);\r\n        }\r\n        m1 = m / g;\r\n        n1 = n / g;\r\n\r\n        let fr: number | string; //face to the right of current face\r\n        let rot: number | string; //rotation about which vertex for fr\r\n        let O: number;\r\n        let A: number;\r\n        let B: number;\r\n        const oVec: _IsoVector = _IsoVector.Zero();\r\n        const aVec = new _IsoVector(m, n);\r\n        const bVec = new _IsoVector(-n, m + n);\r\n        const oaVec: _IsoVector = _IsoVector.Zero();\r\n        const abVec: _IsoVector = _IsoVector.Zero();\r\n        const obVec: _IsoVector = _IsoVector.Zero();\r\n        let verts: number[] = [];\r\n        let idx: string;\r\n        let idxR: string;\r\n        let isoId: string;\r\n        let isoIdR: string;\r\n\r\n        const closestTo: number[][] = [];\r\n        const vDist = this.vertByDist;\r\n\r\n        const matchIdx = (f: number, fr: number, isoId: string, isoIdR: string) => {\r\n            idx = f + \"|\" + isoId;\r\n            idxR = fr + \"|\" + isoIdR;\r\n            if (!(idx in vecToidx || idxR in vecToidx)) {\r\n                vecToidx[idx] = indexCount;\r\n                vecToidx[idxR] = indexCount;\r\n                indexCount++;\r\n            } else if (idx in vecToidx && !(idxR in vecToidx)) {\r\n                vecToidx[idxR] = vecToidx[idx];\r\n            } else if (idxR in vecToidx && !(idx in vecToidx)) {\r\n                vecToidx[idx] = vecToidx[idxR];\r\n            }\r\n            if (vDist[isoId][0] > 2) {\r\n                closestTo[vecToidx[idx]] = [-vDist[isoId][0], vDist[isoId][1], vecToidx[idx]];\r\n            } else {\r\n                closestTo[vecToidx[idx]] = [verts[vDist[isoId][0]], vDist[isoId][1], vecToidx[idx]];\r\n            }\r\n        };\r\n\r\n        this.IDATA.edgematch = [\r\n            [1, \"B\"],\r\n            [2, \"B\"],\r\n            [3, \"B\"],\r\n            [4, \"B\"],\r\n            [0, \"B\"],\r\n            [10, \"O\", 14, \"A\"],\r\n            [11, \"O\", 10, \"A\"],\r\n            [12, \"O\", 11, \"A\"],\r\n            [13, \"O\", 12, \"A\"],\r\n            [14, \"O\", 13, \"A\"],\r\n            [0, \"O\"],\r\n            [1, \"O\"],\r\n            [2, \"O\"],\r\n            [3, \"O\"],\r\n            [4, \"O\"],\r\n            [19, \"B\", 5, \"A\"],\r\n            [15, \"B\", 6, \"A\"],\r\n            [16, \"B\", 7, \"A\"],\r\n            [17, \"B\", 8, \"A\"],\r\n            [18, \"B\", 9, \"A\"],\r\n        ];\r\n\r\n        /***edges AB to OB***** rotation about B*/\r\n        for (let f = 0; f < 20; f++) {\r\n            //f current face\r\n\r\n            verts = this.IDATA.face[f];\r\n            O = verts[2];\r\n            A = verts[1];\r\n            B = verts[0];\r\n\r\n            isoId = oVec.x + \"|\" + oVec.y;\r\n            idx = f + \"|\" + isoId;\r\n            if (!(idx in vecToidx)) {\r\n                vecToidx[idx] = O;\r\n                closestTo[O] = [verts[vDist[isoId][0]], vDist[isoId][1]];\r\n            }\r\n\r\n            isoId = aVec.x + \"|\" + aVec.y;\r\n            idx = f + \"|\" + isoId;\r\n            if (!(idx in vecToidx)) {\r\n                vecToidx[idx] = A;\r\n                closestTo[A] = [verts[vDist[isoId][0]], vDist[isoId][1]];\r\n            }\r\n\r\n            isoId = bVec.x + \"|\" + bVec.y;\r\n            idx = f + \"|\" + isoId;\r\n            if (!(idx in vecToidx)) {\r\n                vecToidx[idx] = B;\r\n                closestTo[B] = [verts[vDist[isoId][0]], vDist[isoId][1]];\r\n            }\r\n\r\n            //for edge vertices\r\n            fr = <number>this.IDATA.edgematch[f][0];\r\n            rot = <string>this.IDATA.edgematch[f][1];\r\n            if (rot === \"B\") {\r\n                for (let i = 1; i < g; i++) {\r\n                    abVec.x = m - i * (m1 + n1);\r\n                    abVec.y = n + i * m1;\r\n                    obVec.x = -i * n1;\r\n                    obVec.y = i * (m1 + n1);\r\n                    isoId = abVec.x + \"|\" + abVec.y;\r\n                    isoIdR = obVec.x + \"|\" + obVec.y;\r\n                    matchIdx(f, fr, isoId, isoIdR);\r\n                }\r\n            }\r\n\r\n            if (rot === \"O\") {\r\n                for (let i = 1; i < g; i++) {\r\n                    obVec.x = -i * n1;\r\n                    obVec.y = i * (m1 + n1);\r\n                    oaVec.x = i * m1;\r\n                    oaVec.y = i * n1;\r\n                    isoId = obVec.x + \"|\" + obVec.y;\r\n                    isoIdR = oaVec.x + \"|\" + oaVec.y;\r\n                    matchIdx(f, fr, isoId, isoIdR);\r\n                }\r\n            }\r\n\r\n            fr = <number>this.IDATA.edgematch[f][2];\r\n            rot = <string>this.IDATA.edgematch[f][3];\r\n            if (rot && rot === \"A\") {\r\n                for (let i = 1; i < g; i++) {\r\n                    oaVec.x = i * m1;\r\n                    oaVec.y = i * n1;\r\n                    abVec.x = m - (g - i) * (m1 + n1); //reversed for BA\r\n                    abVec.y = n + (g - i) * m1; //reversed for BA\r\n                    isoId = oaVec.x + \"|\" + oaVec.y;\r\n                    isoIdR = abVec.x + \"|\" + abVec.y;\r\n                    matchIdx(f, fr, isoId, isoIdR);\r\n                }\r\n            }\r\n\r\n            for (let i = 0; i < this.vertices.length; i++) {\r\n                isoId = this.vertices[i].x + \"|\" + this.vertices[i].y;\r\n                idx = f + \"|\" + isoId;\r\n                if (!(idx in vecToidx)) {\r\n                    vecToidx[idx] = indexCount++;\r\n                    if (vDist[isoId][0] > 2) {\r\n                        closestTo[vecToidx[idx]] = [-vDist[isoId][0], vDist[isoId][1], vecToidx[idx]];\r\n                    } else {\r\n                        closestTo[vecToidx[idx]] = [verts[vDist[isoId][0]], vDist[isoId][1], vecToidx[idx]];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.closestTo = closestTo;\r\n        this.vecToidx = vecToidx;\r\n    }\r\n\r\n    public calcCoeffs() {\r\n        const m = this.m;\r\n        const n = this.n;\r\n        const thirdR3 = Math.sqrt(3) / 3;\r\n\r\n        const LSQD = m * m + n * n + m * n;\r\n\r\n        this.coau = (m + n) / LSQD;\r\n        this.cobu = -n / LSQD;\r\n        this.coav = (-thirdR3 * (m - n)) / LSQD;\r\n        this.cobv = (thirdR3 * (2 * m + n)) / LSQD;\r\n    }\r\n\r\n    public createInnerFacets() {\r\n        const m = this.m;\r\n        const n = this.n;\r\n        for (let y = 0; y < n + m + 1; y++) {\r\n            for (let x = this.min[y]; x < this.max[y] + 1; x++) {\r\n                if (x < this.max[y] && x < this.max[y + 1] + 1) {\r\n                    this.innerFacets.push([\"|\" + x + \"|\" + y, \"|\" + x + \"|\" + (y + 1), \"|\" + (x + 1) + \"|\" + y]);\r\n                }\r\n                if (y > 0 && x < this.max[y - 1] && x + 1 < this.max[y] + 1) {\r\n                    this.innerFacets.push([\"|\" + x + \"|\" + y, \"|\" + (x + 1) + \"|\" + y, \"|\" + (x + 1) + \"|\" + (y - 1)]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public edgeVecsABOB() {\r\n        const m = this.m;\r\n        const n = this.n;\r\n\r\n        const B = new _IsoVector(-n, m + n);\r\n\r\n        for (let y = 1; y < m + n; y++) {\r\n            const point = new _IsoVector(this.min[y], y);\r\n            const prev = new _IsoVector(this.min[y - 1], y - 1);\r\n            const next = new _IsoVector(this.min[y + 1], y + 1);\r\n            const pointR = point.clone();\r\n            const prevR = prev.clone();\r\n            const nextR = next.clone();\r\n\r\n            pointR.rotate60About(B);\r\n            prevR.rotate60About(B);\r\n            nextR.rotate60About(B);\r\n\r\n            const maxPoint = new _IsoVector(this.max[pointR.y], pointR.y);\r\n            const maxPrev = new _IsoVector(this.max[pointR.y - 1], pointR.y - 1);\r\n            const maxLeftPrev = new _IsoVector(this.max[pointR.y - 1] - 1, pointR.y - 1);\r\n\r\n            if (pointR.x !== maxPoint.x || pointR.y !== maxPoint.y) {\r\n                if (pointR.x !== maxPrev.x) {\r\n                    // type2\r\n                    //up\r\n                    this.vertexTypes.push([1, 0, 0]);\r\n                    this.isoVecsABOB.push([point, maxPrev, maxLeftPrev]);\r\n                    //down\r\n                    this.vertexTypes.push([1, 0, 0]);\r\n                    this.isoVecsABOB.push([point, maxLeftPrev, maxPoint]);\r\n                } else if (pointR.y === nextR.y) {\r\n                    // type1\r\n                    //up\r\n                    this.vertexTypes.push([1, 1, 0]);\r\n                    this.isoVecsABOB.push([point, prev, maxPrev]);\r\n                    //down\r\n                    this.vertexTypes.push([1, 0, 1]);\r\n                    this.isoVecsABOB.push([point, maxPrev, next]);\r\n                } else {\r\n                    // type 0\r\n                    //up\r\n                    this.vertexTypes.push([1, 1, 0]);\r\n                    this.isoVecsABOB.push([point, prev, maxPrev]);\r\n                    //down\r\n                    this.vertexTypes.push([1, 0, 0]);\r\n                    this.isoVecsABOB.push([point, maxPrev, maxPoint]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public mapABOBtoOBOA() {\r\n        const point = new _IsoVector(0, 0);\r\n        for (let i = 0; i < this.isoVecsABOB.length; i++) {\r\n            const temp = [];\r\n            for (let j = 0; j < 3; j++) {\r\n                point.x = this.isoVecsABOB[i][j].x;\r\n                point.y = this.isoVecsABOB[i][j].y;\r\n                if (this.vertexTypes[i][j] === 0) {\r\n                    point.rotateNeg120(this.m, this.n);\r\n                }\r\n                temp.push(point.clone());\r\n            }\r\n            this.isoVecsOBOA.push(temp);\r\n        }\r\n    }\r\n\r\n    public mapABOBtoBAOA() {\r\n        const point = new _IsoVector(0, 0);\r\n        for (let i = 0; i < this.isoVecsABOB.length; i++) {\r\n            const temp = [];\r\n            for (let j = 0; j < 3; j++) {\r\n                point.x = this.isoVecsABOB[i][j].x;\r\n                point.y = this.isoVecsABOB[i][j].y;\r\n                if (this.vertexTypes[i][j] === 1) {\r\n                    point.rotate120(this.m, this.n);\r\n                }\r\n                temp.push(point.clone());\r\n            }\r\n            this.isoVecsBAOA.push(temp);\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public MapToFace(faceNb: number, geodesicData: PolyhedronData) {\r\n        const F = this.IDATA.face[faceNb];\r\n        const oidx = F[2];\r\n        const aidx = F[1];\r\n        const bidx = F[0];\r\n\r\n        const O = Vector3.FromArray(this.IDATA.vertex[oidx]);\r\n        const A = Vector3.FromArray(this.IDATA.vertex[aidx]);\r\n        const B = Vector3.FromArray(this.IDATA.vertex[bidx]);\r\n\r\n        const OA = A.subtract(O);\r\n        const OB = B.subtract(O);\r\n\r\n        const x: Vector3 = OA.scale(this.coau).add(OB.scale(this.cobu));\r\n        const y: Vector3 = OA.scale(this.coav).add(OB.scale(this.cobv));\r\n\r\n        const mapped = [];\r\n\r\n        let idx: string;\r\n        let tempVec: Vector3 = TmpVectors.Vector3[0];\r\n        for (let i = 0; i < this.cartesian.length; i++) {\r\n            tempVec = x.scale(this.cartesian[i].x).add(y.scale(this.cartesian[i].y)).add(O);\r\n            mapped[i] = [tempVec.x, tempVec.y, tempVec.z];\r\n            idx = faceNb + \"|\" + this.vertices[i].x + \"|\" + this.vertices[i].y;\r\n            geodesicData.vertex[this.vecToidx[idx]] = [tempVec.x, tempVec.y, tempVec.z];\r\n        }\r\n    }\r\n\r\n    //statics\r\n    /**Creates a primary triangle\r\n     * @internal\r\n     */\r\n\r\n    public build(m: number, n: number) {\r\n        const vertices: _IsoVector[] = [];\r\n\r\n        const O: _IsoVector = _IsoVector.Zero();\r\n        const A: _IsoVector = new _IsoVector(m, n);\r\n        const B: _IsoVector = new _IsoVector(-n, m + n);\r\n        vertices.push(O, A, B);\r\n\r\n        //max internal isoceles triangle vertices\r\n        for (let y = n; y < m + 1; y++) {\r\n            for (let x = 0; x < m + 1 - y; x++) {\r\n                vertices.push(new _IsoVector(x, y));\r\n            }\r\n        }\r\n\r\n        //shared vertices along edges when needed\r\n        if (n > 0) {\r\n            const g = HighestCommonFactor(m, n);\r\n            const m1 = m / g;\r\n            const n1 = n / g;\r\n\r\n            for (let i = 1; i < g; i++) {\r\n                vertices.push(new _IsoVector(i * m1, i * n1)); //OA\r\n                vertices.push(new _IsoVector(-i * n1, i * (m1 + n1))); //OB\r\n                vertices.push(new _IsoVector(m - i * (m1 + n1), n + i * m1)); // AB\r\n            }\r\n\r\n            //lower rows vertices and their rotations\r\n            const ratio = m / n;\r\n            for (let y = 1; y < n; y++) {\r\n                for (let x = 0; x < y * ratio; x++) {\r\n                    vertices.push(new _IsoVector(x, y));\r\n                    vertices.push(new _IsoVector(x, y).rotate120(m, n));\r\n                    vertices.push(new _IsoVector(x, y).rotateNeg120(m, n));\r\n                }\r\n            }\r\n        }\r\n        //order vertices by x and then y\r\n        vertices.sort((a, b) => {\r\n            return a.x - b.x;\r\n        });\r\n\r\n        vertices.sort((a, b) => {\r\n            return a.y - b.y;\r\n        });\r\n\r\n        const min = new Array<number>(m + n + 1);\r\n        const max = new Array<number>(m + n + 1);\r\n        for (let i = 0; i < min.length; i++) {\r\n            min[i] = Infinity;\r\n            max[i] = -Infinity;\r\n        }\r\n\r\n        let y: number = 0;\r\n        let x: number = 0;\r\n\r\n        const len: number = vertices.length;\r\n        for (let i = 0; i < len; i++) {\r\n            x = vertices[i].x;\r\n            y = vertices[i].y;\r\n            min[y] = Math.min(x, min[y]);\r\n            max[y] = Math.max(x, max[y]);\r\n        }\r\n\r\n        //calculates the distance of a vertex from a given primary vertex\r\n        const distFrom = (vert: _IsoVector, primVert: string) => {\r\n            const v = vert.clone();\r\n            if (primVert === \"A\") {\r\n                v.rotateNeg120(m, n);\r\n            }\r\n            if (primVert === \"B\") {\r\n                v.rotate120(m, n);\r\n            }\r\n            if (v.x < 0) {\r\n                return v.y;\r\n            }\r\n            return v.x + v.y;\r\n        };\r\n\r\n        const cartesian: Vector3[] = [];\r\n        const distFromO: number[] = [];\r\n        const distFromA: number[] = [];\r\n        const distFromB: number[] = [];\r\n        const vertByDist: { [key: string]: number[] } = {};\r\n        const vertData: number[][] = [];\r\n        let closest: number = -1;\r\n        let dist: number = -1;\r\n        for (let i = 0; i < len; i++) {\r\n            cartesian[i] = vertices[i].toCartesianOrigin(new _IsoVector(0, 0), 0.5);\r\n            distFromO[i] = distFrom(vertices[i], \"O\");\r\n            distFromA[i] = distFrom(vertices[i], \"A\");\r\n            distFromB[i] = distFrom(vertices[i], \"B\");\r\n\r\n            if (distFromO[i] === distFromA[i] && distFromA[i] === distFromB[i]) {\r\n                closest = 3;\r\n                dist = distFromO[i];\r\n            } else if (distFromO[i] === distFromA[i]) {\r\n                closest = 4;\r\n                dist = distFromO[i];\r\n            } else if (distFromA[i] === distFromB[i]) {\r\n                closest = 5;\r\n                dist = distFromA[i];\r\n            } else if (distFromB[i] === distFromO[i]) {\r\n                closest = 6;\r\n                dist = distFromO[i];\r\n            }\r\n            if (distFromO[i] < distFromA[i] && distFromO[i] < distFromB[i]) {\r\n                closest = 2;\r\n                dist = distFromO[i];\r\n            }\r\n            if (distFromA[i] < distFromO[i] && distFromA[i] < distFromB[i]) {\r\n                closest = 1;\r\n                dist = distFromA[i];\r\n            }\r\n            if (distFromB[i] < distFromA[i] && distFromB[i] < distFromO[i]) {\r\n                closest = 0;\r\n                dist = distFromB[i];\r\n            }\r\n            vertData.push([closest, dist, vertices[i].x, vertices[i].y]);\r\n        }\r\n\r\n        vertData.sort((a, b) => {\r\n            return a[2] - b[2];\r\n        });\r\n        vertData.sort((a, b) => {\r\n            return a[3] - b[3];\r\n        });\r\n        vertData.sort((a, b) => {\r\n            return a[1] - b[1];\r\n        });\r\n        vertData.sort((a, b) => {\r\n            return a[0] - b[0];\r\n        });\r\n\r\n        for (let v = 0; v < vertData.length; v++) {\r\n            vertByDist[vertData[v][2] + \"|\" + vertData[v][3]] = [vertData[v][0], vertData[v][1], v];\r\n        }\r\n\r\n        this.m = m;\r\n        this.n = n;\r\n        this.vertices = vertices;\r\n        this.vertByDist = vertByDist;\r\n        this.cartesian = cartesian;\r\n        this.min = min;\r\n        this.max = max;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\n/** Builds Polyhedron Data\r\n * @internal\r\n */\r\n\r\nexport class PolyhedronData {\r\n    /**\r\n     * @internal\r\n     */\r\n    public edgematch: (number | string)[][];\r\n\r\n    constructor(\r\n        /**\r\n         * The name of the polyhedron\r\n         */\r\n        public name: string,\r\n        /**\r\n         * The category of the polyhedron\r\n         */\r\n        public category: string,\r\n        /**\r\n         * vertex data\r\n         */\r\n        public vertex: number[][],\r\n        /**\r\n         * face data\r\n         */\r\n        public face: number[][]\r\n    ) {}\r\n}\r\n\r\n/**\r\n * This class Extends the PolyhedronData Class to provide measures for a Geodesic Polyhedron\r\n */\r\nexport class GeodesicData extends PolyhedronData {\r\n    /**\r\n     * @internal\r\n     */\r\n    public override edgematch: (number | string)[][];\r\n    /**\r\n     * @internal\r\n     */\r\n    public adjacentFaces: number[][];\r\n    /**\r\n     * @internal\r\n     */\r\n    public sharedNodes: number;\r\n    /**\r\n     * @internal\r\n     */\r\n    public poleNodes: number;\r\n    /**\r\n     * @internal\r\n     */\r\n    public innerToData(face: number, primTri: _PrimaryIsoTriangle) {\r\n        for (let i = 0; i < primTri.innerFacets.length; i++) {\r\n            this.face.push(primTri.innerFacets[i].map((el) => primTri.vecToidx[face + el]));\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public mapABOBtoDATA(faceNb: number, primTri: _PrimaryIsoTriangle) {\r\n        const fr = primTri.IDATA.edgematch[faceNb][0];\r\n        for (let i = 0; i < primTri.isoVecsABOB.length; i++) {\r\n            const temp = [];\r\n            for (let j = 0; j < 3; j++) {\r\n                if (primTri.vertexTypes[i][j] === 0) {\r\n                    temp.push(faceNb + \"|\" + primTri.isoVecsABOB[i][j].x + \"|\" + primTri.isoVecsABOB[i][j].y);\r\n                } else {\r\n                    temp.push(fr + \"|\" + primTri.isoVecsABOB[i][j].x + \"|\" + primTri.isoVecsABOB[i][j].y);\r\n                }\r\n            }\r\n            this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public mapOBOAtoDATA(faceNb: number, primTri: _PrimaryIsoTriangle) {\r\n        const fr = primTri.IDATA.edgematch[faceNb][0];\r\n        for (let i = 0; i < primTri.isoVecsOBOA.length; i++) {\r\n            const temp = [];\r\n            for (let j = 0; j < 3; j++) {\r\n                if (primTri.vertexTypes[i][j] === 1) {\r\n                    temp.push(faceNb + \"|\" + primTri.isoVecsOBOA[i][j].x + \"|\" + primTri.isoVecsOBOA[i][j].y);\r\n                } else {\r\n                    temp.push(fr + \"|\" + primTri.isoVecsOBOA[i][j].x + \"|\" + primTri.isoVecsOBOA[i][j].y);\r\n                }\r\n            }\r\n            this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public mapBAOAtoDATA(faceNb: number, primTri: _PrimaryIsoTriangle) {\r\n        const fr = primTri.IDATA.edgematch[faceNb][2];\r\n        for (let i = 0; i < primTri.isoVecsBAOA.length; i++) {\r\n            const temp = [];\r\n            for (let j = 0; j < 3; j++) {\r\n                if (primTri.vertexTypes[i][j] === 1) {\r\n                    temp.push(faceNb + \"|\" + primTri.isoVecsBAOA[i][j].x + \"|\" + primTri.isoVecsBAOA[i][j].y);\r\n                } else {\r\n                    temp.push(fr + \"|\" + primTri.isoVecsBAOA[i][j].x + \"|\" + primTri.isoVecsBAOA[i][j].y);\r\n                }\r\n            }\r\n            this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public orderData(primTri: _PrimaryIsoTriangle) {\r\n        const nearTo: number[][][] = [];\r\n        for (let i = 0; i < 13; i++) {\r\n            nearTo[i] = [];\r\n        }\r\n        const close: number[][] = primTri.closestTo;\r\n        for (let i = 0; i < close.length; i++) {\r\n            if (close[i][0] > -1) {\r\n                if (close[i][1] > 0) {\r\n                    nearTo[close[i][0]].push([i, close[i][1]]);\r\n                }\r\n            } else {\r\n                nearTo[12].push([i, close[i][0]]);\r\n            }\r\n        }\r\n\r\n        const near: number[] = [];\r\n        for (let i = 0; i < 12; i++) {\r\n            near[i] = i;\r\n        }\r\n        let nearIndex = 12;\r\n        for (let i = 0; i < 12; i++) {\r\n            nearTo[i].sort((a: number[], b: number[]) => {\r\n                return a[1] - b[1];\r\n            });\r\n            for (let j = 0; j < nearTo[i].length; j++) {\r\n                near[nearTo[i][j][0]] = nearIndex++;\r\n            }\r\n        }\r\n\r\n        for (let j = 0; j < nearTo[12].length; j++) {\r\n            near[nearTo[12][j][0]] = nearIndex++;\r\n        }\r\n\r\n        for (let i = 0; i < this.vertex.length; i++) {\r\n            this.vertex[i].push(near[i]);\r\n        }\r\n\r\n        this.vertex.sort((a, b) => {\r\n            return a[3] - b[3];\r\n        });\r\n\r\n        for (let i = 0; i < this.vertex.length; i++) {\r\n            this.vertex[i].pop();\r\n        }\r\n\r\n        for (let i = 0; i < this.face.length; i++) {\r\n            for (let j = 0; j < this.face[i].length; j++) {\r\n                this.face[i][j] = near[this.face[i][j]];\r\n            }\r\n        }\r\n\r\n        this.sharedNodes = nearTo[12].length;\r\n        this.poleNodes = this.vertex.length - this.sharedNodes;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setOrder(m: number, faces: number[]) {\r\n        const adjVerts: number[] = [];\r\n        const dualFaces: number[] = [];\r\n        let face: number = <number>faces.pop();\r\n        dualFaces.push(face);\r\n        let index = this.face[face].indexOf(m);\r\n        index = (index + 2) % 3;\r\n        let v = this.face[face][index];\r\n        adjVerts.push(v);\r\n        let f = 0;\r\n        while (faces.length > 0) {\r\n            face = faces[f];\r\n            if (this.face[face].indexOf(v) > -1) {\r\n                // v is a vertex of face f\r\n                index = (this.face[face].indexOf(v) + 1) % 3;\r\n                v = this.face[face][index];\r\n                adjVerts.push(v);\r\n                dualFaces.push(face);\r\n                faces.splice(f, 1);\r\n                f = 0;\r\n            } else {\r\n                f++;\r\n            }\r\n        }\r\n        this.adjacentFaces.push(adjVerts);\r\n        return dualFaces;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public toGoldbergPolyhedronData(): PolyhedronData {\r\n        const goldbergPolyhedronData: PolyhedronData = new PolyhedronData(\"GeoDual\", \"Goldberg\", [], []);\r\n        goldbergPolyhedronData.name = \"GD dual\";\r\n        const verticesNb: number = this.vertex.length;\r\n        const map = new Array(verticesNb);\r\n        for (let v = 0; v < verticesNb; v++) {\r\n            map[v] = [];\r\n        }\r\n        for (let f = 0; f < this.face.length; f++) {\r\n            for (let i = 0; i < 3; i++) {\r\n                map[this.face[f][i]].push(f);\r\n            }\r\n        }\r\n        let cx = 0;\r\n        let cy = 0;\r\n        let cz = 0;\r\n        let face = [];\r\n        let vertex = [];\r\n        this.adjacentFaces = [];\r\n        for (let m = 0; m < map.length; m++) {\r\n            goldbergPolyhedronData.face[m] = this.setOrder(m, map[m].concat([]));\r\n            map[m].forEach((el: number) => {\r\n                cx = 0;\r\n                cy = 0;\r\n                cz = 0;\r\n                face = this.face[el];\r\n                for (let i = 0; i < 3; i++) {\r\n                    vertex = this.vertex[face[i]];\r\n                    cx += vertex[0];\r\n                    cy += vertex[1];\r\n                    cz += vertex[2];\r\n                }\r\n                goldbergPolyhedronData.vertex[el] = [cx / 3, cy / 3, cz / 3];\r\n            });\r\n        }\r\n        return goldbergPolyhedronData;\r\n    }\r\n\r\n    //statics\r\n    /**Builds the data for a Geodesic Polyhedron from a primary triangle\r\n     * @param primTri the primary triangle\r\n     * @internal\r\n     */\r\n\r\n    public static BuildGeodesicData(primTri: _PrimaryIsoTriangle) {\r\n        const geodesicData = new GeodesicData(\r\n            \"Geodesic-m-n\",\r\n            \"Geodesic\",\r\n            [\r\n                [0, PHI, -1],\r\n                [-PHI, 1, 0],\r\n                [-1, 0, -PHI],\r\n                [1, 0, -PHI],\r\n                [PHI, 1, 0],\r\n                [0, PHI, 1],\r\n                [-1, 0, PHI],\r\n                [-PHI, -1, 0],\r\n                [0, -PHI, -1],\r\n                [PHI, -1, 0],\r\n                [1, 0, PHI],\r\n                [0, -PHI, 1],\r\n            ],\r\n            []\r\n        );\r\n\r\n        primTri.setIndices();\r\n        primTri.calcCoeffs();\r\n        primTri.createInnerFacets();\r\n        primTri.edgeVecsABOB();\r\n        primTri.mapABOBtoOBOA();\r\n        primTri.mapABOBtoBAOA();\r\n\r\n        for (let f = 0; f < primTri.IDATA.face.length; f++) {\r\n            primTri.MapToFace(f, geodesicData);\r\n            geodesicData.innerToData(f, primTri);\r\n            if (primTri.IDATA.edgematch[f][1] === \"B\") {\r\n                geodesicData.mapABOBtoDATA(f, primTri);\r\n            }\r\n            if (primTri.IDATA.edgematch[f][1] === \"O\") {\r\n                geodesicData.mapOBOAtoDATA(f, primTri);\r\n            }\r\n            if (primTri.IDATA.edgematch[f][3] === \"A\") {\r\n                geodesicData.mapBAOAtoDATA(f, primTri);\r\n            }\r\n        }\r\n\r\n        geodesicData.orderData(primTri);\r\n        const radius = 1;\r\n        geodesicData.vertex = geodesicData.vertex.map(function (el) {\r\n            const a = el[0];\r\n            const b = el[1];\r\n            const c = el[2];\r\n            const d = Math.sqrt(a * a + b * b + c * c);\r\n            el[0] *= radius / d;\r\n            el[1] *= radius / d;\r\n            el[2] *= radius / d;\r\n            return el;\r\n        });\r\n\r\n        return geodesicData;\r\n    }\r\n}\r\n", "import type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { CreatePolyhedron } from \"./polyhedronBuilder\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { _PrimaryIsoTriangle, GeodesicData } from \"../geodesicMesh\";\r\n\r\n/**\r\n * Creates the Mesh for a Geodesic Polyhedron\r\n * @see https://en.wikipedia.org/wiki/Geodesic_polyhedron\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/polyhedra/geodesic_poly\r\n * @param name defines the name of the mesh\r\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n * * m number of horizontal steps along an isogrid\r\n * * n number of angled steps along an isogrid\r\n * * size the size of the Geodesic, optional default 1\r\n * * sizeX allows stretching in the x direction, optional, default size\r\n * * sizeY allows stretching in the y direction, optional, default size\r\n * * sizeZ allows stretching in the z direction, optional, default size\r\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n * * flat when true creates a flat shaded mesh, optional, default true\r\n * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param scene defines the hosting scene\r\n * @returns Geodesic mesh\r\n */\r\nexport function CreateGeodesic(\r\n    name: string,\r\n    options: {\r\n        m?: number;\r\n        n?: number;\r\n        size?: number;\r\n        sizeX?: number;\r\n        sizeY?: number;\r\n        sizeZ?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        flat?: boolean;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    let m: number = options.m || 1;\r\n    if (m !== Math.floor(m)) {\r\n        m = Math.floor(m);\r\n        Logger.Warn(\"m not an integer only floor(m) used\");\r\n    }\r\n    let n: number = options.n || 0;\r\n    if (n !== Math.floor(n)) {\r\n        n = Math.floor(n);\r\n        Logger.Warn(\"n not an integer only floor(n) used\");\r\n    }\r\n    if (n > m) {\r\n        const temp = n;\r\n        n = m;\r\n        m = temp;\r\n        Logger.Warn(\"n > m therefore m and n swapped\");\r\n    }\r\n    const primTri: _PrimaryIsoTriangle = new _PrimaryIsoTriangle();\r\n    primTri.build(m, n);\r\n    const geodesicData = GeodesicData.BuildGeodesicData(primTri);\r\n\r\n    const geoOptions: object = {\r\n        custom: geodesicData,\r\n        size: options.size,\r\n        sizeX: options.sizeX,\r\n        sizeY: options.sizeY,\r\n        sizeZ: options.sizeZ,\r\n        faceUV: options.faceUV,\r\n        faceColors: options.faceColors,\r\n        flat: options.flat,\r\n        updatable: options.updatable,\r\n        sideOrientation: options.sideOrientation,\r\n        frontUVs: options.frontUVs,\r\n        backUVs: options.backUVs,\r\n    };\r\n    const geodesic = CreatePolyhedron(name, geoOptions, scene);\r\n\r\n    return geodesic;\r\n}\r\n", "import type { Scene } from \"../scene\";\r\nimport type { Vector2 } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { FloatArray } from \"../types\";\r\n\r\nMesh._GoldbergMeshParser = (parsedMesh: any, scene: Scene): GoldbergMesh => {\r\n    return GoldbergMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Defines the set of goldberg data used to create the polygon\r\n */\r\nexport type GoldbergData = {\r\n    /**\r\n     * The list of Goldberg faces colors\r\n     */\r\n    faceColors: Color4[];\r\n    /**\r\n     * The list of Goldberg faces centers\r\n     */\r\n    faceCenters: Vector3[];\r\n    /**\r\n     * The list of Goldberg faces Z axis\r\n     */\r\n    faceZaxis: Vector3[];\r\n    /**\r\n     * The list of Goldberg faces Y axis\r\n     */\r\n    faceXaxis: Vector3[];\r\n    /**\r\n     * The list of Goldberg faces X axis\r\n     */\r\n    faceYaxis: Vector3[];\r\n    /**\r\n     * Defines the number of shared faces\r\n     */\r\n    nbSharedFaces: number;\r\n    /**\r\n     * Defines the number of unshared faces\r\n     */\r\n    nbUnsharedFaces: number;\r\n    /**\r\n     * Defines the total number of goldberg faces\r\n     */\r\n    nbFaces: number;\r\n    /**\r\n     * Defines the number of goldberg faces at the pole\r\n     */\r\n    nbFacesAtPole: number;\r\n    /**\r\n     * Defines the number of adjacent faces per goldberg faces\r\n     */\r\n    adjacentFaces: number[][];\r\n};\r\n\r\n/**\r\n * Mesh for a Goldberg Polyhedron which is made from 12 pentagonal and the rest hexagonal faces\r\n * @see https://en.wikipedia.org/wiki/Goldberg_polyhedron\r\n */\r\nexport class GoldbergMesh extends Mesh {\r\n    /**\r\n     * Defines the specific Goldberg data used in this mesh construction.\r\n     */\r\n    public goldbergData: GoldbergData = {\r\n        faceColors: [],\r\n        faceCenters: [],\r\n        faceZaxis: [],\r\n        faceXaxis: [],\r\n        faceYaxis: [],\r\n        nbSharedFaces: 0,\r\n        nbUnsharedFaces: 0,\r\n        nbFaces: 0,\r\n        nbFacesAtPole: 0,\r\n        adjacentFaces: [],\r\n    };\r\n\r\n    /**\r\n     * Gets the related Goldberg face from pole infos\r\n     * @param poleOrShared Defines the pole index or the shared face index if the fromPole parameter is passed in\r\n     * @param fromPole Defines an optional pole index to find the related info from\r\n     * @returns the goldberg face number\r\n     */\r\n    public relatedGoldbergFace(poleOrShared: number, fromPole?: number): number {\r\n        if (fromPole === void 0) {\r\n            if (poleOrShared > this.goldbergData.nbUnsharedFaces - 1) {\r\n                Logger.Warn(\"Maximum number of unshared faces used\");\r\n                poleOrShared = this.goldbergData.nbUnsharedFaces - 1;\r\n            }\r\n            return this.goldbergData.nbUnsharedFaces + poleOrShared;\r\n        }\r\n        if (poleOrShared > 11) {\r\n            Logger.Warn(\"Last pole used\");\r\n            poleOrShared = 11;\r\n        }\r\n        if (fromPole > this.goldbergData.nbFacesAtPole - 1) {\r\n            Logger.Warn(\"Maximum number of faces at a pole used\");\r\n            fromPole = this.goldbergData.nbFacesAtPole - 1;\r\n        }\r\n\r\n        return 12 + poleOrShared * this.goldbergData.nbFacesAtPole + fromPole;\r\n    }\r\n\r\n    private _changeGoldbergFaceColors(colorRange: (number | Color4)[][]): number[] {\r\n        for (let i = 0; i < colorRange.length; i++) {\r\n            const min: number = <number>colorRange[i][0];\r\n            const max: number = <number>colorRange[i][1];\r\n            const col: Color4 = <Color4>colorRange[i][2];\r\n            for (let f = min; f < max + 1; f++) {\r\n                this.goldbergData.faceColors[f] = col;\r\n            }\r\n        }\r\n\r\n        const newCols: number[] = [];\r\n        for (let f = 0; f < 12; f++) {\r\n            for (let i = 0; i < 5; i++) {\r\n                newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);\r\n            }\r\n        }\r\n        for (let f = 12; f < this.goldbergData.faceColors.length; f++) {\r\n            for (let i = 0; i < 6; i++) {\r\n                newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);\r\n            }\r\n        }\r\n        return newCols;\r\n    }\r\n\r\n    /**\r\n     * Set new goldberg face colors\r\n     * @param colorRange the new color to apply to the mesh\r\n     */\r\n    public setGoldbergFaceColors(colorRange: (number | Color4)[][]) {\r\n        const newCols = this._changeGoldbergFaceColors(colorRange);\r\n        this.setVerticesData(VertexBuffer.ColorKind, newCols);\r\n    }\r\n\r\n    /**\r\n     * Updates new goldberg face colors\r\n     * @param colorRange the new color to apply to the mesh\r\n     */\r\n    public updateGoldbergFaceColors(colorRange: (number | Color4)[][]) {\r\n        const newCols = this._changeGoldbergFaceColors(colorRange);\r\n        this.updateVerticesData(VertexBuffer.ColorKind, newCols);\r\n    }\r\n\r\n    private _changeGoldbergFaceUVs(uvRange: (number | Vector2)[][]): FloatArray {\r\n        const uvs: FloatArray = this.getVerticesData(VertexBuffer.UVKind)!!;\r\n        for (let i = 0; i < uvRange.length; i++) {\r\n            const min: number = <number>uvRange[i][0];\r\n            const max: number = <number>uvRange[i][1];\r\n            const center: Vector2 = <Vector2>uvRange[i][2];\r\n            const radius: number = <number>uvRange[i][3];\r\n            const angle: number = <number>uvRange[i][4];\r\n            const points5: number[] = [];\r\n            const points6: number[] = [];\r\n            let u: number;\r\n            let v: number;\r\n            for (let p = 0; p < 5; p++) {\r\n                u = center.x + radius * Math.cos(angle + (p * Math.PI) / 2.5);\r\n                v = center.y + radius * Math.sin(angle + (p * Math.PI) / 2.5);\r\n                if (u < 0) {\r\n                    u = 0;\r\n                }\r\n                if (u > 1) {\r\n                    u = 1;\r\n                }\r\n                points5.push(u, v);\r\n            }\r\n            for (let p = 0; p < 6; p++) {\r\n                u = center.x + radius * Math.cos(angle + (p * Math.PI) / 3);\r\n                v = center.y + radius * Math.sin(angle + (p * Math.PI) / 3);\r\n                if (u < 0) {\r\n                    u = 0;\r\n                }\r\n                if (u > 1) {\r\n                    u = 1;\r\n                }\r\n                points6.push(u, v);\r\n            }\r\n            for (let f = min; f < Math.min(12, max + 1); f++) {\r\n                for (let p = 0; p < 5; p++) {\r\n                    uvs[10 * f + 2 * p] = points5[2 * p];\r\n                    uvs[10 * f + 2 * p + 1] = points5[2 * p + 1];\r\n                }\r\n            }\r\n            for (let f = Math.max(12, min); f < max + 1; f++) {\r\n                for (let p = 0; p < 6; p++) {\r\n                    //120 + 12 * (f - 12) = 12 * f - 24\r\n                    uvs[12 * f - 24 + 2 * p] = points6[2 * p];\r\n                    uvs[12 * f - 23 + 2 * p] = points6[2 * p + 1];\r\n                }\r\n            }\r\n        }\r\n        return uvs;\r\n    }\r\n\r\n    /**\r\n     * set new goldberg face UVs\r\n     * @param uvRange the new UVs to apply to the mesh\r\n     */\r\n    public setGoldbergFaceUVs(uvRange: (number | Vector2)[][]) {\r\n        const newUVs: FloatArray = this._changeGoldbergFaceUVs(uvRange);\r\n        this.setVerticesData(VertexBuffer.UVKind, newUVs);\r\n    }\r\n\r\n    /**\r\n     * Updates new goldberg face UVs\r\n     * @param uvRange the new UVs to apply to the mesh\r\n     */\r\n    public updateGoldbergFaceUVs(uvRange: (number | Vector2)[][]) {\r\n        const newUVs = this._changeGoldbergFaceUVs(uvRange);\r\n        this.updateVerticesData(VertexBuffer.UVKind, newUVs);\r\n    }\r\n\r\n    /**\r\n     * Places a mesh on a particular face of the goldberg polygon\r\n     * @param mesh Defines the mesh to position\r\n     * @param face Defines the face to position onto\r\n     * @param position Defines the position relative to the face we are positioning the mesh onto\r\n     */\r\n    public placeOnGoldbergFaceAt(mesh: Mesh, face: number, position: Vector3) {\r\n        const orientation = Vector3.RotationFromAxis(this.goldbergData.faceXaxis[face], this.goldbergData.faceYaxis[face], this.goldbergData.faceZaxis[face]);\r\n        mesh.rotation = orientation;\r\n        mesh.position = this.goldbergData.faceCenters[face]\r\n            .add(this.goldbergData.faceXaxis[face].scale(position.x))\r\n            .add(this.goldbergData.faceYaxis[face].scale(position.y))\r\n            .add(this.goldbergData.faceZaxis[face].scale(position.z));\r\n    }\r\n\r\n    /**\r\n     * Serialize current mesh\r\n     * @param serializationObject defines the object which will receive the serialization data\r\n     */\r\n    public override serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.type = \"GoldbergMesh\";\r\n\r\n        const goldbergData: any = {};\r\n        goldbergData.adjacentFaces = this.goldbergData.adjacentFaces;\r\n        goldbergData.nbSharedFaces = this.goldbergData.nbSharedFaces;\r\n        goldbergData.nbUnsharedFaces = this.goldbergData.nbUnsharedFaces;\r\n        goldbergData.nbFaces = this.goldbergData.nbFaces;\r\n        goldbergData.nbFacesAtPole = this.goldbergData.nbFacesAtPole;\r\n\r\n        if (this.goldbergData.faceColors) {\r\n            goldbergData.faceColors = [];\r\n            for (const color of this.goldbergData.faceColors) {\r\n                goldbergData.faceColors.push(color.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceCenters) {\r\n            goldbergData.faceCenters = [];\r\n            for (const vector of this.goldbergData.faceCenters) {\r\n                goldbergData.faceCenters.push(vector.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceZaxis) {\r\n            goldbergData.faceZaxis = [];\r\n            for (const vector of this.goldbergData.faceZaxis) {\r\n                goldbergData.faceZaxis.push(vector.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceYaxis) {\r\n            goldbergData.faceYaxis = [];\r\n            for (const vector of this.goldbergData.faceYaxis) {\r\n                goldbergData.faceYaxis.push(vector.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceXaxis) {\r\n            goldbergData.faceXaxis = [];\r\n            for (const vector of this.goldbergData.faceXaxis) {\r\n                goldbergData.faceXaxis.push(vector.asArray());\r\n            }\r\n        }\r\n\r\n        serializationObject.goldbergData = goldbergData;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized goldberg mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the goldberg mesh in\r\n     * @returns the created goldberg mesh\r\n     */\r\n    public static override Parse(parsedMesh: any, scene: Scene): GoldbergMesh {\r\n        const goldbergData = parsedMesh.goldbergData;\r\n        goldbergData.faceColors = goldbergData.faceColors.map((el: number[]) => Color4.FromArray(el));\r\n        goldbergData.faceCenters = goldbergData.faceCenters.map((el: number[]) => Vector3.FromArray(el));\r\n        goldbergData.faceZaxis = goldbergData.faceZaxis.map((el: number[]) => Vector3.FromArray(el));\r\n        goldbergData.faceXaxis = goldbergData.faceXaxis.map((el: number[]) => Vector3.FromArray(el));\r\n        goldbergData.faceYaxis = goldbergData.faceYaxis.map((el: number[]) => Vector3.FromArray(el));\r\n\r\n        const goldberg = new GoldbergMesh(parsedMesh.name, scene);\r\n        goldberg.goldbergData = goldbergData;\r\n\r\n        return goldberg;\r\n    }\r\n}\r\n", "import type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { PolyhedronData } from \"../geodesicMesh\";\r\nimport { _PrimaryIsoTriangle, GeodesicData } from \"../geodesicMesh\";\r\nimport { GoldbergMesh } from \"../goldbergMesh\";\r\nimport { useOpenGLOrientationForUV } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Defines the set of data required to create goldberg vertex data.\r\n */\r\nexport type GoldbergVertexDataOption = {\r\n    /**\r\n     * the size of the Goldberg, optional default 1\r\n     */\r\n    size?: number;\r\n    /**\r\n     * allows stretching in the x direction, optional, default size\r\n     */\r\n    sizeX?: number;\r\n    /**\r\n     * allows stretching in the y direction, optional, default size\r\n     */\r\n    sizeY?: number;\r\n    /**\r\n     * allows stretching in the z direction, optional, default size\r\n     */\r\n    sizeZ?: number;\r\n    /**\r\n     * optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     */\r\n    sideOrientation?: number;\r\n};\r\n\r\n/**\r\n * Defines the set of data required to create a goldberg mesh.\r\n */\r\nexport type GoldbergCreationOption = {\r\n    /**\r\n     * number of horizontal steps along an isogrid\r\n     */\r\n    m?: number;\r\n    /**\r\n     * number of angled steps along an isogrid\r\n     */\r\n    n?: number;\r\n    /**\r\n     * defines if the mesh must be flagged as updatable\r\n     */\r\n    updatable?: boolean;\r\n} & GoldbergVertexDataOption;\r\n\r\n/**\r\n * Creates the Mesh for a Goldberg Polyhedron\r\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n * @param goldbergData polyhedronData defining the Goldberg polyhedron\r\n * @returns GoldbergSphere mesh\r\n */\r\nexport function CreateGoldbergVertexData(options: GoldbergVertexDataOption, goldbergData: PolyhedronData): VertexData {\r\n    const size = options.size;\r\n    const sizeX: number = options.sizeX || size || 1;\r\n    const sizeY: number = options.sizeY || size || 1;\r\n    const sizeZ: number = options.sizeZ || size || 1;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    const positions: number[] = [];\r\n    const indices: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n\r\n    let minX = Infinity;\r\n    let maxX = -Infinity;\r\n    let minY = Infinity;\r\n    let maxY = -Infinity;\r\n\r\n    for (let v = 0; v < goldbergData.vertex.length; v++) {\r\n        minX = Math.min(minX, goldbergData.vertex[v][0] * sizeX);\r\n        maxX = Math.max(maxX, goldbergData.vertex[v][0] * sizeX);\r\n        minY = Math.min(minY, goldbergData.vertex[v][1] * sizeY);\r\n        maxY = Math.max(maxY, goldbergData.vertex[v][1] * sizeY);\r\n    }\r\n\r\n    let index: number = 0;\r\n    for (let f = 0; f < goldbergData.face.length; f++) {\r\n        const verts = goldbergData.face[f];\r\n        const a = Vector3.FromArray(goldbergData.vertex[verts[0]]);\r\n        const b = Vector3.FromArray(goldbergData.vertex[verts[2]]);\r\n        const c = Vector3.FromArray(goldbergData.vertex[verts[1]]);\r\n        const ba = b.subtract(a);\r\n        const ca = c.subtract(a);\r\n        const norm = Vector3.Cross(ca, ba).normalize();\r\n        for (let v = 0; v < verts.length; v++) {\r\n            normals.push(norm.x, norm.y, norm.z);\r\n            const pdata = goldbergData.vertex[verts[v]];\r\n            positions.push(pdata[0] * sizeX, pdata[1] * sizeY, pdata[2] * sizeZ);\r\n            const vCoord = (pdata[1] * sizeY - minY) / (maxY - minY);\r\n            uvs.push((pdata[0] * sizeX - minX) / (maxX - minX), useOpenGLOrientationForUV ? 1 - vCoord : vCoord);\r\n        }\r\n        for (let v = 0; v < verts.length - 2; v++) {\r\n            indices.push(index, index + v + 2, index + v + 1);\r\n        }\r\n        index += verts.length;\r\n    }\r\n\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);\r\n\r\n    const vertexData = new VertexData();\r\n    vertexData.positions = positions;\r\n    vertexData.indices = indices;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates the Mesh for a Goldberg Polyhedron which is made from 12 pentagonal and the rest hexagonal faces\r\n * @see https://en.wikipedia.org/wiki/Goldberg_polyhedron\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/polyhedra/goldberg_poly\r\n * @param name defines the name of the mesh\r\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n * @param scene defines the hosting scene\r\n * @returns Goldberg mesh\r\n */\r\nexport function CreateGoldberg(name: string, options: GoldbergCreationOption, scene: Nullable<Scene> = null): GoldbergMesh {\r\n    const size = options.size;\r\n    const sizeX: number = options.sizeX || size || 1;\r\n    const sizeY: number = options.sizeY || size || 1;\r\n    const sizeZ: number = options.sizeZ || size || 1;\r\n    let m: number = options.m || 1;\r\n    if (m !== Math.floor(m)) {\r\n        m = Math.floor(m);\r\n        Logger.Warn(\"m not an integer only floor(m) used\");\r\n    }\r\n    let n: number = options.n || 0;\r\n    if (n !== Math.floor(n)) {\r\n        n = Math.floor(n);\r\n        Logger.Warn(\"n not an integer only floor(n) used\");\r\n    }\r\n    if (n > m) {\r\n        const temp = n;\r\n        n = m;\r\n        m = temp;\r\n        Logger.Warn(\"n > m therefore m and n swapped\");\r\n    }\r\n    const primTri: _PrimaryIsoTriangle = new _PrimaryIsoTriangle();\r\n    primTri.build(m, n);\r\n    const geodesicData = GeodesicData.BuildGeodesicData(primTri);\r\n    const goldbergData = geodesicData.toGoldbergPolyhedronData();\r\n\r\n    const goldberg = new GoldbergMesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    goldberg._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateGoldbergVertexData(options, goldbergData);\r\n\r\n    vertexData.applyToMesh(goldberg, options.updatable);\r\n\r\n    goldberg.goldbergData.nbSharedFaces = geodesicData.sharedNodes;\r\n    goldberg.goldbergData.nbUnsharedFaces = geodesicData.poleNodes;\r\n    goldberg.goldbergData.adjacentFaces = geodesicData.adjacentFaces;\r\n    goldberg.goldbergData.nbFaces = goldberg.goldbergData.nbSharedFaces + goldberg.goldbergData.nbUnsharedFaces;\r\n    goldberg.goldbergData.nbFacesAtPole = (goldberg.goldbergData.nbUnsharedFaces - 12) / 12;\r\n    for (let f = 0; f < geodesicData.vertex.length; f++) {\r\n        goldberg.goldbergData.faceCenters.push(Vector3.FromArray(geodesicData.vertex[f]));\r\n        goldberg.goldbergData.faceCenters[f].x *= sizeX;\r\n        goldberg.goldbergData.faceCenters[f].y *= sizeY;\r\n        goldberg.goldbergData.faceCenters[f].z *= sizeZ;\r\n        goldberg.goldbergData.faceColors.push(new Color4(1, 1, 1, 1));\r\n    }\r\n\r\n    for (let f = 0; f < goldbergData.face.length; f++) {\r\n        const verts = goldbergData.face[f];\r\n        const a = Vector3.FromArray(goldbergData.vertex[verts[0]]);\r\n        const b = Vector3.FromArray(goldbergData.vertex[verts[2]]);\r\n        const c = Vector3.FromArray(goldbergData.vertex[verts[1]]);\r\n        const ba = b.subtract(a);\r\n        const ca = c.subtract(a);\r\n        const norm = Vector3.Cross(ca, ba).normalize();\r\n        const z = Vector3.Cross(ca, norm).normalize();\r\n        goldberg.goldbergData.faceXaxis.push(ca.normalize());\r\n        goldberg.goldbergData.faceYaxis.push(norm);\r\n        goldberg.goldbergData.faceZaxis.push(z);\r\n    }\r\n\r\n    return goldberg;\r\n}\r\n", "import type { Color4 } from \"../../Maths/math.color\";\r\nimport { Path2 } from \"../../Maths/math.path\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { TransformNode } from \"../transformNode\";\r\nimport { ExtrudePolygon } from \"./polygonBuilder\";\r\n\r\ndeclare let earcut: any;\r\n\r\n/**\r\n * Parser inspired by https://github.com/mrdoob/three.js/blob/master/examples/jsm/loaders/FontLoader.js\r\n */\r\n\r\n// Interfaces\r\n\r\n/**\r\n * Represents glyph data generated by http://gero3.github.io/facetype.js/\r\n */\r\nexport interface IGlyphData {\r\n    /** Commands used to draw (line, move, curve, etc..) */\r\n    o: string;\r\n\r\n    /** Width */\r\n    ha: number;\r\n}\r\n\r\n/**\r\n * Represents font data generated by http://gero3.github.io/facetype.js/\r\n */\r\nexport interface IFontData {\r\n    /**\r\n     * Font resolution\r\n     */\r\n    resolution: number;\r\n    /** Underline tickness */\r\n    underlineThickness: number;\r\n    /** Bounding box */\r\n    boundingBox: {\r\n        yMax: number;\r\n        yMin: number;\r\n    };\r\n    /** List of supported glyphs */\r\n    glyphs: { [key: string]: IGlyphData };\r\n}\r\n\r\n// Shape functions\r\nclass ShapePath {\r\n    private _paths: Path2[] = [];\r\n    private _tempPaths: Path2[] = [];\r\n    private _holes: Path2[] = [];\r\n    private _currentPath: Path2;\r\n    private _resolution: number;\r\n\r\n    /** Create the ShapePath used to support glyphs\r\n     * @param resolution defines the resolution used to determine the number of points per curve (default is 4)\r\n     */\r\n    constructor(resolution: number) {\r\n        this._resolution = resolution;\r\n    }\r\n\r\n    /** Move the virtual cursor to a coordinate\r\n     * @param x defines the x coordinate\r\n     * @param y defines the y coordinate\r\n     */\r\n    moveTo(x: number, y: number) {\r\n        this._currentPath = new Path2(x, y);\r\n        this._tempPaths.push(this._currentPath);\r\n    }\r\n\r\n    /** Draw a line from the virtual cursor to a given coordinate\r\n     * @param x defines the x coordinate\r\n     * @param y defines the y coordinate\r\n     */\r\n    lineTo(x: number, y: number) {\r\n        this._currentPath.addLineTo(x, y);\r\n    }\r\n\r\n    /** Create a quadratic curve from the virtual cursor to a given coordinate\r\n     * @param cpx defines the x coordinate of the control point\r\n     * @param cpy defines the y coordinate of the control point\r\n     * @param x defines the x coordinate of the end point\r\n     * @param y defines the y coordinate of the end point\r\n     */\r\n    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number) {\r\n        this._currentPath.addQuadraticCurveTo(cpx, cpy, x, y, this._resolution);\r\n    }\r\n\r\n    /**\r\n     * Create a bezier curve from the virtual cursor to a given coordinate\r\n     * @param cpx1 defines the x coordinate of the first control point\r\n     * @param cpy1 defines the y coordinate of the first control point\r\n     * @param cpx2 defines the x coordinate of the second control point\r\n     * @param cpy2 defines the y coordinate of the second control point\r\n     * @param x defines the x coordinate of the end point\r\n     * @param y defines the y coordinate of the end point\r\n     */\r\n    bezierCurveTo(cpx1: number, cpy1: number, cpx2: number, cpy2: number, x: number, y: number) {\r\n        this._currentPath.addBezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, y, this._resolution);\r\n    }\r\n\r\n    /** Extract holes based on CW / CCW */\r\n    extractHoles() {\r\n        for (const path of this._tempPaths) {\r\n            if (path.area() > 0) {\r\n                this._holes.push(path);\r\n            } else {\r\n                this._paths.push(path);\r\n            }\r\n        }\r\n\r\n        if (!this._paths.length && this._holes.length) {\r\n            const temp = this._holes;\r\n            this._holes = this._paths;\r\n            this._paths = temp;\r\n        }\r\n\r\n        this._tempPaths.length = 0;\r\n    }\r\n\r\n    /** Gets the list of paths */\r\n    get paths() {\r\n        return this._paths;\r\n    }\r\n\r\n    /** Gets the list of holes */\r\n    get holes() {\r\n        return this._holes;\r\n    }\r\n}\r\n\r\n// Utility functions\r\nfunction CreateShapePath(\r\n    char: string,\r\n    scale: number,\r\n    offsetX: number,\r\n    offsetY: number,\r\n    resolution: number,\r\n    fontData: IFontData\r\n): Nullable<{\r\n    offsetX: number;\r\n    shapePath: ShapePath;\r\n}> {\r\n    const glyph = fontData.glyphs[char] || fontData.glyphs[\"?\"];\r\n\r\n    if (!glyph) {\r\n        // return if there is no glyph data\r\n        return null;\r\n    }\r\n\r\n    const shapePath = new ShapePath(resolution);\r\n\r\n    if (glyph.o) {\r\n        const outline = glyph.o.split(\" \");\r\n\r\n        for (let i = 0, l = outline.length; i < l; ) {\r\n            const action = outline[i++];\r\n\r\n            switch (action) {\r\n                case \"m\": {\r\n                    // moveTo\r\n                    const x = parseInt(outline[i++]) * scale + offsetX;\r\n                    const y = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.moveTo(x, y);\r\n                    break;\r\n                }\r\n                case \"l\": {\r\n                    // lineTo\r\n                    const x = parseInt(outline[i++]) * scale + offsetX;\r\n                    const y = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.lineTo(x, y);\r\n                    break;\r\n                }\r\n                case \"q\": {\r\n                    // quadraticCurveTo\r\n                    const cpx = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy = parseInt(outline[i++]) * scale + offsetY;\r\n                    const cpx1 = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy1 = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\r\n                    break;\r\n                }\r\n                case \"b\": {\r\n                    // bezierCurveTo\r\n                    const cpx = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy = parseInt(outline[i++]) * scale + offsetY;\r\n                    const cpx1 = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy1 = parseInt(outline[i++]) * scale + offsetY;\r\n                    const cpx2 = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy2 = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Extract holes (based on clockwise data)\r\n    shapePath.extractHoles();\r\n\r\n    return { offsetX: glyph.ha * scale, shapePath: shapePath };\r\n}\r\n\r\n/**\r\n * Creates shape paths from a text and font\r\n * @param text the text\r\n * @param size size of the font\r\n * @param resolution resolution of the font\r\n * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)\r\n * @returns array of ShapePath objects\r\n */\r\nexport function CreateTextShapePaths(text: string, size: number, resolution: number, fontData: IFontData) {\r\n    const chars = Array.from(text);\r\n    const scale = size / fontData.resolution;\r\n    const line_height = (fontData.boundingBox.yMax - fontData.boundingBox.yMin + fontData.underlineThickness) * scale;\r\n\r\n    const shapePaths: ShapePath[] = [];\r\n\r\n    let offsetX = 0,\r\n        offsetY = 0;\r\n\r\n    for (let i = 0; i < chars.length; i++) {\r\n        const char = chars[i];\r\n\r\n        if (char === \"\\n\") {\r\n            offsetX = 0;\r\n            offsetY -= line_height;\r\n        } else {\r\n            const ret = CreateShapePath(char, scale, offsetX, offsetY, resolution, fontData);\r\n\r\n            if (ret) {\r\n                offsetX += ret.offsetX;\r\n                shapePaths.push(ret.shapePath);\r\n            }\r\n        }\r\n    }\r\n\r\n    return shapePaths;\r\n}\r\n\r\n/**\r\n * Create a text mesh\r\n * @param name defines the name of the mesh\r\n * @param text defines the text to use to build the mesh\r\n * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)\r\n * @param options defines options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @param earcutInjection can be used to inject your own earcut reference\r\n * @returns a new Mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/text\r\n */\r\nexport function CreateText(\r\n    name: string,\r\n    text: string,\r\n    fontData: IFontData,\r\n    options: {\r\n        size?: number;\r\n        resolution?: number;\r\n        depth?: number;\r\n        sideOrientation?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        perLetterFaceUV?: (letterIndex: number) => Vector4[];\r\n        perLetterFaceColors?: (letterIndex: number) => Color4[];\r\n    } = {\r\n        size: 50,\r\n        resolution: 8,\r\n        depth: 1.0,\r\n    },\r\n    scene: Nullable<Scene> = null,\r\n    earcutInjection = earcut\r\n): Nullable<Mesh> {\r\n    // First we need to generate the paths\r\n    const shapePaths = CreateTextShapePaths(text, options.size || 50, options.resolution || 8, fontData);\r\n\r\n    // And extrude them\r\n    const meshes: Mesh[] = [];\r\n    let letterIndex = 0;\r\n    for (const shapePath of shapePaths) {\r\n        if (!shapePath.paths.length) {\r\n            continue;\r\n        }\r\n\r\n        const holes = shapePath.holes.slice(); // Copy it as we will update the copy\r\n        for (const path of shapePath.paths) {\r\n            const holeVectors: Vector3[][] = [];\r\n            const shapeVectors: Vector3[] = [];\r\n            const points = path.getPoints();\r\n            for (const point of points) {\r\n                shapeVectors.push(new Vector3(point.x, 0, point.y)); // ExtrudePolygon expects data on the xz plane\r\n            }\r\n\r\n            // Holes\r\n            const localHolesCopy = holes.slice();\r\n            for (const hole of localHolesCopy) {\r\n                const points = hole.getPoints();\r\n\r\n                let found = false;\r\n                for (const point of points) {\r\n                    if (path.isPointInside(point)) {\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!found) {\r\n                    continue;\r\n                }\r\n\r\n                const holePoints: Vector3[] = [];\r\n                for (const point of points) {\r\n                    holePoints.push(new Vector3(point.x, 0, point.y)); // ExtrudePolygon expects data on the xz plane\r\n                }\r\n                holeVectors.push(holePoints);\r\n\r\n                // Remove the hole as it was already used\r\n                holes.splice(holes.indexOf(hole), 1);\r\n            }\r\n\r\n            // There is at least a hole but it was unaffected\r\n            if (!holeVectors.length && holes.length) {\r\n                for (const hole of holes) {\r\n                    const points = hole.getPoints();\r\n                    const holePoints: Vector3[] = [];\r\n                    for (const point of points) {\r\n                        holePoints.push(new Vector3(point.x, 0, point.y)); // ExtrudePolygon expects data on the xz plane\r\n                    }\r\n                    holeVectors.push(holePoints);\r\n                }\r\n            }\r\n\r\n            // Extrusion!\r\n            const mesh = ExtrudePolygon(\r\n                name,\r\n                {\r\n                    shape: shapeVectors,\r\n                    holes: holeVectors.length ? holeVectors : undefined,\r\n                    depth: options.depth || 1.0,\r\n                    faceUV: options.faceUV || options.perLetterFaceUV?.(letterIndex),\r\n                    faceColors: options.faceColors || options.perLetterFaceColors?.(letterIndex),\r\n                    sideOrientation: Mesh._GetDefaultSideOrientation(options.sideOrientation || Mesh.DOUBLESIDE),\r\n                },\r\n                scene,\r\n                earcutInjection\r\n            );\r\n            meshes.push(mesh);\r\n            letterIndex++;\r\n        }\r\n    }\r\n\r\n    // Then we can merge everyone into one single mesh\r\n    const newMesh = Mesh.MergeMeshes(meshes, true, true);\r\n\r\n    if (newMesh) {\r\n        // Move pivot to desired center / bottom / center position\r\n        const bbox = newMesh.getBoundingInfo().boundingBox;\r\n        newMesh.position.x += -(bbox.minimumWorld.x + bbox.maximumWorld.x) / 2; // Mid X\r\n        newMesh.position.y += -(bbox.minimumWorld.y + bbox.maximumWorld.y) / 2; // Mid Z as it will rotate\r\n        newMesh.position.z += -(bbox.minimumWorld.z + bbox.maximumWorld.z) / 2 + bbox.extendSize.z; // Bottom Y as it will rotate\r\n        newMesh.name = name;\r\n\r\n        // Rotate 90 Up\r\n        const pivot = new TransformNode(\"pivot\", scene);\r\n        pivot.rotation.x = -Math.PI / 2;\r\n        newMesh.parent = pivot;\r\n\r\n        newMesh.bakeCurrentTransformIntoVertices();\r\n\r\n        // Remove the pivot\r\n        newMesh.parent = null;\r\n        pivot.dispose();\r\n    }\r\n\r\n    return newMesh;\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { CreateRibbon } from \"./Builders/ribbonBuilder\";\r\nimport { CreateDisc } from \"./Builders/discBuilder\";\r\nimport { CreateBox } from \"./Builders/boxBuilder\";\r\nimport { CreateTiledBox } from \"./Builders/tiledBoxBuilder\";\r\nimport { CreateSphere } from \"./Builders/sphereBuilder\";\r\nimport { CreateCylinder } from \"./Builders/cylinderBuilder\";\r\nimport { CreateTorus } from \"./Builders/torusBuilder\";\r\nimport { CreateTorusKnot } from \"./Builders/torusKnotBuilder\";\r\nimport { CreateDashedLines, CreateLineSystem, CreateLines } from \"./Builders/linesBuilder\";\r\nimport { CreatePolygon, ExtrudePolygon } from \"./Builders/polygonBuilder\";\r\nimport { ExtrudeShape, ExtrudeShapeCustom } from \"./Builders/shapeBuilder\";\r\nimport { CreateLathe } from \"./Builders/latheBuilder\";\r\nimport { CreatePlane } from \"./Builders/planeBuilder\";\r\nimport { CreateTiledPlane } from \"./Builders/tiledPlaneBuilder\";\r\nimport { CreateGround, CreateGroundFromHeightMap, CreateTiledGround } from \"./Builders/groundBuilder\";\r\nimport { CreateTube } from \"./Builders/tubeBuilder\";\r\nimport { CreatePolyhedron } from \"./Builders/polyhedronBuilder\";\r\nimport { CreateIcoSphere } from \"./Builders/icoSphereBuilder\";\r\nimport { CreateDecal } from \"./Builders/decalBuilder\";\r\nimport { CreateCapsule } from \"./Builders/capsuleBuilder\";\r\nimport { CreateGeodesic } from \"./Builders/geodesicBuilder\";\r\nimport { CreateGoldberg } from \"./Builders/goldbergBuilder\";\r\nimport { CreateText } from \"./Builders/textBuilder\";\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport const MeshBuilder = {\r\n    CreateBox,\r\n    CreateTiledBox,\r\n    CreateSphere,\r\n    CreateDisc,\r\n    CreateIcoSphere,\r\n    CreateRibbon,\r\n    CreateCylinder,\r\n    CreateTorus,\r\n    CreateTorusKnot,\r\n    CreateLineSystem,\r\n    CreateLines,\r\n    CreateDashedLines,\r\n    ExtrudeShape,\r\n    ExtrudeShapeCustom,\r\n    CreateLathe,\r\n    CreateTiledPlane,\r\n    CreatePlane,\r\n    CreateGround,\r\n    CreateTiledGround,\r\n    CreateGroundFromHeightMap,\r\n    CreatePolygon,\r\n    ExtrudePolygon,\r\n    CreateTube,\r\n    CreatePolyhedron,\r\n    CreateGeodesic,\r\n    CreateGoldberg,\r\n    CreateDecal,\r\n    CreateCapsule,\r\n    CreateText,\r\n};\r\n"],
  "mappings": "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",
  "names": ["l", "positions", "radius", "angle", "i", "v", "dashSize", "gapSize", "idx", "shape", "curve", "path3D", "scale", "rotation", "scaleFunction", "rotateFunction", "cap", "custom", "adjustFrame", "path", "path3D", "radius", "tessellation", "radiusFunction", "cap", "indices", "v", "fr", "isoId", "isoIdR", "y", "x", "points"]
}
