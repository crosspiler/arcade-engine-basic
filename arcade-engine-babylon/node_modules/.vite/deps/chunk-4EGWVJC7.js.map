{
  "version": 3,
  "sources": ["../../../dev/core/src/XR/webXRFeaturesManager.ts", "../../../dev/core/src/Behaviors/Meshes/handConstraintBehavior.ts", "../../../dev/core/src/Misc/webRequest.fetch.ts", "../../../dev/core/src/Loading/sceneLoader.ts", "../../../dev/core/src/Behaviors/Meshes/fadeInOutBehavior.ts", "../../../dev/core/src/Maths/math.scalar.ts", "../../../dev/core/src/Behaviors/Meshes/followBehavior.ts", "../../../dev/core/src/Behaviors/Meshes/baseSixDofDragBehavior.ts", "../../../dev/core/src/Behaviors/Meshes/sixDofDragBehavior.ts", "../../../dev/core/src/Behaviors/Meshes/surfaceMagnetismBehavior.ts", "../../../dev/core/src/Rendering/utilityLayerRenderer.ts", "../../../dev/core/src/Gizmos/gizmo.ts", "../../../dev/core/src/Misc/pivotTools.ts", "../../../dev/core/src/Behaviors/Meshes/pointerDragBehavior.ts"],
  "sourcesContent": ["import type { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { Observable } from \"core/Misc/observable\";\r\n\r\n/**\r\n * Defining the interface required for a (webxr) feature\r\n */\r\nexport interface IWebXRFeature extends IDisposable {\r\n    /**\r\n     * Is this feature attached\r\n     */\r\n    attached: boolean;\r\n    /**\r\n     * Should auto-attach be disabled?\r\n     */\r\n    disableAutoAttach: boolean;\r\n\r\n    /**\r\n     * Attach the feature to the session\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @param force should attachment be forced (even when already attached)\r\n     * @returns true if successful.\r\n     */\r\n    attach(force?: boolean): boolean;\r\n    /**\r\n     * Detach the feature from the session\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    detach(): boolean;\r\n\r\n    /**\r\n     * This function will be executed during before enabling the feature and can be used to not-allow enabling it.\r\n     * Note that at this point the session has NOT started, so this is purely checking if the browser supports it\r\n     *\r\n     * @returns whether or not the feature is compatible in this environment\r\n     */\r\n    isCompatible(): boolean;\r\n\r\n    /**\r\n     * Was this feature disposed;\r\n     */\r\n    isDisposed: boolean;\r\n\r\n    /**\r\n     * The name of the native xr feature name, if applicable (like anchor, hit-test, or hand-tracking)\r\n     */\r\n    xrNativeFeatureName?: string;\r\n\r\n    /**\r\n     * A list of (Babylon WebXR) features this feature depends on\r\n     */\r\n    dependsOn?: string[];\r\n\r\n    /**\r\n     * If this feature requires to extend the XRSessionInit object, this function will return the partial XR session init object\r\n     */\r\n    getXRSessionInitExtension?: () => Promise<Partial<XRSessionInit>>;\r\n\r\n    /**\r\n     * Triggered when the feature is attached\r\n     */\r\n    onFeatureAttachObservable: Observable<IWebXRFeature>;\r\n    /**\r\n     * Triggered when the feature is detached\r\n     */\r\n    onFeatureDetachObservable: Observable<IWebXRFeature>;\r\n}\r\n\r\n/**\r\n * A list of the currently available features without referencing them\r\n */\r\nexport class WebXRFeatureName {\r\n    /**\r\n     * The name of the anchor system feature\r\n     */\r\n    public static readonly ANCHOR_SYSTEM = \"xr-anchor-system\";\r\n    /**\r\n     * The name of the background remover feature\r\n     */\r\n    public static readonly BACKGROUND_REMOVER = \"xr-background-remover\";\r\n    /**\r\n     * The name of the hit test feature\r\n     */\r\n    public static readonly HIT_TEST = \"xr-hit-test\";\r\n    /**\r\n     * The name of the mesh detection feature\r\n     */\r\n    public static readonly MESH_DETECTION = \"xr-mesh-detection\";\r\n    /**\r\n     * physics impostors for xr controllers feature\r\n     */\r\n    public static readonly PHYSICS_CONTROLLERS = \"xr-physics-controller\";\r\n    /**\r\n     * The name of the plane detection feature\r\n     */\r\n    public static readonly PLANE_DETECTION = \"xr-plane-detection\";\r\n    /**\r\n     * The name of the pointer selection feature\r\n     */\r\n    public static readonly POINTER_SELECTION = \"xr-controller-pointer-selection\";\r\n    /**\r\n     * The name of the teleportation feature\r\n     */\r\n    public static readonly TELEPORTATION = \"xr-controller-teleportation\";\r\n    /**\r\n     * The name of the feature points feature.\r\n     */\r\n    public static readonly FEATURE_POINTS = \"xr-feature-points\";\r\n    /**\r\n     * The name of the hand tracking feature.\r\n     */\r\n    public static readonly HAND_TRACKING = \"xr-hand-tracking\";\r\n    /**\r\n     * The name of the image tracking feature\r\n     */\r\n    public static readonly IMAGE_TRACKING = \"xr-image-tracking\";\r\n    /**\r\n     * The name of the near interaction feature\r\n     */\r\n    public static readonly NEAR_INTERACTION = \"xr-near-interaction\";\r\n    /**\r\n     * The name of the DOM overlay feature\r\n     */\r\n    public static readonly DOM_OVERLAY = \"xr-dom-overlay\";\r\n    /**\r\n     * The name of the movement feature\r\n     */\r\n    public static readonly MOVEMENT = \"xr-controller-movement\";\r\n    /**\r\n     * The name of the light estimation feature\r\n     */\r\n    public static readonly LIGHT_ESTIMATION = \"xr-light-estimation\";\r\n    /**\r\n     * The name of the eye tracking feature\r\n     */\r\n    public static readonly EYE_TRACKING = \"xr-eye-tracking\";\r\n    /**\r\n     * The name of the walking locomotion feature\r\n     */\r\n    public static readonly WALKING_LOCOMOTION = \"xr-walking-locomotion\";\r\n    /**\r\n     * The name of the composition layers feature\r\n     */\r\n    public static readonly LAYERS = \"xr-layers\";\r\n    /**\r\n     * The name of the depth sensing feature\r\n     */\r\n    public static readonly DEPTH_SENSING = \"xr-depth-sensing\";\r\n    /**\r\n     * The name of the WebXR Space Warp feature\r\n     */\r\n    public static readonly SPACE_WARP = \"xr-space-warp\";\r\n    /**\r\n     * The name of the WebXR Raw Camera Access feature\r\n     */\r\n    public static readonly RAW_CAMERA_ACCESS = \"xr-raw-camera-access\";\r\n}\r\n\r\n/**\r\n * Defining the constructor of a feature. Used to register the modules.\r\n */\r\nexport type WebXRFeatureConstructor = (xrSessionManager: WebXRSessionManager, options?: any) => () => IWebXRFeature;\r\n\r\n/**\r\n * The WebXR features manager is responsible of enabling or disabling features required for the current XR session.\r\n * It is mainly used in AR sessions.\r\n *\r\n * A feature can have a version that is defined by Babylon (and does not correspond with the webxr version).\r\n */\r\nexport class WebXRFeaturesManager implements IDisposable {\r\n    private static readonly _AvailableFeatures: {\r\n        [name: string]: {\r\n            stable: number;\r\n            latest: number;\r\n            [version: number]: WebXRFeatureConstructor;\r\n        };\r\n    } = {};\r\n\r\n    private _features: {\r\n        [name: string]: {\r\n            featureImplementation: IWebXRFeature;\r\n            version: number;\r\n            enabled: boolean;\r\n            required: boolean;\r\n        };\r\n    } = {};\r\n\r\n    /**\r\n     * The key is the feature to check and the value is the feature that conflicts.\r\n     */\r\n    private static readonly _ConflictingFeatures: { [key: string]: string } = {\r\n        [WebXRFeatureName.TELEPORTATION]: WebXRFeatureName.MOVEMENT,\r\n        [WebXRFeatureName.MOVEMENT]: WebXRFeatureName.TELEPORTATION,\r\n    };\r\n\r\n    /**\r\n     * constructs a new features manages.\r\n     *\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     */\r\n    constructor(private _xrSessionManager: WebXRSessionManager) {\r\n        // when session starts / initialized - attach\r\n        this._xrSessionManager.onXRSessionInit.add(() => {\r\n            this.getEnabledFeatures().forEach((featureName) => {\r\n                const feature = this._features[featureName];\r\n                if (feature.enabled && !feature.featureImplementation.attached && !feature.featureImplementation.disableAutoAttach) {\r\n                    this.attachFeature(featureName);\r\n                }\r\n            });\r\n        });\r\n\r\n        // when session ends - detach\r\n        this._xrSessionManager.onXRSessionEnded.add(() => {\r\n            this.getEnabledFeatures().forEach((featureName) => {\r\n                const feature = this._features[featureName];\r\n                if (feature.enabled && feature.featureImplementation.attached) {\r\n                    // detach, but don't disable!\r\n                    this.detachFeature(featureName);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Used to register a module. After calling this function a developer can use this feature in the scene.\r\n     * Mainly used internally.\r\n     *\r\n     * @param featureName the name of the feature to register\r\n     * @param constructorFunction the function used to construct the module\r\n     * @param version the (babylon) version of the module\r\n     * @param stable is that a stable version of this module\r\n     */\r\n    public static AddWebXRFeature(featureName: string, constructorFunction: WebXRFeatureConstructor, version: number = 1, stable: boolean = false) {\r\n        this._AvailableFeatures[featureName] = this._AvailableFeatures[featureName] || { latest: version };\r\n        if (version > this._AvailableFeatures[featureName].latest) {\r\n            this._AvailableFeatures[featureName].latest = version;\r\n        }\r\n        if (stable) {\r\n            this._AvailableFeatures[featureName].stable = version;\r\n        }\r\n        this._AvailableFeatures[featureName][version] = constructorFunction;\r\n    }\r\n\r\n    /**\r\n     * Returns a constructor of a specific feature.\r\n     *\r\n     * @param featureName the name of the feature to construct\r\n     * @param version the version of the feature to load\r\n     * @param xrSessionManager the xrSessionManager. Used to construct the module\r\n     * @param options optional options provided to the module.\r\n     * @returns a function that, when called, will return a new instance of this feature\r\n     */\r\n    public static ConstructFeature(featureName: string, version: number = 1, xrSessionManager: WebXRSessionManager, options?: any): () => IWebXRFeature {\r\n        const constructorFunction = this._AvailableFeatures[featureName][version];\r\n        if (!constructorFunction) {\r\n            // throw an error? return nothing?\r\n            throw new Error(\"feature not found\");\r\n        }\r\n\r\n        return constructorFunction(xrSessionManager, options);\r\n    }\r\n\r\n    /**\r\n     * Can be used to return the list of features currently registered\r\n     *\r\n     * @returns an Array of available features\r\n     */\r\n    public static GetAvailableFeatures() {\r\n        return Object.keys(this._AvailableFeatures);\r\n    }\r\n\r\n    /**\r\n     * Gets the versions available for a specific feature\r\n     * @param featureName the name of the feature\r\n     * @returns an array with the available versions\r\n     */\r\n    public static GetAvailableVersions(featureName: string) {\r\n        return Object.keys(this._AvailableFeatures[featureName]);\r\n    }\r\n\r\n    /**\r\n     * Return the latest unstable version of this feature\r\n     * @param featureName the name of the feature to search\r\n     * @returns the version number. if not found will return -1\r\n     */\r\n    public static GetLatestVersionOfFeature(featureName: string): number {\r\n        return (this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].latest) || -1;\r\n    }\r\n\r\n    /**\r\n     * Return the latest stable version of this feature\r\n     * @param featureName the name of the feature to search\r\n     * @returns the version number. if not found will return -1\r\n     */\r\n    public static GetStableVersionOfFeature(featureName: string): number {\r\n        return (this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].stable) || -1;\r\n    }\r\n\r\n    /**\r\n     * Attach a feature to the current session. Mainly used when session started to start the feature effect.\r\n     * Can be used during a session to start a feature\r\n     * @param featureName the name of feature to attach\r\n     */\r\n    public attachFeature(featureName: string) {\r\n        const feature = this._features[featureName];\r\n        if (feature && feature.enabled && !feature.featureImplementation.attached) {\r\n            const attached = feature.featureImplementation.attach();\r\n            if (!attached) {\r\n                Tools.Warn(`Feature ${featureName} failed to attach`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Can be used inside a session or when the session ends to detach a specific feature\r\n     * @param featureName the name of the feature to detach\r\n     */\r\n    public detachFeature(featureName: string) {\r\n        const feature = this._features[featureName];\r\n        if (feature && feature.featureImplementation.attached) {\r\n            const detached = feature.featureImplementation.detach();\r\n            if (!detached) {\r\n                Tools.Warn(`Feature ${featureName} failed to detach`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Used to disable an already-enabled feature\r\n     * The feature will be disposed and will be recreated once enabled.\r\n     * @param featureName the feature to disable\r\n     * @returns true if disable was successful\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public disableFeature(featureName: string | { Name: string }): boolean {\r\n        const name = typeof featureName === \"string\" ? featureName : featureName.Name;\r\n        const feature = this._features[name];\r\n        if (feature && feature.enabled) {\r\n            feature.enabled = false;\r\n            this.detachFeature(name);\r\n            feature.featureImplementation.dispose();\r\n            delete this._features[name];\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * dispose this features manager\r\n     */\r\n    public dispose(): void {\r\n        this.getEnabledFeatures().forEach((feature) => {\r\n            this.disableFeature(feature);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Enable a feature using its name and a version. This will enable it in the scene, and will be responsible to attach it when the session starts.\r\n     * If used twice, the old version will be disposed and a new one will be constructed. This way you can re-enable with different configuration.\r\n     *\r\n     * @param featureName the name of the feature to load or the class of the feature\r\n     * @param version optional version to load. if not provided the latest version will be enabled\r\n     * @param moduleOptions options provided to the module. Ses the module documentation / constructor\r\n     * @param attachIfPossible if set to true (default) the feature will be automatically attached, if it is currently possible\r\n     * @param required is this feature required to the app. If set to true the session init will fail if the feature is not available.\r\n     * @returns a new constructed feature or throws an error if feature not found or conflicts with another enabled feature.\r\n     */\r\n    public enableFeature(\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        featureName: string | { Name: string },\r\n        version: number | string = \"latest\",\r\n        moduleOptions: any = {},\r\n        attachIfPossible: boolean = true,\r\n        required: boolean = true\r\n    ): IWebXRFeature {\r\n        const name = typeof featureName === \"string\" ? featureName : featureName.Name;\r\n        let versionToLoad = 0;\r\n        if (typeof version === \"string\") {\r\n            if (!version) {\r\n                throw new Error(`Error in provided version - ${name} (${version})`);\r\n            }\r\n            if (version === \"stable\") {\r\n                versionToLoad = WebXRFeaturesManager.GetStableVersionOfFeature(name);\r\n            } else if (version === \"latest\") {\r\n                versionToLoad = WebXRFeaturesManager.GetLatestVersionOfFeature(name);\r\n            } else {\r\n                // try loading the number the string represents\r\n                versionToLoad = +version;\r\n            }\r\n            if (versionToLoad === -1 || isNaN(versionToLoad)) {\r\n                throw new Error(`feature not found - ${name} (${version})`);\r\n            }\r\n        } else {\r\n            versionToLoad = version;\r\n        }\r\n\r\n        // check if there is a feature conflict\r\n        const conflictingFeature = WebXRFeaturesManager._ConflictingFeatures[name];\r\n        if (conflictingFeature !== undefined && this.getEnabledFeatures().indexOf(conflictingFeature) !== -1) {\r\n            throw new Error(`Feature ${name} cannot be enabled while ${conflictingFeature} is enabled.`);\r\n        }\r\n\r\n        // check if already initialized\r\n        const feature = this._features[name];\r\n        const constructFunction = WebXRFeaturesManager.ConstructFeature(name, versionToLoad, this._xrSessionManager, moduleOptions);\r\n        if (!constructFunction) {\r\n            // report error?\r\n            throw new Error(`feature not found - ${name}`);\r\n        }\r\n\r\n        /* If the feature is already enabled, detach and dispose it, and create a new one */\r\n        if (feature) {\r\n            this.disableFeature(name);\r\n        }\r\n\r\n        const constructed = constructFunction();\r\n        if (constructed.dependsOn) {\r\n            const dependentsFound = constructed.dependsOn.every((featureName) => !!this._features[featureName]);\r\n            if (!dependentsFound) {\r\n                throw new Error(`Dependant features missing. Make sure the following features are enabled - ${constructed.dependsOn.join(\", \")}`);\r\n            }\r\n        }\r\n        if (constructed.isCompatible()) {\r\n            this._features[name] = {\r\n                featureImplementation: constructed,\r\n                enabled: true,\r\n                version: versionToLoad,\r\n                required,\r\n            };\r\n\r\n            if (attachIfPossible) {\r\n                // if session started already, request and enable\r\n                if (this._xrSessionManager.session && !this._features[name].featureImplementation.attached) {\r\n                    // enable feature\r\n                    this.attachFeature(name);\r\n                }\r\n            } else {\r\n                // disable auto-attach when session starts\r\n                this._features[name].featureImplementation.disableAutoAttach = true;\r\n            }\r\n\r\n            return this._features[name].featureImplementation;\r\n        } else {\r\n            if (required) {\r\n                throw new Error(\"required feature not compatible\");\r\n            } else {\r\n                Tools.Warn(`Feature ${name} not compatible with the current environment/browser and was not enabled.`);\r\n                return constructed;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get the implementation of an enabled feature.\r\n     * @param featureName the name of the feature to load\r\n     * @returns the feature class, if found\r\n     */\r\n    public getEnabledFeature(featureName: string): IWebXRFeature {\r\n        return this._features[featureName] && this._features[featureName].featureImplementation;\r\n    }\r\n\r\n    /**\r\n     * Get the list of enabled features\r\n     * @returns an array of enabled features\r\n     */\r\n    public getEnabledFeatures() {\r\n        return Object.keys(this._features);\r\n    }\r\n\r\n    /**\r\n     * This function will extend the session creation configuration object with enabled features.\r\n     * If, for example, the anchors feature is enabled, it will be automatically added to the optional or required features list,\r\n     * according to the defined \"required\" variable, provided during enableFeature call\r\n     * @param xrSessionInit the xr Session init object to extend\r\n     *\r\n     * @returns an extended XRSessionInit object\r\n     */\r\n    public async _extendXRSessionInitObject(xrSessionInit: XRSessionInit): Promise<XRSessionInit> {\r\n        const enabledFeatures = this.getEnabledFeatures();\r\n        for (const featureName of enabledFeatures) {\r\n            const feature = this._features[featureName];\r\n            const nativeName = feature.featureImplementation.xrNativeFeatureName;\r\n            if (nativeName) {\r\n                if (feature.required) {\r\n                    xrSessionInit.requiredFeatures = xrSessionInit.requiredFeatures || [];\r\n                    if (xrSessionInit.requiredFeatures.indexOf(nativeName) === -1) {\r\n                        xrSessionInit.requiredFeatures.push(nativeName);\r\n                    }\r\n                } else {\r\n                    xrSessionInit.optionalFeatures = xrSessionInit.optionalFeatures || [];\r\n                    if (xrSessionInit.optionalFeatures.indexOf(nativeName) === -1) {\r\n                        xrSessionInit.optionalFeatures.push(nativeName);\r\n                    }\r\n                }\r\n            }\r\n            if (feature.featureImplementation.getXRSessionInitExtension) {\r\n                const extended = await feature.featureImplementation.getXRSessionInitExtension();\r\n                xrSessionInit = {\r\n                    ...xrSessionInit,\r\n                    ...extended,\r\n                };\r\n            }\r\n        }\r\n        return xrSessionInit;\r\n    }\r\n}\r\n", "import type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { WebXRFeatureName } from \"../../XR/webXRFeaturesManager\";\r\nimport type { WebXRFeaturesManager } from \"../../XR/webXRFeaturesManager\";\r\nimport type { WebXREyeTracking } from \"../../XR/features/WebXREyeTracking\";\r\nimport type { WebXRHandTracking } from \"../../XR/features/WebXRHandTracking\";\r\nimport { WebXRHandJoint } from \"../../XR/features/WebXRHandTracking\";\r\nimport type { WebXRExperienceHelper } from \"../../XR/webXRExperienceHelper\";\r\nimport type { Behavior } from \"../behavior\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Ray } from \"../../Culling/ray\";\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\n/**\r\n * Zones around the hand\r\n */\r\nexport const enum HandConstraintZone {\r\n    /**\r\n     * Above finger tips\r\n     */\r\n    ABOVE_FINGER_TIPS,\r\n    /**\r\n     * Next to the thumb\r\n     */\r\n    RADIAL_SIDE,\r\n    /**\r\n     * Next to the pinky finger\r\n     */\r\n    ULNAR_SIDE,\r\n    /**\r\n     * Below the wrist\r\n     */\r\n    BELOW_WRIST,\r\n}\r\n\r\n/**\r\n * Orientations for the hand zones and for the attached node\r\n */\r\nexport const enum HandConstraintOrientation {\r\n    /**\r\n     * Orientation is towards the camera\r\n     */\r\n    LOOK_AT_CAMERA,\r\n    /**\r\n     * Orientation is determined by the rotation of the palm\r\n     */\r\n    HAND_ROTATION,\r\n}\r\n\r\n/**\r\n * Orientations for the hand zones and for the attached node\r\n */\r\nexport const enum HandConstraintVisibility {\r\n    /**\r\n     * Constraint is always visible\r\n     */\r\n    ALWAYS_VISIBLE,\r\n    /**\r\n     * Constraint is only visible when the palm is up\r\n     */\r\n    PALM_UP,\r\n    /**\r\n     * Constraint is only visible when the user is looking at the constraint.\r\n     * Uses XR Eye Tracking if enabled/available, otherwise uses camera direction\r\n     */\r\n    GAZE_FOCUS,\r\n    /**\r\n     * Constraint is only visible when the palm is up and the user is looking at it\r\n     */\r\n    PALM_AND_GAZE,\r\n}\r\n\r\ntype HandPoseInfo = {\r\n    position: Vector3;\r\n    quaternion: Quaternion;\r\n    id: string;\r\n};\r\n\r\n/**\r\n * Hand constraint behavior that makes the attached `TransformNode` follow hands in XR experiences.\r\n * @since 5.0.0\r\n */\r\nexport class HandConstraintBehavior implements Behavior<TransformNode> {\r\n    private _scene: Scene;\r\n    private _node: TransformNode;\r\n    private _eyeTracking: Nullable<WebXREyeTracking>;\r\n    private _handTracking: Nullable<WebXRHandTracking>;\r\n    private _sceneRenderObserver: Nullable<Observer<Scene>> = null;\r\n    private _zoneAxis: { [id: number]: Vector3 } = {};\r\n\r\n    /**\r\n     * Sets the HandConstraintVisibility level for the hand constraint\r\n     */\r\n    public handConstraintVisibility: HandConstraintVisibility = HandConstraintVisibility.PALM_AND_GAZE;\r\n\r\n    /**\r\n     * A number from 0.0 to 1.0, marking how restricted the direction the palm faces is for the attached node to be enabled.\r\n     * A 1 means the palm must be directly facing the user before the node is enabled, a 0 means it is always enabled.\r\n     * Used with HandConstraintVisibility.PALM_UP\r\n     */\r\n    public palmUpStrictness: number = 0.95;\r\n\r\n    /**\r\n     * The radius in meters around the center of the hand that the user must gaze inside for the attached node to be enabled and appear.\r\n     * Used with HandConstraintVisibility.GAZE_FOCUS\r\n     */\r\n    public gazeProximityRadius: number = 0.15;\r\n\r\n    /**\r\n     * Offset distance from the hand in meters\r\n     */\r\n    public targetOffset: number = 0.1;\r\n\r\n    /**\r\n     * Where to place the node regarding the center of the hand.\r\n     */\r\n    public targetZone: HandConstraintZone = HandConstraintZone.ULNAR_SIDE;\r\n\r\n    /**\r\n     * Orientation mode of the 4 zones around the hand\r\n     */\r\n    public zoneOrientationMode: HandConstraintOrientation = HandConstraintOrientation.HAND_ROTATION;\r\n    /**\r\n     * Orientation mode of the node attached to this behavior\r\n     */\r\n    public nodeOrientationMode: HandConstraintOrientation = HandConstraintOrientation.HAND_ROTATION;\r\n\r\n    /**\r\n     * Set the hand this behavior should follow. If set to \"none\", it will follow any visible hand (prioritising the left one).\r\n     */\r\n    public handedness: XRHandedness = \"none\";\r\n\r\n    /**\r\n     * Rate of interpolation of position and rotation of the attached node.\r\n     * Higher values will give a slower interpolation.\r\n     */\r\n    public lerpTime = 100;\r\n\r\n    /**\r\n     * Builds a hand constraint behavior\r\n     */\r\n    constructor() {\r\n        // For a right hand\r\n        this._zoneAxis[HandConstraintZone.ABOVE_FINGER_TIPS] = new Vector3(0, 1, 0);\r\n        this._zoneAxis[HandConstraintZone.RADIAL_SIDE] = new Vector3(-1, 0, 0);\r\n        this._zoneAxis[HandConstraintZone.ULNAR_SIDE] = new Vector3(1, 0, 0);\r\n        this._zoneAxis[HandConstraintZone.BELOW_WRIST] = new Vector3(0, -1, 0);\r\n    }\r\n\r\n    /** gets or sets behavior's name */\r\n    public get name() {\r\n        return \"HandConstraint\";\r\n    }\r\n\r\n    /** Enable the behavior */\r\n    public enable() {\r\n        this._node.setEnabled(true);\r\n    }\r\n\r\n    /** Disable the behavior */\r\n    public disable() {\r\n        this._node.setEnabled(false);\r\n    }\r\n\r\n    private _getHandPose(): Nullable<HandPoseInfo> {\r\n        if (!this._handTracking) {\r\n            return null;\r\n        }\r\n\r\n        // Retrieve any available hand, starting by the left\r\n        let hand;\r\n        if (this.handedness === \"none\") {\r\n            hand = this._handTracking.getHandByHandedness(\"left\") || this._handTracking.getHandByHandedness(\"right\");\r\n        } else {\r\n            hand = this._handTracking.getHandByHandedness(this.handedness);\r\n        }\r\n\r\n        if (hand) {\r\n            const pinkyMetacarpal = hand.getJointMesh(WebXRHandJoint.PINKY_FINGER_METACARPAL);\r\n            const middleMetacarpal = hand.getJointMesh(WebXRHandJoint.MIDDLE_FINGER_METACARPAL);\r\n            const wrist = hand.getJointMesh(WebXRHandJoint.WRIST);\r\n\r\n            if (wrist && middleMetacarpal && pinkyMetacarpal) {\r\n                const handPose: HandPoseInfo = { position: middleMetacarpal.absolutePosition, quaternion: new Quaternion(), id: hand.xrController.uniqueId };\r\n\r\n                // palm forward\r\n                const up = TmpVectors.Vector3[0];\r\n                const forward = TmpVectors.Vector3[1];\r\n                const left = TmpVectors.Vector3[2];\r\n                up.copyFrom(middleMetacarpal.absolutePosition).subtractInPlace(wrist.absolutePosition).normalize();\r\n                forward.copyFrom(pinkyMetacarpal.absolutePosition).subtractInPlace(middleMetacarpal.absolutePosition).normalize();\r\n\r\n                // Create vectors for a rotation quaternion, where forward points out from the palm\r\n                Vector3.CrossToRef(up, forward, forward);\r\n                Vector3.CrossToRef(forward, up, left);\r\n\r\n                Quaternion.FromLookDirectionLHToRef(forward, up, handPose.quaternion);\r\n\r\n                return handPose;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Initializes the hand constraint behavior\r\n     */\r\n    public init() {}\r\n\r\n    /**\r\n     * Attaches the hand constraint to a `TransformNode`\r\n     * @param node defines the node to attach the behavior to\r\n     */\r\n    public attach(node: TransformNode): void {\r\n        this._node = node;\r\n        this._scene = node.getScene();\r\n\r\n        if (!this._node.rotationQuaternion) {\r\n            this._node.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._node.rotation.y, this._node.rotation.x, this._node.rotation.z);\r\n        }\r\n\r\n        let lastTick = Date.now();\r\n        this._sceneRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\r\n            const pose = this._getHandPose();\r\n\r\n            this._node.reservedDataStore = this._node.reservedDataStore || {};\r\n            this._node.reservedDataStore.nearInteraction = this._node.reservedDataStore.nearInteraction || {};\r\n            this._node.reservedDataStore.nearInteraction.excludedControllerId = null;\r\n\r\n            if (pose) {\r\n                const zoneOffset = TmpVectors.Vector3[0];\r\n                const camera = this._scene.activeCamera;\r\n\r\n                zoneOffset.copyFrom(this._zoneAxis[this.targetZone]);\r\n\r\n                const cameraLookAtQuaternion = TmpVectors.Quaternion[0];\r\n                if (camera && (this.zoneOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA || this.nodeOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA)) {\r\n                    const toCamera = TmpVectors.Vector3[1];\r\n                    toCamera.copyFrom(camera.position).subtractInPlace(pose.position).normalize();\r\n                    if (this._scene.useRightHandedSystem) {\r\n                        Quaternion.FromLookDirectionRHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);\r\n                    } else {\r\n                        Quaternion.FromLookDirectionLHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);\r\n                    }\r\n                }\r\n\r\n                if (this.zoneOrientationMode === HandConstraintOrientation.HAND_ROTATION) {\r\n                    pose.quaternion.toRotationMatrix(TmpVectors.Matrix[0]);\r\n                } else {\r\n                    cameraLookAtQuaternion.toRotationMatrix(TmpVectors.Matrix[0]);\r\n                }\r\n\r\n                Vector3.TransformNormalToRef(zoneOffset, TmpVectors.Matrix[0], zoneOffset);\r\n                zoneOffset.scaleInPlace(this.targetOffset);\r\n\r\n                const targetPosition = TmpVectors.Vector3[2];\r\n                const targetRotation = TmpVectors.Quaternion[1];\r\n                targetPosition.copyFrom(pose.position).addInPlace(zoneOffset);\r\n\r\n                if (this.nodeOrientationMode === HandConstraintOrientation.HAND_ROTATION) {\r\n                    targetRotation.copyFrom(pose.quaternion);\r\n                } else {\r\n                    targetRotation.copyFrom(cameraLookAtQuaternion);\r\n                }\r\n\r\n                const elapsed = Date.now() - lastTick;\r\n\r\n                Vector3.SmoothToRef(this._node.position, targetPosition, elapsed, this.lerpTime, this._node.position);\r\n                Quaternion.SmoothToRef(this._node.rotationQuaternion!, targetRotation, elapsed, this.lerpTime, this._node.rotationQuaternion!);\r\n\r\n                this._node.reservedDataStore.nearInteraction.excludedControllerId = pose.id;\r\n            }\r\n\r\n            this._setVisibility(pose);\r\n\r\n            lastTick = Date.now();\r\n        });\r\n    }\r\n\r\n    private _setVisibility(pose: Nullable<HandPoseInfo>) {\r\n        let palmVisible = true;\r\n        let gazeVisible = true;\r\n        const camera = this._scene.activeCamera;\r\n\r\n        if (camera) {\r\n            const cameraForward = camera.getForwardRay();\r\n\r\n            if (this.handConstraintVisibility === HandConstraintVisibility.GAZE_FOCUS || this.handConstraintVisibility === HandConstraintVisibility.PALM_AND_GAZE) {\r\n                gazeVisible = false;\r\n                let gaze: Ray | undefined;\r\n                if (this._eyeTracking) {\r\n                    gaze = this._eyeTracking.getEyeGaze()!;\r\n                }\r\n\r\n                gaze = gaze || cameraForward;\r\n\r\n                const gazeToBehavior = TmpVectors.Vector3[0];\r\n                if (pose) {\r\n                    pose.position.subtractToRef(gaze.origin, gazeToBehavior);\r\n                } else {\r\n                    this._node.getAbsolutePosition().subtractToRef(gaze.origin, gazeToBehavior);\r\n                }\r\n\r\n                const projectedDistance = Vector3.Dot(gazeToBehavior, gaze.direction);\r\n                const projectedSquared = projectedDistance * projectedDistance;\r\n\r\n                if (projectedDistance > 0) {\r\n                    const radiusSquared = gazeToBehavior.lengthSquared() - projectedSquared;\r\n                    if (radiusSquared < this.gazeProximityRadius * this.gazeProximityRadius) {\r\n                        gazeVisible = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.handConstraintVisibility === HandConstraintVisibility.PALM_UP || this.handConstraintVisibility === HandConstraintVisibility.PALM_AND_GAZE) {\r\n                palmVisible = false;\r\n\r\n                if (pose) {\r\n                    const palmDirection = TmpVectors.Vector3[0];\r\n                    Vector3.LeftHandedForwardReadOnly.rotateByQuaternionToRef(pose.quaternion, palmDirection);\r\n\r\n                    if (Vector3.Dot(palmDirection, cameraForward.direction) > this.palmUpStrictness * 2 - 1) {\r\n                        palmVisible = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this._node.setEnabled(palmVisible && gazeVisible);\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from the `TransformNode`\r\n     */\r\n    public detach(): void {\r\n        this._scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);\r\n    }\r\n\r\n    /**\r\n     * Links the behavior to the XR experience in which to retrieve hand transform information.\r\n     * @param xr xr experience\r\n     */\r\n    public linkToXRExperience(xr: WebXRExperienceHelper | WebXRFeaturesManager) {\r\n        const featuresManager: WebXRFeaturesManager = (xr as WebXRExperienceHelper).featuresManager ? (xr as WebXRExperienceHelper).featuresManager : (xr as WebXRFeaturesManager);\r\n        if (!featuresManager) {\r\n            Tools.Error(\"XR features manager must be available or provided directly for the Hand Menu to work\");\r\n        } else {\r\n            try {\r\n                this._eyeTracking = featuresManager.getEnabledFeature(WebXRFeatureName.EYE_TRACKING) as WebXREyeTracking;\r\n            } catch {}\r\n\r\n            try {\r\n                this._handTracking = featuresManager.getEnabledFeature(WebXRFeatureName.HAND_TRACKING) as WebXRHandTracking;\r\n            } catch {\r\n                Tools.Error(\"Hand tracking must be enabled for the Hand Menu to work\");\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { WebRequest } from \"./webRequest\";\r\n\r\n/**\r\n * Fetches a resource from the network\r\n * @param url defines the url to fetch the resource from\r\n * @param options defines the options to use when fetching the resource\r\n * @returns a promise that resolves when the resource is fetched\r\n * @internal\r\n */\r\nexport function _FetchAsync(\r\n    url: string,\r\n    options: Partial<{ method: string; responseHeaders?: string[] }>\r\n): Promise<{ response: Response; headerValues: { [key: string]: string } }> {\r\n    const method = options.method || \"GET\";\r\n    return new Promise((resolve, reject) => {\r\n        const request = new WebRequest();\r\n        request.addEventListener(\"readystatechange\", () => {\r\n            if (request.readyState == 4) {\r\n                if (request.status == 200) {\r\n                    const headerValues: { [key: string]: string } = {};\r\n                    if (options.responseHeaders) {\r\n                        for (const header of options.responseHeaders) {\r\n                            headerValues[header] = request.getResponseHeader(header) || \"\";\r\n                        }\r\n                    }\r\n\r\n                    resolve({ response: request.response, headerValues: headerValues });\r\n                } else {\r\n                    reject(`Unable to fetch data from ${url}. Error code: ${request.status}`);\r\n                }\r\n            }\r\n        });\r\n\r\n        request.open(method, url);\r\n        request.send();\r\n    });\r\n}\r\n", "import { Tools } from \"../Misc/tools\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { DeepImmutable, Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { AnimationGroup } from \"../Animations/animationGroup\";\r\nimport type { AssetContainer } from \"../assetContainer\";\r\nimport type { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { SceneLoaderFlags } from \"./sceneLoaderFlags\";\r\nimport type { IFileRequest } from \"../Misc/fileRequest\";\r\nimport type { WebRequest } from \"../Misc/webRequest\";\r\nimport type { LoadFileError } from \"../Misc/fileTools\";\r\nimport { IsBase64DataUrl } from \"../Misc/fileTools\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { Geometry } from \"../Meshes/geometry\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport { RuntimeError, ErrorCodes } from \"../Misc/error\";\r\nimport type { ISpriteManager } from \"../Sprites/spriteManager\";\r\nimport { RandomGUID } from \"../Misc/guid\";\r\nimport { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { _FetchAsync } from \"core/Misc/webRequest.fetch\";\r\n\r\n/**\r\n * Type used for the success callback of ImportMesh\r\n */\r\nexport type SceneLoaderSuccessCallback = (\r\n    meshes: AbstractMesh[],\r\n    particleSystems: IParticleSystem[],\r\n    skeletons: Skeleton[],\r\n    animationGroups: AnimationGroup[],\r\n    transformNodes: TransformNode[],\r\n    geometries: Geometry[],\r\n    lights: Light[],\r\n    spriteManagers: ISpriteManager[]\r\n) => void;\r\n\r\n/**\r\n * Interface used for the result of ImportMeshAsync\r\n */\r\nexport interface ISceneLoaderAsyncResult {\r\n    /**\r\n     * The array of loaded meshes\r\n     */\r\n    readonly meshes: AbstractMesh[];\r\n\r\n    /**\r\n     * The array of loaded particle systems\r\n     */\r\n    readonly particleSystems: IParticleSystem[];\r\n\r\n    /**\r\n     * The array of loaded skeletons\r\n     */\r\n    readonly skeletons: Skeleton[];\r\n\r\n    /**\r\n     * The array of loaded animation groups\r\n     */\r\n    readonly animationGroups: AnimationGroup[];\r\n\r\n    /**\r\n     * The array of loaded transform nodes\r\n     */\r\n    readonly transformNodes: TransformNode[];\r\n\r\n    /**\r\n     * The array of loaded geometries\r\n     */\r\n    readonly geometries: Geometry[];\r\n\r\n    /**\r\n     * The array of loaded lights\r\n     */\r\n    readonly lights: Light[];\r\n\r\n    /**\r\n     * The array of loaded sprite managers\r\n     */\r\n    readonly spriteManagers: ISpriteManager[];\r\n}\r\n\r\n/**\r\n * Interface used to represent data loading progression\r\n */\r\nexport interface ISceneLoaderProgressEvent {\r\n    /**\r\n     * Defines if data length to load can be evaluated\r\n     */\r\n    readonly lengthComputable: boolean;\r\n\r\n    /**\r\n     * Defines the loaded data length\r\n     */\r\n    readonly loaded: number;\r\n\r\n    /**\r\n     * Defines the data length to load\r\n     */\r\n    readonly total: number;\r\n}\r\n\r\n/**\r\n * Interface used by SceneLoader plugins to define supported file extensions\r\n */\r\nexport interface ISceneLoaderPluginExtensions {\r\n    /**\r\n     * Defines the list of supported extensions\r\n     */\r\n    readonly [extension: string]: {\r\n        readonly isBinary: boolean;\r\n        readonly mimeType?: string;\r\n    };\r\n}\r\n\r\n/**\r\n * Metadata for a SceneLoader plugin that must also be provided by a plugin factory\r\n */\r\nexport interface ISceneLoaderPluginMetadata {\r\n    /**\r\n     * The friendly name of the plugin.\r\n     */\r\n    readonly name: string;\r\n\r\n    /**\r\n     * The file extensions supported by the plugin.\r\n     */\r\n    readonly extensions: string | ISceneLoaderPluginExtensions;\r\n\r\n    /**\r\n     * The callback that returns true if the data can be directly loaded.\r\n     * @param data string containing the file data\r\n     * @returns if the data can be loaded directly\r\n     */\r\n    canDirectLoad?(data: string): boolean;\r\n}\r\n\r\n/**\r\n * Interface used by SceneLoader plugin factory\r\n */\r\nexport interface ISceneLoaderPluginFactory extends ISceneLoaderPluginMetadata {\r\n    /**\r\n     * Function called to create a new plugin\r\n     * @param options plugin options that were passed to the SceneLoader operation\r\n     * @returns the new plugin\r\n     */\r\n    createPlugin(options: SceneLoaderPluginOptions): ISceneLoaderPlugin | ISceneLoaderPluginAsync | Promise<ISceneLoaderPlugin | ISceneLoaderPluginAsync>;\r\n}\r\n\r\n/**\r\n * Interface used to define the base of ISceneLoaderPlugin and ISceneLoaderPluginAsync\r\n */\r\nexport interface ISceneLoaderPluginBase extends ISceneLoaderPluginMetadata {\r\n    /**\r\n     * The callback called when loading from a url.\r\n     * @param scene scene loading this url\r\n     * @param fileOrUrl file or url to load\r\n     * @param rootUrl root url to use to load assets\r\n     * @param onSuccess callback called when the file successfully loads\r\n     * @param onProgress callback called while file is loading (if the server supports this mode)\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @param onError callback called when the file fails to load\r\n     * @param name defines the name of the file when loading a binary file\r\n     * @returns a file request object\r\n     */\r\n    loadFile?(\r\n        scene: Scene,\r\n        fileOrUrl: File | string | ArrayBufferView,\r\n        rootUrl: string,\r\n        onSuccess: (data: unknown, responseURL?: string) => void,\r\n        onProgress?: (ev: ISceneLoaderProgressEvent) => void,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void,\r\n        name?: string\r\n    ): Nullable<IFileRequest>;\r\n\r\n    /**\r\n     * The callback that returns the data to pass to the plugin if the data can be directly loaded.\r\n     * @param scene scene loading this data\r\n     * @param data string containing the data\r\n     * @returns data to pass to the plugin\r\n     */\r\n    directLoad?(scene: Scene, data: string): unknown | Promise<unknown>;\r\n\r\n    /**\r\n     * The callback that allows custom handling of the root url based on the response url.\r\n     * @param rootUrl the original root url\r\n     * @param responseURL the response url if available\r\n     * @returns the new root url\r\n     */\r\n    rewriteRootURL?(rootUrl: string, responseURL?: string): string;\r\n}\r\n\r\n/**\r\n * Interface used to define a SceneLoader plugin\r\n */\r\nexport interface ISceneLoaderPlugin extends ISceneLoaderPluginBase {\r\n    /**\r\n     * Import meshes into a scene.\r\n     * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param scene The scene to import into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param meshes The meshes array to import into\r\n     * @param particleSystems The particle systems array to import into\r\n     * @param skeletons The skeletons array to import into\r\n     * @param onError The callback when import fails\r\n     * @returns True if successful or false otherwise\r\n     */\r\n    importMesh(\r\n        meshesNames: string | readonly string[] | null | undefined,\r\n        scene: Scene,\r\n        data: unknown,\r\n        rootUrl: string,\r\n        meshes: AbstractMesh[],\r\n        particleSystems: IParticleSystem[],\r\n        skeletons: Skeleton[],\r\n        onError?: (message: string, exception?: any) => void\r\n    ): boolean;\r\n\r\n    /**\r\n     * Load into a scene.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onError The callback when import fails\r\n     * @returns True if successful or false otherwise\r\n     */\r\n    load(scene: Scene, data: unknown, rootUrl: string, onError?: (message: string, exception?: any) => void): boolean;\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onError The callback when import fails\r\n     * @returns The loaded asset container\r\n     */\r\n    loadAssetContainer(scene: Scene, data: unknown, rootUrl: string, onError?: (message: string, exception?: any) => void): AssetContainer;\r\n}\r\n\r\n/**\r\n * Interface used to define an async SceneLoader plugin\r\n */\r\nexport interface ISceneLoaderPluginAsync extends ISceneLoaderPluginBase {\r\n    /**\r\n     * Import meshes into a scene.\r\n     * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param scene The scene to import into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns The loaded objects (e.g. meshes, particle systems, skeletons, animation groups, etc.)\r\n     */\r\n    importMeshAsync(\r\n        meshesNames: string | readonly string[] | null | undefined,\r\n        scene: Scene,\r\n        data: unknown,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName?: string\r\n    ): Promise<ISceneLoaderAsyncResult>;\r\n\r\n    /**\r\n     * Load into a scene.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns Nothing\r\n     */\r\n    loadAsync(scene: Scene, data: unknown, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<void>;\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns The loaded asset container\r\n     */\r\n    loadAssetContainerAsync(scene: Scene, data: unknown, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<AssetContainer>;\r\n}\r\n\r\n/**\r\n * Mode that determines how to handle old animation groups before loading new ones.\r\n */\r\nexport const enum SceneLoaderAnimationGroupLoadingMode {\r\n    /**\r\n     * Reset all old animations to initial state then dispose them.\r\n     */\r\n    Clean = 0,\r\n\r\n    /**\r\n     * Stop all old animations.\r\n     */\r\n    Stop = 1,\r\n\r\n    /**\r\n     * Restart old animations from first frame.\r\n     */\r\n    Sync = 2,\r\n\r\n    /**\r\n     * Old animations remains untouched.\r\n     */\r\n    NoSync = 3,\r\n}\r\n\r\n/**\r\n * Defines internal only plugin members.\r\n */\r\ninterface ISceneLoaderPluginInternal {\r\n    /**\r\n     * An optional observable to notify when the plugin is disposed\r\n     */\r\n    readonly onDisposeObservable: Observable<void>;\r\n}\r\n\r\n/**\r\n * Defines a plugin registered by the SceneLoader\r\n */\r\ninterface IRegisteredPlugin {\r\n    /**\r\n     * Defines the plugin to use\r\n     */\r\n    plugin: ((ISceneLoaderPlugin | ISceneLoaderPluginAsync) & Partial<ISceneLoaderPluginInternal>) | ISceneLoaderPluginFactory;\r\n    /**\r\n     * Defines if the plugin supports binary data\r\n     */\r\n    isBinary: boolean;\r\n    mimeType?: string;\r\n}\r\n\r\nfunction isFactory(pluginOrFactory: IRegisteredPlugin[\"plugin\"]): pluginOrFactory is ISceneLoaderPluginFactory {\r\n    return !!(pluginOrFactory as ISceneLoaderPluginFactory).createPlugin;\r\n}\r\n\r\n/**\r\n * Defines file information\r\n */\r\ninterface IFileInfo {\r\n    /**\r\n     * Gets the file url\r\n     */\r\n    url: string;\r\n    /**\r\n     * Gets the root url\r\n     */\r\n    rootUrl: string;\r\n    /**\r\n     * Gets filename\r\n     */\r\n    name: string;\r\n    /**\r\n     * Gets the file\r\n     */\r\n    file: Nullable<File>;\r\n\r\n    /**\r\n     * Gets raw binary data.\r\n     */\r\n    rawData: Nullable<ArrayBufferView>;\r\n}\r\n\r\n/**\r\n * Defines options for SceneLoader plugins. This interface is extended by specific plugins.\r\n */\r\nexport interface SceneLoaderPluginOptions extends Record<string, Record<string, unknown> | undefined> {}\r\n\r\n/**\r\n * Adds default/implicit options to plugin specific options.\r\n */\r\ntype DefaultPluginOptions<BasePluginOptions> = {\r\n    /**\r\n     * Defines if the plugin is enabled\r\n     */\r\n    enabled?: boolean;\r\n} & BasePluginOptions;\r\n\r\n// This captures the type defined inline for the pluginOptions property, which is just SceneLoaderPluginOptions wrapped with DefaultPluginOptions.\r\n// We do it this way rather than explicitly defining the type here and then using it in SceneLoaderOptions because we want the full expanded type\r\n// to show up in the user's intellisense to make it easier to understand what options are available.\r\ntype PluginOptions = SceneLoaderOptions[\"pluginOptions\"];\r\n\r\ntype SceneSource = string | File | ArrayBufferView;\r\n\r\n/**\r\n * Defines common options for loading operations performed by SceneLoader.\r\n */\r\ninterface SceneLoaderOptions {\r\n    /**\r\n     * A string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     */\r\n    rootUrl?: string;\r\n\r\n    /**\r\n     * A callback with a progress event for each file being loaded\r\n     */\r\n    onProgress?: (event: ISceneLoaderProgressEvent) => void;\r\n\r\n    /**\r\n     * The extension used to determine the plugin\r\n     */\r\n    pluginExtension?: string;\r\n\r\n    /**\r\n     * Defines the filename, if the data is binary\r\n     */\r\n    name?: string;\r\n\r\n    /**\r\n     * Defines options for the registered plugins\r\n     */\r\n    pluginOptions?: {\r\n        // NOTE: This type is doing two things:\r\n        // 1. Adding an implicit 'enabled' property to the options for each plugin.\r\n        // 2. Creating a mapped type of all the options of all the plugins to make it just look like a consolidated plain object in intellisense for the user.\r\n        [Plugin in keyof SceneLoaderPluginOptions]?: {\r\n            [Option in keyof DefaultPluginOptions<SceneLoaderPluginOptions[Plugin]>]: DefaultPluginOptions<SceneLoaderPluginOptions[Plugin]>[Option];\r\n        };\r\n    };\r\n}\r\n\r\n/**\r\n * Defines options for ImportMeshAsync.\r\n */\r\nexport interface ImportMeshOptions extends SceneLoaderOptions {\r\n    /**\r\n     * An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     */\r\n    meshNames?: string | readonly string[] | null | undefined;\r\n}\r\n\r\n/**\r\n * Defines options for LoadAsync.\r\n */\r\nexport interface LoadOptions extends SceneLoaderOptions {}\r\n\r\n/**\r\n * Defines options for AppendAsync.\r\n */\r\nexport interface AppendOptions extends SceneLoaderOptions {}\r\n\r\n/**\r\n * Defines options for LoadAssetContainerAsync.\r\n */\r\nexport interface LoadAssetContainerOptions extends SceneLoaderOptions {}\r\n\r\n/**\r\n * Defines options for ImportAnimationsAsync.\r\n */\r\nexport interface ImportAnimationsOptions extends SceneLoaderOptions {\r\n    /**\r\n     * When true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n     */\r\n    overwriteAnimations?: boolean;\r\n\r\n    /**\r\n     * Defines how to handle old animations groups before importing new ones\r\n     */\r\n    animationGroupLoadingMode?: SceneLoaderAnimationGroupLoadingMode;\r\n\r\n    /**\r\n     * defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n     */\r\n    targetConverter?: Nullable<(target: unknown) => unknown>;\r\n}\r\n\r\nfunction isFile(value: unknown): value is File {\r\n    return !!(value as File).name;\r\n}\r\n\r\nconst onPluginActivatedObservable = new Observable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>();\r\nconst registeredPlugins: { [extension: string]: IRegisteredPlugin } = {};\r\nlet showingLoadingScreen = false;\r\n\r\nfunction getDefaultPlugin(): IRegisteredPlugin | undefined {\r\n    return registeredPlugins[\".babylon\"];\r\n}\r\n\r\nfunction getPluginForMimeType(mimeType: string): IRegisteredPlugin | undefined {\r\n    for (const registeredPluginKey in registeredPlugins) {\r\n        const registeredPlugin = registeredPlugins[registeredPluginKey];\r\n        if (registeredPlugin.mimeType === mimeType) {\r\n            return registeredPlugin;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction getPluginForExtension(extension: string, returnDefault: boolean): IRegisteredPlugin | undefined {\r\n    const registeredPlugin = registeredPlugins[extension];\r\n    if (registeredPlugin) {\r\n        return registeredPlugin;\r\n    }\r\n    Logger.Warn(\r\n        \"Unable to find a plugin to load \" +\r\n            extension +\r\n            \" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes\"\r\n    );\r\n    return returnDefault ? getDefaultPlugin() : undefined;\r\n}\r\n\r\nfunction isPluginForExtensionAvailable(extension: string): boolean {\r\n    return !!registeredPlugins[extension];\r\n}\r\n\r\nfunction getPluginForDirectLoad(data: string): IRegisteredPlugin | undefined {\r\n    for (const extension in registeredPlugins) {\r\n        const plugin = registeredPlugins[extension].plugin;\r\n\r\n        if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {\r\n            return registeredPlugins[extension];\r\n        }\r\n    }\r\n\r\n    return getDefaultPlugin();\r\n}\r\n\r\nfunction getFilenameExtension(sceneFilename: string): string {\r\n    const queryStringPosition = sceneFilename.indexOf(\"?\");\r\n\r\n    if (queryStringPosition !== -1) {\r\n        sceneFilename = sceneFilename.substring(0, queryStringPosition);\r\n    }\r\n\r\n    const dotPosition = sceneFilename.lastIndexOf(\".\");\r\n\r\n    return sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();\r\n}\r\n\r\nfunction getDirectLoad(sceneFilename: string): Nullable<string> {\r\n    if (sceneFilename.substring(0, 5) === \"data:\") {\r\n        return sceneFilename.substring(5);\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nfunction formatErrorMessage(fileInfo: IFileInfo, message?: string, exception?: any): string {\r\n    const fromLoad = fileInfo.rawData ? \"binary data\" : fileInfo.url;\r\n    let errorMessage = \"Unable to load from \" + fromLoad;\r\n\r\n    if (message) {\r\n        errorMessage += `: ${message}`;\r\n    } else if (exception) {\r\n        errorMessage += `: ${exception}`;\r\n    }\r\n\r\n    return errorMessage;\r\n}\r\n\r\nasync function loadDataAsync(\r\n    fileInfo: IFileInfo,\r\n    scene: Scene,\r\n    onSuccess: (plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync, data: unknown, responseURL?: string) => void,\r\n    onProgress: ((event: ISceneLoaderProgressEvent) => void) | undefined,\r\n    onError: (message?: string, exception?: any) => void,\r\n    onDispose: () => void,\r\n    pluginExtension: Nullable<string>,\r\n    name: string,\r\n    pluginOptions: PluginOptions\r\n): Promise<Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>> {\r\n    const directLoad = getDirectLoad(fileInfo.url);\r\n\r\n    if (fileInfo.rawData && !pluginExtension) {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \"When using ArrayBufferView to load data the file extension must be provided.\";\r\n    }\r\n\r\n    const fileExtension = !directLoad && !pluginExtension ? getFilenameExtension(fileInfo.url) : \"\";\r\n\r\n    let registeredPlugin = pluginExtension\r\n        ? getPluginForExtension(pluginExtension, true)\r\n        : directLoad\r\n          ? getPluginForDirectLoad(fileInfo.url)\r\n          : getPluginForExtension(fileExtension, false);\r\n\r\n    if (!registeredPlugin && fileExtension) {\r\n        if (fileInfo.url && !fileInfo.url.startsWith(\"blob:\")) {\r\n            // Fetching head content to get the mime type\r\n            const response = await _FetchAsync(fileInfo.url, { method: \"HEAD\", responseHeaders: [\"Content-Type\"] });\r\n            const mimeType = response.headerValues ? response.headerValues[\"Content-Type\"] : \"\";\r\n            if (mimeType) {\r\n                registeredPlugin = getPluginForMimeType(mimeType);\r\n            }\r\n        }\r\n\r\n        if (!registeredPlugin) {\r\n            registeredPlugin = getDefaultPlugin();\r\n        }\r\n    }\r\n\r\n    if (!registeredPlugin) {\r\n        throw new Error(`No plugin or fallback for ${pluginExtension ?? fileInfo.url}`);\r\n    }\r\n\r\n    if (pluginOptions?.[registeredPlugin.plugin.name]?.enabled === false) {\r\n        throw new Error(`The '${registeredPlugin.plugin.name}' plugin is disabled via the loader options passed to the loading operation.`);\r\n    }\r\n\r\n    if (fileInfo.rawData && !registeredPlugin.isBinary) {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \"Loading from ArrayBufferView can not be used with plugins that don't support binary loading.\";\r\n    }\r\n\r\n    const getPluginInstance = (callback: (plugin: (ISceneLoaderPlugin | ISceneLoaderPluginAsync) & Partial<ISceneLoaderPluginInternal>) => void) => {\r\n        // For plugin factories, the plugin is instantiated on each SceneLoader operation. This makes options handling\r\n        // much simpler as we can just pass the options to the factory, rather than passing options through to every possible\r\n        // plugin call. Given this, options are only supported for plugins that provide a factory function.\r\n        if (isFactory(registeredPlugin!.plugin)) {\r\n            const pluginFactory = registeredPlugin!.plugin;\r\n            const partialPlugin = pluginFactory.createPlugin(pluginOptions ?? {});\r\n            if (partialPlugin instanceof Promise) {\r\n                partialPlugin.then(callback).catch((error) => {\r\n                    onError(\"Error instantiating plugin.\", error);\r\n                });\r\n                // When async factories are used, the plugin instance cannot be returned synchronously.\r\n                // In this case, the legacy loader functions will return null.\r\n                return null;\r\n            } else {\r\n                callback(partialPlugin);\r\n                return partialPlugin;\r\n            }\r\n        } else {\r\n            callback(registeredPlugin!.plugin);\r\n            return registeredPlugin!.plugin;\r\n        }\r\n    };\r\n\r\n    return getPluginInstance((plugin) => {\r\n        if (!plugin) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw `The loader plugin corresponding to the '${pluginExtension}' file type has not been found. If using es6, please import the plugin you wish to use before.`;\r\n        }\r\n\r\n        onPluginActivatedObservable.notifyObservers(plugin);\r\n\r\n        // Check if we have a direct load url. If the plugin is registered to handle\r\n        // it or it's not a base64 data url, then pass it through the direct load path.\r\n        if (directLoad && ((plugin.canDirectLoad && plugin.canDirectLoad(fileInfo.url)) || !IsBase64DataUrl(fileInfo.url))) {\r\n            if (plugin.directLoad) {\r\n                const result = plugin.directLoad(scene, directLoad);\r\n                if (result instanceof Promise) {\r\n                    result\r\n                        .then((data: unknown) => {\r\n                            onSuccess(plugin, data);\r\n                        })\r\n                        .catch((error: any) => {\r\n                            onError(\"Error in directLoad of _loadData: \" + error, error);\r\n                        });\r\n                } else {\r\n                    onSuccess(plugin, result);\r\n                }\r\n            } else {\r\n                onSuccess(plugin, directLoad);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const useArrayBuffer = registeredPlugin!.isBinary;\r\n\r\n        const dataCallback = (data: unknown, responseURL?: string) => {\r\n            if (scene.isDisposed) {\r\n                onError(\"Scene has been disposed\");\r\n                return;\r\n            }\r\n\r\n            onSuccess(plugin, data, responseURL);\r\n        };\r\n\r\n        let request: Nullable<IFileRequest> = null;\r\n        let pluginDisposed = false;\r\n        plugin.onDisposeObservable?.add(() => {\r\n            pluginDisposed = true;\r\n\r\n            if (request) {\r\n                request.abort();\r\n                request = null;\r\n            }\r\n\r\n            onDispose();\r\n        });\r\n\r\n        const manifestChecked = () => {\r\n            if (pluginDisposed) {\r\n                return;\r\n            }\r\n\r\n            const errorCallback = (request?: WebRequest, exception?: LoadFileError) => {\r\n                onError(request?.statusText, exception);\r\n            };\r\n\r\n            if (!plugin.loadFile && fileInfo.rawData) {\r\n                // eslint-disable-next-line no-throw-literal\r\n                throw \"Plugin does not support loading ArrayBufferView.\";\r\n            }\r\n\r\n            request = plugin.loadFile\r\n                ? plugin.loadFile(scene, fileInfo.rawData || fileInfo.file || fileInfo.url, fileInfo.rootUrl, dataCallback, onProgress, useArrayBuffer, errorCallback, name)\r\n                : scene._loadFile(fileInfo.file || fileInfo.url, dataCallback, onProgress, true, useArrayBuffer, errorCallback);\r\n        };\r\n\r\n        const engine = scene.getEngine();\r\n        let canUseOfflineSupport = engine.enableOfflineSupport;\r\n        if (canUseOfflineSupport) {\r\n            // Also check for exceptions\r\n            let exceptionFound = false;\r\n            for (const regex of scene.disableOfflineSupportExceptionRules) {\r\n                if (regex.test(fileInfo.url)) {\r\n                    exceptionFound = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            canUseOfflineSupport = !exceptionFound;\r\n        }\r\n\r\n        if (canUseOfflineSupport && AbstractEngine.OfflineProviderFactory) {\r\n            // Checking if a manifest file has been set for this scene and if offline mode has been requested\r\n            scene.offlineProvider = AbstractEngine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);\r\n        } else {\r\n            manifestChecked();\r\n        }\r\n    });\r\n}\r\n\r\nfunction _getFileInfo(rootUrl: string, sceneSource: SceneSource): Nullable<IFileInfo> {\r\n    let url: string;\r\n    let name: string;\r\n    let file: Nullable<File> = null;\r\n    let rawData: Nullable<ArrayBufferView> = null;\r\n\r\n    if (!sceneSource) {\r\n        url = rootUrl;\r\n        name = Tools.GetFilename(rootUrl);\r\n        rootUrl = Tools.GetFolderPath(rootUrl);\r\n    } else if (isFile(sceneSource)) {\r\n        url = `file:${sceneSource.name}`;\r\n        name = sceneSource.name;\r\n        file = sceneSource;\r\n    } else if (ArrayBuffer.isView(sceneSource)) {\r\n        url = \"\";\r\n        name = RandomGUID();\r\n        rawData = sceneSource;\r\n    } else if (sceneSource.startsWith(\"data:\")) {\r\n        url = sceneSource;\r\n        name = \"\";\r\n    } else if (rootUrl) {\r\n        const filename = sceneSource;\r\n        if (filename.substring(0, 1) === \"/\") {\r\n            Tools.Error(\"Wrong sceneFilename parameter\");\r\n            return null;\r\n        }\r\n\r\n        url = rootUrl + filename;\r\n        name = filename;\r\n    } else {\r\n        url = sceneSource;\r\n        name = Tools.GetFilename(sceneSource);\r\n        rootUrl = Tools.GetFolderPath(sceneSource);\r\n    }\r\n\r\n    return {\r\n        url: url,\r\n        rootUrl: rootUrl,\r\n        name: name,\r\n        file: file,\r\n        rawData,\r\n    };\r\n}\r\n\r\n/**\r\n * Adds a new plugin to the list of registered plugins\r\n * @param plugin defines the plugin to add\r\n */\r\nexport function RegisterSceneLoaderPlugin(plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory): void {\r\n    if (typeof plugin.extensions === \"string\") {\r\n        const extension = plugin.extensions;\r\n        registeredPlugins[extension.toLowerCase()] = {\r\n            plugin: plugin,\r\n            isBinary: false,\r\n        };\r\n    } else {\r\n        const extensions = plugin.extensions;\r\n        Object.keys(extensions).forEach((extension) => {\r\n            registeredPlugins[extension.toLowerCase()] = {\r\n                plugin: plugin,\r\n                isBinary: extensions[extension].isBinary,\r\n                mimeType: extensions[extension].mimeType,\r\n            };\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Adds a new plugin to the list of registered plugins\r\n * @deprecated Please use {@link RegisterSceneLoaderPlugin} instead.\r\n * @param plugin defines the plugin to add\r\n */\r\nexport function registerSceneLoaderPlugin(plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory): void {\r\n    RegisterSceneLoaderPlugin(plugin);\r\n}\r\n\r\n/**\r\n * Gets metadata for all currently registered scene loader plugins.\r\n * @returns An array where each entry has metadata for a single scene loader plugin.\r\n */\r\nexport function GetRegisteredSceneLoaderPluginMetadata(): DeepImmutable<\r\n    Array<\r\n        Pick<ISceneLoaderPluginMetadata, \"name\"> & {\r\n            /**\r\n             * The extensions supported by the plugin.\r\n             */\r\n            extensions: ({\r\n                /**\r\n                 * The file extension.\r\n                 */\r\n                extension: string;\r\n            } & ISceneLoaderPluginExtensions[string])[];\r\n        }\r\n    >\r\n> {\r\n    return Array.from(\r\n        Object.entries(registeredPlugins).reduce((pluginMap, [extension, extensionRegistration]) => {\r\n            let pluginMetadata = pluginMap.get(extensionRegistration.plugin.name);\r\n            if (!pluginMetadata) {\r\n                pluginMap.set(extensionRegistration.plugin.name, (pluginMetadata = []));\r\n            }\r\n            pluginMetadata.push({ extension, isBinary: extensionRegistration.isBinary, mimeType: extensionRegistration.mimeType });\r\n            return pluginMap;\r\n        }, new Map<string, ({ extension: string } & ISceneLoaderPluginExtensions[string])[]>())\r\n    ).map(([name, extensions]) => ({ name, extensions }));\r\n}\r\n\r\n/**\r\n * Import meshes into a scene\r\n * @param source a string that defines the name of the scene file, or starts with \"data:\" following by the stringified version of the scene, or a File object, or an ArrayBufferView\r\n * @param scene the instance of BABYLON.Scene to append to\r\n * @param options an object that configures aspects of how the scene is loaded\r\n * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups\r\n */\r\nexport function ImportMeshAsync(source: SceneSource, scene: Scene, options?: ImportMeshOptions): Promise<ISceneLoaderAsyncResult> {\r\n    const { meshNames, rootUrl = \"\", onProgress, pluginExtension, name, pluginOptions } = options ?? {};\r\n    return importMeshAsyncCore(meshNames, rootUrl, source, scene, onProgress, pluginExtension, name, pluginOptions);\r\n}\r\n\r\nasync function importMeshAsync(\r\n    meshNames: string | readonly string[] | null | undefined,\r\n    rootUrl: string,\r\n    sceneFilename: SceneSource = \"\",\r\n    scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n    onSuccess: Nullable<SceneLoaderSuccessCallback> = null,\r\n    onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n    onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n    pluginExtension: Nullable<string> = null,\r\n    name = \"\",\r\n    pluginOptions: PluginOptions = {}\r\n): Promise<Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>> {\r\n    if (!scene) {\r\n        Logger.Error(\"No scene available to import mesh to\");\r\n        return null;\r\n    }\r\n\r\n    const fileInfo = _getFileInfo(rootUrl, sceneFilename);\r\n    if (!fileInfo) {\r\n        return null;\r\n    }\r\n\r\n    const loadingToken = {};\r\n    scene.addPendingData(loadingToken);\r\n\r\n    const disposeHandler = () => {\r\n        scene.removePendingData(loadingToken);\r\n    };\r\n\r\n    const errorHandler = (message?: string, exception?: any) => {\r\n        const errorMessage = formatErrorMessage(fileInfo, message, exception);\r\n\r\n        if (onError) {\r\n            onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\r\n        } else {\r\n            Logger.Error(errorMessage);\r\n            // should the exception be thrown?\r\n        }\r\n\r\n        disposeHandler();\r\n    };\r\n\r\n    const progressHandler = onProgress\r\n        ? (event: ISceneLoaderProgressEvent) => {\r\n              try {\r\n                  onProgress(event);\r\n              } catch (e) {\r\n                  errorHandler(\"Error in onProgress callback: \" + e, e);\r\n              }\r\n          }\r\n        : undefined;\r\n\r\n    const successHandler: SceneLoaderSuccessCallback = (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights, spriteManagers) => {\r\n        scene.importedMeshesFiles.push(fileInfo.url);\r\n\r\n        if (onSuccess) {\r\n            try {\r\n                onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights, spriteManagers);\r\n            } catch (e) {\r\n                errorHandler(\"Error in onSuccess callback: \" + e, e);\r\n            }\r\n        }\r\n\r\n        scene.removePendingData(loadingToken);\r\n    };\r\n\r\n    return await loadDataAsync(\r\n        fileInfo,\r\n        scene,\r\n        (plugin, data, responseURL) => {\r\n            if (plugin.rewriteRootURL) {\r\n                fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);\r\n            }\r\n\r\n            if ((plugin as ISceneLoaderPlugin).importMesh) {\r\n                const syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                const meshes: AbstractMesh[] = [];\r\n                const particleSystems: IParticleSystem[] = [];\r\n                const skeletons: Skeleton[] = [];\r\n\r\n                if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {\r\n                    return;\r\n                }\r\n\r\n                scene.loadingPluginName = plugin.name;\r\n                successHandler(meshes, particleSystems, skeletons, [], [], [], [], []);\r\n            } else {\r\n                const asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                asyncedPlugin\r\n                    .importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name)\r\n                    .then((result) => {\r\n                        scene.loadingPluginName = plugin.name;\r\n                        successHandler(\r\n                            result.meshes,\r\n                            result.particleSystems,\r\n                            result.skeletons,\r\n                            result.animationGroups,\r\n                            result.transformNodes,\r\n                            result.geometries,\r\n                            result.lights,\r\n                            result.spriteManagers\r\n                        );\r\n                    })\r\n                    .catch((error) => {\r\n                        errorHandler(error.message, error);\r\n                    });\r\n            }\r\n        },\r\n        progressHandler,\r\n        errorHandler,\r\n        disposeHandler,\r\n        pluginExtension,\r\n        name,\r\n        pluginOptions\r\n    );\r\n}\r\n\r\nfunction importMeshAsyncCore(\r\n    meshNames: string | readonly string[] | null | undefined,\r\n    rootUrl: string,\r\n    sceneFilename?: SceneSource,\r\n    scene?: Nullable<Scene>,\r\n    onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n    pluginExtension?: Nullable<string>,\r\n    name?: string,\r\n    pluginOptions?: PluginOptions\r\n): Promise<ISceneLoaderAsyncResult> {\r\n    return new Promise((resolve, reject) => {\r\n        try {\r\n            importMeshAsync(\r\n                meshNames,\r\n                rootUrl,\r\n                sceneFilename,\r\n                scene,\r\n                (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights, spriteManagers) => {\r\n                    resolve({\r\n                        meshes: meshes,\r\n                        particleSystems: particleSystems,\r\n                        skeletons: skeletons,\r\n                        animationGroups: animationGroups,\r\n                        transformNodes: transformNodes,\r\n                        geometries: geometries,\r\n                        lights: lights,\r\n                        spriteManagers: spriteManagers,\r\n                    });\r\n                },\r\n                onProgress,\r\n                (scene, message, exception) => {\r\n                    reject(exception || new Error(message));\r\n                },\r\n                pluginExtension,\r\n                name,\r\n                pluginOptions\r\n            ).catch(reject);\r\n        } catch (error) {\r\n            reject(error);\r\n        }\r\n    });\r\n}\r\n\r\n// This is the core implementation of load scene\r\nasync function loadSceneImplAsync(\r\n    rootUrl: string,\r\n    sceneFilename: SceneSource = \"\",\r\n    engine: Nullable<AbstractEngine> = EngineStore.LastCreatedEngine,\r\n    onSuccess: Nullable<(scene: Scene) => void> = null,\r\n    onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n    onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n    pluginExtension: Nullable<string> = null,\r\n    name = \"\",\r\n    pluginOptions: PluginOptions = {}\r\n): Promise<void> {\r\n    if (!engine) {\r\n        Tools.Error(\"No engine available\");\r\n        return;\r\n    }\r\n\r\n    await appendSceneImplAsync(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension, name, pluginOptions);\r\n}\r\n\r\n/**\r\n * Load a scene\r\n * @param source a string that defines the name of the scene file, or starts with \"data:\" following by the stringified version of the scene, or a File object, or an ArrayBufferView\r\n * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n * @param options an object that configures aspects of how the scene is loaded\r\n * @returns The loaded scene\r\n */\r\nexport function LoadSceneAsync(source: SceneSource, engine: AbstractEngine, options?: LoadOptions): Promise<Scene> {\r\n    const { rootUrl = \"\", onProgress, pluginExtension, name, pluginOptions } = options ?? {};\r\n    return loadSceneSharedAsync(rootUrl, source, engine, onProgress, pluginExtension, name, pluginOptions);\r\n}\r\n\r\n/**\r\n * Load a scene\r\n * @deprecated Please use {@link LoadSceneAsync} instead.\r\n * @param source a string that defines the name of the scene file, or starts with \"data:\" following by the stringified version of the scene, or a File object, or an ArrayBufferView\r\n * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n * @param options an object that configures aspects of how the scene is loaded\r\n * @returns The loaded scene\r\n */\r\nexport function loadSceneAsync(source: SceneSource, engine: AbstractEngine, options?: LoadOptions): Promise<Scene> {\r\n    return LoadSceneAsync(source, engine, options);\r\n}\r\n\r\n// This function is shared between the new module level loadSceneAsync and the legacy SceneLoader.LoadAsync\r\nfunction loadSceneSharedAsync(\r\n    rootUrl: string,\r\n    sceneFilename?: SceneSource,\r\n    engine?: Nullable<AbstractEngine>,\r\n    onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n    pluginExtension?: Nullable<string>,\r\n    name?: string,\r\n    pluginOptions?: PluginOptions\r\n): Promise<Scene> {\r\n    return new Promise((resolve, reject) => {\r\n        loadSceneImplAsync(\r\n            rootUrl,\r\n            sceneFilename,\r\n            engine,\r\n            (scene) => {\r\n                resolve(scene);\r\n            },\r\n            onProgress,\r\n            (scene, message, exception) => {\r\n                reject(exception || new Error(message));\r\n            },\r\n            pluginExtension,\r\n            name,\r\n            pluginOptions\r\n        );\r\n    });\r\n}\r\n\r\n// This is the core implementation of append scene\r\nasync function appendSceneImplAsync(\r\n    rootUrl: string,\r\n    sceneFilename: SceneSource = \"\",\r\n    scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n    onSuccess: Nullable<(scene: Scene) => void> = null,\r\n    onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n    onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n    pluginExtension: Nullable<string> = null,\r\n    name = \"\",\r\n    pluginOptions: PluginOptions = {}\r\n): Promise<Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>> {\r\n    if (!scene) {\r\n        Logger.Error(\"No scene available to append to\");\r\n        return null;\r\n    }\r\n\r\n    const fileInfo = _getFileInfo(rootUrl, sceneFilename);\r\n    if (!fileInfo) {\r\n        return null;\r\n    }\r\n\r\n    const loadingToken = {};\r\n    scene.addPendingData(loadingToken);\r\n\r\n    const disposeHandler = () => {\r\n        scene.removePendingData(loadingToken);\r\n    };\r\n\r\n    if (SceneLoaderFlags.ShowLoadingScreen && !showingLoadingScreen) {\r\n        showingLoadingScreen = true;\r\n        scene.getEngine().displayLoadingUI();\r\n        scene.executeWhenReady(() => {\r\n            scene.getEngine().hideLoadingUI();\r\n            showingLoadingScreen = false;\r\n        });\r\n    }\r\n\r\n    const errorHandler = (message?: string, exception?: any) => {\r\n        const errorMessage = formatErrorMessage(fileInfo, message, exception);\r\n\r\n        if (onError) {\r\n            onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\r\n        } else {\r\n            Logger.Error(errorMessage);\r\n            // should the exception be thrown?\r\n        }\r\n\r\n        disposeHandler();\r\n    };\r\n\r\n    const progressHandler = onProgress\r\n        ? (event: ISceneLoaderProgressEvent) => {\r\n              try {\r\n                  onProgress(event);\r\n              } catch (e) {\r\n                  errorHandler(\"Error in onProgress callback\", e);\r\n              }\r\n          }\r\n        : undefined;\r\n\r\n    const successHandler = () => {\r\n        if (onSuccess) {\r\n            try {\r\n                onSuccess(scene);\r\n            } catch (e) {\r\n                errorHandler(\"Error in onSuccess callback\", e);\r\n            }\r\n        }\r\n\r\n        scene.removePendingData(loadingToken);\r\n    };\r\n\r\n    return await loadDataAsync(\r\n        fileInfo,\r\n        scene,\r\n        (plugin, data) => {\r\n            if ((plugin as ISceneLoaderPlugin).load) {\r\n                const syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {\r\n                    return;\r\n                }\r\n\r\n                scene.loadingPluginName = plugin.name;\r\n                successHandler();\r\n            } else {\r\n                const asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                asyncedPlugin\r\n                    .loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name)\r\n                    .then(() => {\r\n                        scene.loadingPluginName = plugin.name;\r\n                        successHandler();\r\n                    })\r\n                    .catch((error) => {\r\n                        errorHandler(error.message, error);\r\n                    });\r\n            }\r\n        },\r\n        progressHandler,\r\n        errorHandler,\r\n        disposeHandler,\r\n        pluginExtension,\r\n        name,\r\n        pluginOptions\r\n    );\r\n}\r\n\r\n/**\r\n * Append a scene\r\n * @param source a string that defines the name of the scene file, or starts with \"data:\" following by the stringified version of the scene, or a File object, or an ArrayBufferView\r\n * @param scene is the instance of BABYLON.Scene to append to\r\n * @param options an object that configures aspects of how the scene is loaded\r\n * @returns A promise that resolves when the scene is appended\r\n */\r\nexport async function AppendSceneAsync(source: SceneSource, scene: Scene, options?: AppendOptions): Promise<void> {\r\n    const { rootUrl = \"\", onProgress, pluginExtension, name, pluginOptions } = options ?? {};\r\n    await appendSceneSharedAsync(rootUrl, source, scene, onProgress, pluginExtension, name, pluginOptions);\r\n}\r\n\r\n/**\r\n * Append a scene\r\n * @deprecated Please use {@link AppendSceneAsync} instead.\r\n * @param source a string that defines the name of the scene file, or starts with \"data:\" following by the stringified version of the scene, or a File object, or an ArrayBufferView\r\n * @param scene is the instance of BABYLON.Scene to append to\r\n * @param options an object that configures aspects of how the scene is loaded\r\n * @returns A promise that resolves when the scene is appended\r\n */\r\nexport function appendSceneAsync(source: SceneSource, scene: Scene, options?: AppendOptions): Promise<void> {\r\n    return AppendSceneAsync(source, scene, options);\r\n}\r\n\r\n// This function is shared between the new module level appendSceneAsync and the legacy SceneLoader.AppendAsync\r\nfunction appendSceneSharedAsync(\r\n    rootUrl: string,\r\n    sceneFilename?: SceneSource,\r\n    scene?: Nullable<Scene>,\r\n    onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n    pluginExtension?: Nullable<string>,\r\n    name?: string,\r\n    pluginOptions?: PluginOptions\r\n): Promise<Scene> {\r\n    return new Promise((resolve, reject) => {\r\n        try {\r\n            appendSceneImplAsync(\r\n                rootUrl,\r\n                sceneFilename,\r\n                scene,\r\n                (scene) => {\r\n                    resolve(scene);\r\n                },\r\n                onProgress,\r\n                (scene, message, exception) => {\r\n                    reject(exception || new Error(message));\r\n                },\r\n                pluginExtension,\r\n                name,\r\n                pluginOptions\r\n            ).catch(reject);\r\n        } catch (error) {\r\n            reject(error);\r\n        }\r\n    });\r\n}\r\n\r\n// This is the core implementation of load asset container\r\nasync function loadAssetContainerImplAsync(\r\n    rootUrl: string,\r\n    sceneFilename: SceneSource = \"\",\r\n    scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n    onSuccess: Nullable<(assets: AssetContainer) => void> = null,\r\n    onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n    onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n    pluginExtension: Nullable<string> = null,\r\n    name = \"\",\r\n    pluginOptions: PluginOptions = {}\r\n): Promise<Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>> {\r\n    if (!scene) {\r\n        Logger.Error(\"No scene available to load asset container to\");\r\n        return null;\r\n    }\r\n\r\n    const fileInfo = _getFileInfo(rootUrl, sceneFilename);\r\n    if (!fileInfo) {\r\n        return null;\r\n    }\r\n\r\n    const loadingToken = {};\r\n    scene.addPendingData(loadingToken);\r\n\r\n    const disposeHandler = () => {\r\n        scene.removePendingData(loadingToken);\r\n    };\r\n\r\n    const errorHandler = (message?: string, exception?: any) => {\r\n        const errorMessage = formatErrorMessage(fileInfo, message, exception);\r\n\r\n        if (onError) {\r\n            onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\r\n        } else {\r\n            Logger.Error(errorMessage);\r\n            // should the exception be thrown?\r\n        }\r\n\r\n        disposeHandler();\r\n    };\r\n\r\n    const progressHandler = onProgress\r\n        ? (event: ISceneLoaderProgressEvent) => {\r\n              try {\r\n                  onProgress(event);\r\n              } catch (e) {\r\n                  errorHandler(\"Error in onProgress callback\", e);\r\n              }\r\n          }\r\n        : undefined;\r\n\r\n    const successHandler = (assets: AssetContainer) => {\r\n        if (onSuccess) {\r\n            try {\r\n                onSuccess(assets);\r\n            } catch (e) {\r\n                errorHandler(\"Error in onSuccess callback\", e);\r\n            }\r\n        }\r\n\r\n        scene.removePendingData(loadingToken);\r\n    };\r\n\r\n    return await loadDataAsync(\r\n        fileInfo,\r\n        scene,\r\n        (plugin, data) => {\r\n            if ((plugin as ISceneLoaderPlugin).loadAssetContainer) {\r\n                const syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                const assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);\r\n                if (!assetContainer) {\r\n                    return;\r\n                }\r\n                assetContainer.populateRootNodes();\r\n                scene.loadingPluginName = plugin.name;\r\n                successHandler(assetContainer);\r\n            } else if ((plugin as ISceneLoaderPluginAsync).loadAssetContainerAsync) {\r\n                const asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                asyncedPlugin\r\n                    .loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name)\r\n                    .then((assetContainer) => {\r\n                        assetContainer.populateRootNodes();\r\n                        scene.loadingPluginName = plugin.name;\r\n                        successHandler(assetContainer);\r\n                    })\r\n                    .catch((error) => {\r\n                        errorHandler(error.message, error);\r\n                    });\r\n            } else {\r\n                errorHandler(\"LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.\");\r\n            }\r\n        },\r\n        progressHandler,\r\n        errorHandler,\r\n        disposeHandler,\r\n        pluginExtension,\r\n        name,\r\n        pluginOptions\r\n    );\r\n}\r\n\r\n/**\r\n * Load a scene into an asset container\r\n * @param source a string that defines the name of the scene file, or starts with \"data:\" following by the stringified version of the scene, or a File object, or an ArrayBufferView\r\n * @param scene is the instance of Scene to append to\r\n * @param options an object that configures aspects of how the scene is loaded\r\n * @returns The loaded asset container\r\n */\r\nexport function LoadAssetContainerAsync(source: SceneSource, scene: Scene, options?: LoadAssetContainerOptions): Promise<AssetContainer> {\r\n    const { rootUrl = \"\", onProgress, pluginExtension, name, pluginOptions } = options ?? {};\r\n    return loadAssetContainerSharedAsync(rootUrl, source, scene, onProgress, pluginExtension, name, pluginOptions);\r\n}\r\n\r\n/**\r\n * Load a scene into an asset container\r\n * @deprecated Please use {@link LoadAssetContainerAsync} instead.\r\n * @param source a string that defines the name of the scene file, or starts with \"data:\" following by the stringified version of the scene, or a File object, or an ArrayBufferView\r\n * @param scene is the instance of Scene to append to\r\n * @param options an object that configures aspects of how the scene is loaded\r\n * @returns The loaded asset container\r\n */\r\nexport function loadAssetContainerAsync(source: SceneSource, scene: Scene, options?: LoadAssetContainerOptions): Promise<AssetContainer> {\r\n    return LoadAssetContainerAsync(source, scene, options);\r\n}\r\n\r\n// This function is shared between the new module level loadAssetContainerAsync and the legacy SceneLoader.LoadAssetContainerAsync\r\nfunction loadAssetContainerSharedAsync(\r\n    rootUrl: string,\r\n    sceneFilename?: SceneSource,\r\n    scene?: Nullable<Scene>,\r\n    onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n    pluginExtension?: Nullable<string>,\r\n    name?: string,\r\n    pluginOptions?: PluginOptions\r\n): Promise<AssetContainer> {\r\n    return new Promise((resolve, reject) => {\r\n        try {\r\n            loadAssetContainerImplAsync(\r\n                rootUrl,\r\n                sceneFilename,\r\n                scene,\r\n                (assets) => {\r\n                    resolve(assets);\r\n                },\r\n                onProgress,\r\n                (scene, message, exception) => {\r\n                    reject(exception || new Error(message));\r\n                },\r\n                pluginExtension,\r\n                name,\r\n                pluginOptions\r\n            ).catch(reject);\r\n        } catch (error) {\r\n            reject(error);\r\n        }\r\n    });\r\n}\r\n\r\n// This is the core implementation of import animations\r\nasync function importAnimationsImplAsync(\r\n    rootUrl: string,\r\n    sceneFilename: SceneSource = \"\",\r\n    scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n    overwriteAnimations = true,\r\n    animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean,\r\n    targetConverter: Nullable<(target: any) => any> = null,\r\n    onSuccess: Nullable<(scene: Scene) => void> = null,\r\n    onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n    onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n    pluginExtension: Nullable<string> = null,\r\n    name = \"\",\r\n    pluginOptions: PluginOptions = {}\r\n): Promise<void> {\r\n    if (!scene) {\r\n        Logger.Error(\"No scene available to load animations to\");\r\n        return;\r\n    }\r\n\r\n    if (overwriteAnimations) {\r\n        // Reset, stop and dispose all animations before loading new ones\r\n        for (const animatable of scene.animatables) {\r\n            animatable.reset();\r\n        }\r\n        scene.stopAllAnimations();\r\n        scene.animationGroups.slice().forEach((animationGroup) => {\r\n            animationGroup.dispose();\r\n        });\r\n        const nodes = scene.getNodes();\r\n        nodes.forEach((node) => {\r\n            if (node.animations) {\r\n                node.animations = [];\r\n            }\r\n        });\r\n    } else {\r\n        switch (animationGroupLoadingMode) {\r\n            case SceneLoaderAnimationGroupLoadingMode.Clean:\r\n                scene.animationGroups.slice().forEach((animationGroup) => {\r\n                    animationGroup.dispose();\r\n                });\r\n                break;\r\n            case SceneLoaderAnimationGroupLoadingMode.Stop:\r\n                scene.animationGroups.forEach((animationGroup) => {\r\n                    animationGroup.stop();\r\n                });\r\n                break;\r\n            case SceneLoaderAnimationGroupLoadingMode.Sync:\r\n                scene.animationGroups.forEach((animationGroup) => {\r\n                    animationGroup.reset();\r\n                    animationGroup.restart();\r\n                });\r\n                break;\r\n            case SceneLoaderAnimationGroupLoadingMode.NoSync:\r\n                // nothing to do\r\n                break;\r\n            default:\r\n                Logger.Error(\"Unknown animation group loading mode value '\" + animationGroupLoadingMode + \"'\");\r\n                return;\r\n        }\r\n    }\r\n\r\n    const startingIndexForNewAnimatables = scene.animatables.length;\r\n\r\n    const onAssetContainerLoaded = (container: AssetContainer) => {\r\n        container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);\r\n\r\n        container.dispose();\r\n\r\n        scene.onAnimationFileImportedObservable.notifyObservers(scene);\r\n\r\n        if (onSuccess) {\r\n            onSuccess(scene);\r\n        }\r\n    };\r\n\r\n    await loadAssetContainerImplAsync(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension, name, pluginOptions);\r\n}\r\n\r\n/**\r\n * Import animations from a file into a scene\r\n * @param source a string that defines the name of the scene file, or starts with \"data:\" following by the stringified version of the scene, or a File object, or an ArrayBufferView\r\n * @param scene is the instance of BABYLON.Scene to append to\r\n * @param options an object that configures aspects of how the scene is loaded\r\n * @returns A promise that resolves when the animations are imported\r\n */\r\nexport async function ImportAnimationsAsync(source: SceneSource, scene: Scene, options?: ImportAnimationsOptions): Promise<void> {\r\n    const { rootUrl = \"\", overwriteAnimations, animationGroupLoadingMode, targetConverter, onProgress, pluginExtension, name, pluginOptions } = options ?? {};\r\n    await importAnimationsSharedAsync(rootUrl, source, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onProgress, pluginExtension, name, pluginOptions);\r\n}\r\n\r\n/**\r\n * Import animations from a file into a scene\r\n * @deprecated Please use {@link ImportAnimationsAsync} instead.\r\n * @param source a string that defines the name of the scene file, or starts with \"data:\" following by the stringified version of the scene, or a File object, or an ArrayBufferView\r\n * @param scene is the instance of BABYLON.Scene to append to\r\n * @param options an object that configures aspects of how the scene is loaded\r\n * @returns A promise that resolves when the animations are imported\r\n */\r\nexport function importAnimationsAsync(source: SceneSource, scene: Scene, options?: ImportAnimationsOptions): Promise<void> {\r\n    return ImportAnimationsAsync(source, scene, options);\r\n}\r\n\r\n// This function is shared between the new module level importAnimationsAsync and the legacy SceneLoader.ImportAnimationsAsync\r\nfunction importAnimationsSharedAsync(\r\n    rootUrl: string,\r\n    sceneFilename?: SceneSource,\r\n    scene?: Nullable<Scene>,\r\n    overwriteAnimations?: boolean,\r\n    animationGroupLoadingMode?: SceneLoaderAnimationGroupLoadingMode,\r\n    targetConverter?: Nullable<(target: any) => any>,\r\n    onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n    pluginExtension?: Nullable<string>,\r\n    name?: string,\r\n    pluginOptions?: PluginOptions\r\n): Promise<Scene> {\r\n    return new Promise((resolve, reject) => {\r\n        try {\r\n            importAnimationsImplAsync(\r\n                rootUrl,\r\n                sceneFilename,\r\n                scene,\r\n                overwriteAnimations,\r\n                animationGroupLoadingMode,\r\n                targetConverter,\r\n                (scene) => {\r\n                    resolve(scene);\r\n                },\r\n                onProgress,\r\n                (scene, message, exception) => {\r\n                    reject(exception || new Error(message));\r\n                },\r\n                pluginExtension,\r\n                name,\r\n                pluginOptions\r\n            ).catch(reject);\r\n        } catch (error) {\r\n            reject(error);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Class used to load scene from various file formats using registered plugins\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes\r\n * @deprecated The module level functions are more efficient for bundler tree shaking and allow plugin options to be passed through. Future improvements to scene loading will primarily be in the module level functions. The SceneLoader class will remain available, but it will be beneficial to prefer the module level functions.\r\n * @see {@link ImportMeshAsync}, {@link LoadSceneAsync}, {@link AppendSceneAsync}, {@link ImportAnimationsAsync}, {@link LoadAssetContainerAsync}\r\n */\r\nexport class SceneLoader {\r\n    /**\r\n     * No logging while loading\r\n     */\r\n    public static readonly NO_LOGGING = Constants.SCENELOADER_NO_LOGGING;\r\n\r\n    /**\r\n     * Minimal logging while loading\r\n     */\r\n    public static readonly MINIMAL_LOGGING = Constants.SCENELOADER_MINIMAL_LOGGING;\r\n\r\n    /**\r\n     * Summary logging while loading\r\n     */\r\n    public static readonly SUMMARY_LOGGING = Constants.SCENELOADER_SUMMARY_LOGGING;\r\n\r\n    /**\r\n     * Detailed logging while loading\r\n     */\r\n    public static readonly DETAILED_LOGGING = Constants.SCENELOADER_DETAILED_LOGGING;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data\r\n     */\r\n    public static get ForceFullSceneLoadingForIncremental() {\r\n        return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;\r\n    }\r\n\r\n    public static set ForceFullSceneLoadingForIncremental(value: boolean) {\r\n        SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene\r\n     */\r\n    public static get ShowLoadingScreen(): boolean {\r\n        return SceneLoaderFlags.ShowLoadingScreen;\r\n    }\r\n\r\n    public static set ShowLoadingScreen(value: boolean) {\r\n        SceneLoaderFlags.ShowLoadingScreen = value;\r\n    }\r\n\r\n    /**\r\n     * Defines the current logging level (while loading the scene)\r\n     * @ignorenaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static get loggingLevel(): number {\r\n        return SceneLoaderFlags.loggingLevel;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static set loggingLevel(value: number) {\r\n        SceneLoaderFlags.loggingLevel = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or set a boolean indicating if matrix weights must be cleaned upon loading\r\n     */\r\n    public static get CleanBoneMatrixWeights(): boolean {\r\n        return SceneLoaderFlags.CleanBoneMatrixWeights;\r\n    }\r\n\r\n    public static set CleanBoneMatrixWeights(value: boolean) {\r\n        SceneLoaderFlags.CleanBoneMatrixWeights = value;\r\n    }\r\n\r\n    // Members\r\n\r\n    /**\r\n     * Event raised when a plugin is used to load a scene\r\n     */\r\n    public static readonly OnPluginActivatedObservable = onPluginActivatedObservable;\r\n\r\n    /**\r\n     * Gets the default plugin (used to load Babylon files)\r\n     * @returns the .babylon plugin\r\n     */\r\n    public static GetDefaultPlugin(): IRegisteredPlugin | undefined {\r\n        return getDefaultPlugin();\r\n    }\r\n\r\n    // Public functions\r\n\r\n    /**\r\n     * Gets a plugin that can load the given extension\r\n     * @param extension defines the extension to load\r\n     * @returns a plugin or null if none works\r\n     */\r\n    public static GetPluginForExtension(extension: string): ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory | undefined {\r\n        return getPluginForExtension(extension, true)?.plugin;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the given extension can be loaded\r\n     * @param extension defines the extension to load\r\n     * @returns true if the extension is supported\r\n     */\r\n    public static IsPluginForExtensionAvailable(extension: string): boolean {\r\n        return isPluginForExtensionAvailable(extension);\r\n    }\r\n\r\n    /**\r\n     * Adds a new plugin to the list of registered plugins\r\n     * @param plugin defines the plugin to add\r\n     */\r\n    public static RegisterPlugin(plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory): void {\r\n        RegisterSceneLoaderPlugin(plugin);\r\n    }\r\n\r\n    /**\r\n     * Import meshes into a scene\r\n     * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene the instance of BABYLON.Scene to append to\r\n     * @param onSuccess a callback with a list of imported meshes, particleSystems, skeletons, and animationGroups when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the name of the file, if the data is binary\r\n     * @deprecated Please use the module level {@link ImportMeshAsync} instead\r\n     */\r\n    public static ImportMesh(\r\n        meshNames: string | readonly string[] | null | undefined,\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        onSuccess?: Nullable<SceneLoaderSuccessCallback>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ): void {\r\n        importMeshAsync(meshNames, rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension, name).catch((error) =>\r\n            onError?.(EngineStore.LastCreatedScene!, error?.message, error)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Import meshes into a scene\r\n     * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene the instance of BABYLON.Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the name of the file\r\n     * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups\r\n     * @deprecated Please use the module level {@link ImportMeshAsync} instead\r\n     */\r\n    public static ImportMeshAsync(\r\n        meshNames: string | readonly string[] | null | undefined,\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        return importMeshAsyncCore(meshNames, rootUrl, sceneFilename, scene, onProgress, pluginExtension, name);\r\n    }\r\n\r\n    /**\r\n     * Load a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the filename, if the data is binary\r\n     * @deprecated Please use the module level {@link LoadSceneAsync} instead\r\n     */\r\n    public static Load(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        engine?: Nullable<AbstractEngine>,\r\n        onSuccess?: Nullable<(scene: Scene) => void>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ) {\r\n        loadSceneImplAsync(rootUrl, sceneFilename, engine, onSuccess, onProgress, onError, pluginExtension, name).catch((error) =>\r\n            onError?.(EngineStore.LastCreatedScene!, error?.message, error)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Load a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the filename, if the data is binary\r\n     * @returns The loaded scene\r\n     * @deprecated Please use the module level {@link LoadSceneAsync} instead\r\n     */\r\n    public static LoadAsync(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        engine?: Nullable<AbstractEngine>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ): Promise<Scene> {\r\n        return loadSceneSharedAsync(rootUrl, sceneFilename, engine, onProgress, pluginExtension, name);\r\n    }\r\n\r\n    /**\r\n     * Append a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the name of the file, if the data is binary\r\n     * @deprecated Please use the module level {@link AppendSceneAsync} instead\r\n     */\r\n    public static Append(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        onSuccess?: Nullable<(scene: Scene) => void>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ) {\r\n        appendSceneImplAsync(rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension, name).catch((error) =>\r\n            onError?.((scene ?? EngineStore.LastCreatedScene)!, error?.message, error)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Append a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the name of the file, if the data is binary\r\n     * @returns The given scene\r\n     * @deprecated Please use the module level {@link AppendSceneAsync} instead\r\n     */\r\n    public static AppendAsync(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ): Promise<Scene> {\r\n        return appendSceneSharedAsync(rootUrl, sceneFilename, scene, onProgress, pluginExtension, name);\r\n    }\r\n\r\n    /**\r\n     * Load a scene into an asset container\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the filename, if the data is binary\r\n     * @deprecated Please use the module level {@link LoadAssetContainerAsync} instead\r\n     */\r\n    public static LoadAssetContainer(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        onSuccess?: Nullable<(assets: AssetContainer) => void>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ) {\r\n        loadAssetContainerImplAsync(rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension, name).catch((error) =>\r\n            onError?.((scene ?? EngineStore.LastCreatedScene)!, error?.message, error)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Load a scene into an asset container\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene (default: empty string)\r\n     * @param scene is the instance of Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the filename, if the data is binary\r\n     * @returns The loaded asset container\r\n     * @deprecated Please use the module level {@link LoadAssetContainerAsync} instead\r\n     */\r\n    public static LoadAssetContainerAsync(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ): Promise<AssetContainer> {\r\n        return loadAssetContainerSharedAsync(rootUrl, sceneFilename, scene, onProgress, pluginExtension, name);\r\n    }\r\n\r\n    /**\r\n     * Import animations from a file into a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n     * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\r\n     * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the filename, if the data is binary\r\n     * @deprecated Please use the module level {@link ImportAnimationsAsync} instead\r\n     */\r\n    public static ImportAnimations(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        overwriteAnimations?: boolean,\r\n        animationGroupLoadingMode?: SceneLoaderAnimationGroupLoadingMode,\r\n        targetConverter?: Nullable<(target: any) => any>,\r\n        onSuccess?: Nullable<(scene: Scene) => void>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ): void {\r\n        importAnimationsImplAsync(\r\n            rootUrl,\r\n            sceneFilename,\r\n            scene,\r\n            overwriteAnimations,\r\n            animationGroupLoadingMode,\r\n            targetConverter,\r\n            onSuccess,\r\n            onProgress,\r\n            onError,\r\n            pluginExtension,\r\n            name\r\n        ).catch((error) => onError?.((scene ?? EngineStore.LastCreatedScene)!, error?.message, error));\r\n    }\r\n\r\n    /**\r\n     * Import animations from a file into a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n     * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\r\n     * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @param name defines the filename, if the data is binary\r\n     * @returns the updated scene with imported animations\r\n     * @deprecated Please use the module level {@link ImportAnimationsAsync} instead\r\n     */\r\n    public static ImportAnimationsAsync(\r\n        rootUrl: string,\r\n        sceneFilename?: SceneSource,\r\n        scene?: Nullable<Scene>,\r\n        overwriteAnimations?: boolean,\r\n        animationGroupLoadingMode?: SceneLoaderAnimationGroupLoadingMode,\r\n        targetConverter?: Nullable<(target: any) => any>,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        onSuccess?: Nullable<(scene: Scene) => void>,\r\n        onProgress?: Nullable<(event: ISceneLoaderProgressEvent) => void>,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        onError?: Nullable<(scene: Scene, message: string, exception?: any) => void>,\r\n        pluginExtension?: Nullable<string>,\r\n        name?: string\r\n    ): Promise<Scene> {\r\n        return importAnimationsSharedAsync(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onProgress, pluginExtension, name);\r\n    }\r\n}\r\n", "import type { Behavior } from \"../behavior\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\n/**\r\n * A behavior that when attached to a mesh will allow the mesh to fade in and out\r\n */\r\nexport class FadeInOutBehavior implements Behavior<Mesh> {\r\n    /**\r\n     * Time in milliseconds to delay before fading in (Default: 0)\r\n     */\r\n    public fadeInDelay = 0;\r\n\r\n    /**\r\n     * Time in milliseconds to delay before fading out (Default: 0)\r\n     */\r\n    public fadeOutDelay = 0;\r\n\r\n    /**\r\n     * Time in milliseconds for the mesh to fade in (Default: 300)\r\n     */\r\n    public fadeInTime = 300;\r\n\r\n    /**\r\n     * Time in milliseconds for the mesh to fade out (Default: 300)\r\n     */\r\n    public fadeOutTime = 300;\r\n\r\n    /**\r\n     * Time in milliseconds to delay before fading in (Default: 0)\r\n     * Will set both fade in and out delay to the same value\r\n     */\r\n    public get delay(): number {\r\n        return this.fadeInDelay;\r\n    }\r\n\r\n    public set delay(value: number) {\r\n        this.fadeInDelay = value;\r\n        this.fadeOutDelay = value;\r\n    }\r\n\r\n    private _millisecondsPerFrame = 1000 / 60;\r\n    private _hovered = false;\r\n    private _hoverValue = 0;\r\n    private _ownerNode: Nullable<Mesh> = null;\r\n    private _onBeforeRenderObserver: Nullable<Observer<Scene>> | undefined;\r\n    private _delay: number = 0;\r\n    private _time: number = 300;\r\n\r\n    /**\r\n     * Instantiates the FadeInOutBehavior\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"FadeInOut\";\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() {}\r\n\r\n    /**\r\n     * Attaches the fade behavior on the passed in mesh\r\n     * @param ownerNode The mesh that will be faded in/out once attached\r\n     */\r\n    public attach(ownerNode: Mesh): void {\r\n        this._ownerNode = ownerNode;\r\n        this._setAllVisibility(this._ownerNode, 0);\r\n    }\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        this._ownerNode = null;\r\n    }\r\n\r\n    /**\r\n     * Triggers the mesh to begin fading in (or out)\r\n     * @param fadeIn if the object should fade in or out (true to fade in)\r\n     */\r\n    public fadeIn(fadeIn: boolean = true) {\r\n        this._delay = fadeIn ? this.fadeInDelay : this.fadeOutDelay;\r\n        this._time = fadeIn ? this.fadeInTime : this.fadeOutTime;\r\n\r\n        // Cancel any pending updates\r\n        this._detachObserver();\r\n\r\n        // If fading in and already visible or fading out and already not visible do nothing\r\n        if (this._ownerNode && ((fadeIn && this._ownerNode.visibility >= 1) || (!fadeIn && this._ownerNode.visibility <= 0))) {\r\n            return;\r\n        }\r\n\r\n        this._hovered = fadeIn;\r\n        if (!this._hovered) {\r\n            // Make the delay the negative of fadeout delay so the hoverValue is kept above 1 until\r\n            // fadeOutDelay has elapsed\r\n            this._delay *= -1;\r\n        }\r\n\r\n        // Reset the hoverValue.  This is necessary because we may have been fading out, e.g. but not yet reached\r\n        // the delay, so the hover value is greater than 1\r\n        if (this._ownerNode!.visibility >= 1) {\r\n            this._hoverValue = this._time;\r\n        } else if (this._ownerNode!.visibility <= 0) {\r\n            this._hoverValue = 0;\r\n        }\r\n        this._update();\r\n    }\r\n\r\n    /**\r\n     * Triggers the mesh to begin fading out\r\n     */\r\n    public fadeOut() {\r\n        this.fadeIn(false);\r\n    }\r\n\r\n    private _update = () => {\r\n        if (this._ownerNode) {\r\n            this._hoverValue += this._hovered ? this._millisecondsPerFrame : -this._millisecondsPerFrame;\r\n\r\n            this._setAllVisibility(this._ownerNode, (this._hoverValue - this._delay) / this._time);\r\n\r\n            if (this._ownerNode.visibility > 1) {\r\n                this._setAllVisibility(this._ownerNode, 1);\r\n                if (this._hoverValue > this._time) {\r\n                    this._hoverValue = this._time;\r\n                    this._detachObserver();\r\n                    return;\r\n                }\r\n            } else if (this._ownerNode.visibility < 0) {\r\n                this._setAllVisibility(this._ownerNode, 0);\r\n                if (this._hoverValue < 0) {\r\n                    this._hoverValue = 0;\r\n                    this._detachObserver();\r\n                    return;\r\n                }\r\n            }\r\n\r\n            this._attachObserver();\r\n        }\r\n    };\r\n\r\n    private _setAllVisibility(mesh: AbstractMesh, value: number) {\r\n        mesh.visibility = value;\r\n        mesh.getChildMeshes().forEach((c) => {\r\n            this._setAllVisibility(c, value);\r\n        });\r\n    }\r\n\r\n    private _attachObserver() {\r\n        if (!this._onBeforeRenderObserver) {\r\n            this._onBeforeRenderObserver = this._ownerNode?.getScene().onBeforeRenderObservable.add(this._update);\r\n        }\r\n    }\r\n\r\n    private _detachObserver() {\r\n        if (this._onBeforeRenderObserver) {\r\n            this._ownerNode?.getScene().onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\r\n            this._onBeforeRenderObserver = null;\r\n        }\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport * as functions from \"./math.scalar.functions\";\r\n\r\nconst HCF: (a: number, b: number) => number = functions.HighestCommonFactor;\r\n\r\n/**\r\n * Scalar computation library\r\n */\r\nexport const Scalar = {\r\n    ...functions,\r\n\r\n    /**\r\n     * Two pi constants convenient for computation.\r\n     */\r\n    TwoPi: Math.PI * 2,\r\n\r\n    /**\r\n     * Returns -1 if value is negative and +1 is value is positive.\r\n     * @param value the value\r\n     * @returns the value itself if it's equal to zero.\r\n     */\r\n    Sign: Math.sign,\r\n\r\n    /**\r\n     * the log2 of value.\r\n     * @param value the value to compute log2 of\r\n     * @returns the log2 of value.\r\n     */\r\n    Log2: Math.log2,\r\n\r\n    /**\r\n     * Returns the highest common factor of two integers.\r\n     * @param a first parameter\r\n     * @param b second parameter\r\n     * @returns HCF of a and b\r\n     */\r\n    HCF,\r\n};\r\n/* eslint-enable @typescript-eslint/naming-convention */\r\n", "import type { Behavior } from \"../behavior\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport { Matrix, Quaternion, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Clamp } from \"../../Maths/math.scalar.functions\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\n\r\n/**\r\n * A behavior that when attached to a mesh will follow a camera\r\n * @since 5.0.0\r\n */\r\nexport class FollowBehavior implements Behavior<TransformNode> {\r\n    private _scene: Scene;\r\n\r\n    // Memory cache to avoid GC usage\r\n    private _tmpQuaternion: Quaternion = new Quaternion();\r\n    private _tmpVectors: Vector3[] = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];\r\n    private _tmpMatrix: Matrix = new Matrix();\r\n    private _tmpInvertView: Matrix = new Matrix();\r\n    private _tmpForward: Vector3 = new Vector3();\r\n    private _tmpNodeForward: Vector3 = new Vector3();\r\n    private _tmpPosition: Vector3 = new Vector3();\r\n\r\n    private _followedCamera: Nullable<Camera>;\r\n    private _onBeforeRender: Nullable<Observer<Scene>>;\r\n\r\n    private _workingPosition: Vector3 = new Vector3();\r\n    private _workingQuaternion: Quaternion = new Quaternion();\r\n    private _lastTick: number = -1;\r\n    private _recenterNextUpdate = true;\r\n\r\n    /**\r\n     * Attached node of this behavior\r\n     */\r\n    public attachedNode: Nullable<TransformNode>;\r\n\r\n    /**\r\n     * Set to false if the node should strictly follow the camera without any interpolation time\r\n     */\r\n    public interpolatePose = true;\r\n\r\n    /**\r\n     * Rate of interpolation of position and rotation of the attached node.\r\n     * Higher values will give a slower interpolation.\r\n     */\r\n    public lerpTime = 500;\r\n\r\n    /**\r\n     * If the behavior should ignore the pitch and roll of the camera.\r\n     */\r\n    public ignoreCameraPitchAndRoll = false;\r\n\r\n    /**\r\n     * Pitch offset from camera (relative to Max Distance)\r\n     * Is only effective if `ignoreCameraPitchAndRoll` is set to `true`.\r\n     */\r\n    public pitchOffset = 15;\r\n\r\n    /**\r\n     * The vertical angle from the camera forward axis to the owner will not exceed this value\r\n     */\r\n    public maxViewVerticalDegrees = 30;\r\n\r\n    /**\r\n     * The horizontal angle from the camera forward axis to the owner will not exceed this value\r\n     */\r\n    public maxViewHorizontalDegrees = 30;\r\n    /**\r\n     * The attached node will not reorient until the angle between its forward vector and the vector to the camera is greater than this value\r\n     */\r\n    public orientToCameraDeadzoneDegrees = 60;\r\n    /**\r\n     * Option to ignore distance clamping\r\n     */\r\n    public ignoreDistanceClamp = false;\r\n    /**\r\n     * Option to ignore angle clamping\r\n     */\r\n    public ignoreAngleClamp = false;\r\n    /**\r\n     * Max vertical distance between the attachedNode and camera\r\n     */\r\n    public verticalMaxDistance = 0;\r\n    /**\r\n     *  Default distance from eye to attached node, i.e. the sphere radius\r\n     */\r\n    public defaultDistance = 0.8;\r\n    /**\r\n     *  Max distance from eye to attached node, i.e. the sphere radius\r\n     */\r\n    public maximumDistance = 2;\r\n    /**\r\n     *  Min distance from eye to attached node, i.e. the sphere radius\r\n     */\r\n    public minimumDistance = 0.3;\r\n\r\n    /**\r\n     * Ignore vertical movement and lock the Y position of the object.\r\n     */\r\n    public useFixedVerticalOffset = false;\r\n\r\n    /**\r\n     * Fixed vertical position offset distance.\r\n     */\r\n    public fixedVerticalOffset = 0;\r\n\r\n    /**\r\n     * Enables/disables the behavior\r\n     * @internal\r\n     */\r\n    public _enabled = true;\r\n\r\n    /**\r\n     * The camera that should be followed by this behavior\r\n     */\r\n    public get followedCamera(): Nullable<Camera> {\r\n        return this._followedCamera || this._scene.activeCamera;\r\n    }\r\n\r\n    public set followedCamera(camera: Nullable<Camera>) {\r\n        this._followedCamera = camera;\r\n    }\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"Follow\";\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() {}\r\n\r\n    /**\r\n     * Attaches the follow behavior\r\n     * @param ownerNode The mesh that will be following once attached\r\n     * @param followedCamera The camera that should be followed by the node\r\n     */\r\n    public attach(ownerNode: TransformNode, followedCamera?: Camera): void {\r\n        this._scene = ownerNode.getScene();\r\n        this.attachedNode = ownerNode;\r\n\r\n        if (followedCamera) {\r\n            this.followedCamera = followedCamera;\r\n        }\r\n\r\n        this._addObservables();\r\n    }\r\n\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        this.attachedNode = null;\r\n        this._removeObservables();\r\n    }\r\n\r\n    /**\r\n     * Recenters the attached node in front of the camera on the next update\r\n     */\r\n    public recenter() {\r\n        this._recenterNextUpdate = true;\r\n    }\r\n\r\n    private _angleBetweenVectorAndPlane(vector: Vector3, normal: Vector3) {\r\n        // Work on copies\r\n        this._tmpVectors[0].copyFrom(vector);\r\n        vector = this._tmpVectors[0];\r\n        this._tmpVectors[1].copyFrom(normal);\r\n        normal = this._tmpVectors[1];\r\n\r\n        vector.normalize();\r\n        normal.normalize();\r\n\r\n        return Math.PI / 2 - Math.acos(Vector3.Dot(vector, normal));\r\n    }\r\n\r\n    private _length2D(vector: Vector3) {\r\n        return Math.sqrt(vector.x * vector.x + vector.z * vector.z);\r\n    }\r\n\r\n    private _distanceClamp(currentToTarget: Vector3, moveToDefault: boolean = false) {\r\n        let minDistance = this.minimumDistance;\r\n        let maxDistance = this.maximumDistance;\r\n        const defaultDistance = this.defaultDistance;\r\n\r\n        const direction = this._tmpVectors[0];\r\n        direction.copyFrom(currentToTarget);\r\n        let currentDistance = direction.length();\r\n        direction.normalizeFromLength(currentDistance);\r\n\r\n        if (this.ignoreCameraPitchAndRoll) {\r\n            // If we don't account for pitch offset, the casted object will float up/down as the reference\r\n            // gets closer to it because we will still be casting in the direction of the pitched offset.\r\n            // To fix this, only modify the XZ position of the object.\r\n            minDistance = this._length2D(direction) * minDistance;\r\n            maxDistance = this._length2D(direction) * maxDistance;\r\n\r\n            const currentDistance2D = this._length2D(currentToTarget);\r\n            direction.scaleInPlace(currentDistance / currentDistance2D);\r\n            currentDistance = currentDistance2D;\r\n        }\r\n\r\n        let clampedDistance = currentDistance;\r\n\r\n        if (moveToDefault) {\r\n            clampedDistance = defaultDistance;\r\n        } else {\r\n            clampedDistance = Clamp(currentDistance, minDistance, maxDistance);\r\n        }\r\n\r\n        currentToTarget.copyFrom(direction).scaleInPlace(clampedDistance);\r\n\r\n        return currentDistance !== clampedDistance;\r\n    }\r\n\r\n    private _applyVerticalClamp(currentToTarget: Vector3) {\r\n        if (this.verticalMaxDistance !== 0) {\r\n            currentToTarget.y = Clamp(currentToTarget.y, -this.verticalMaxDistance, this.verticalMaxDistance);\r\n        }\r\n    }\r\n\r\n    private _toOrientationQuatToRef(vector: Vector3, quaternion: Quaternion) {\r\n        Quaternion.RotationYawPitchRollToRef(Math.atan2(vector.x, vector.z), Math.atan2(vector.y, Math.sqrt(vector.z * vector.z + vector.x * vector.x)), 0, quaternion);\r\n    }\r\n\r\n    private _applyPitchOffset(invertView: Matrix) {\r\n        const forward = this._tmpVectors[0];\r\n        const right = this._tmpVectors[1];\r\n        forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n        right.copyFromFloats(1, 0, 0);\r\n        Vector3.TransformNormalToRef(forward, invertView, forward);\r\n        forward.y = 0;\r\n        forward.normalize();\r\n        Vector3.TransformNormalToRef(right, invertView, right);\r\n\r\n        Quaternion.RotationAxisToRef(right, (this.pitchOffset * Math.PI) / 180, this._tmpQuaternion);\r\n        forward.rotateByQuaternionToRef(this._tmpQuaternion, forward);\r\n        this._toOrientationQuatToRef(forward, this._tmpQuaternion);\r\n        this._tmpQuaternion.toRotationMatrix(this._tmpMatrix);\r\n\r\n        // Since we already extracted position from the invert view matrix, we can\r\n        // disregard the position part of the matrix in the copy\r\n        invertView.copyFrom(this._tmpMatrix);\r\n    }\r\n\r\n    private _angularClamp(invertView: Matrix, currentToTarget: Vector3): boolean {\r\n        const forward = this._tmpVectors[5];\r\n        forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n        const right = this._tmpVectors[6];\r\n        right.copyFromFloats(1, 0, 0);\r\n\r\n        // forward and right are related to camera frame of reference\r\n        Vector3.TransformNormalToRef(forward, invertView, forward);\r\n        Vector3.TransformNormalToRef(right, invertView, right);\r\n\r\n        // Up is global Z\r\n        const up = Vector3.UpReadOnly;\r\n\r\n        const dist = currentToTarget.length();\r\n\r\n        if (dist < Epsilon) {\r\n            return false;\r\n        }\r\n\r\n        let angularClamped = false;\r\n        const rotationQuat = this._tmpQuaternion;\r\n\r\n        // X-axis leashing\r\n        if (this.ignoreCameraPitchAndRoll) {\r\n            const angle = Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);\r\n            Quaternion.RotationAxisToRef(right, angle, rotationQuat);\r\n            currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n        } else {\r\n            const angle = -Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);\r\n            const minMaxAngle = ((this.maxViewVerticalDegrees * Math.PI) / 180) * 0.5;\r\n            if (angle < -minMaxAngle) {\r\n                Quaternion.RotationAxisToRef(right, -angle - minMaxAngle, rotationQuat);\r\n                currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n                angularClamped = true;\r\n            } else if (angle > minMaxAngle) {\r\n                Quaternion.RotationAxisToRef(right, -angle + minMaxAngle, rotationQuat);\r\n                currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n                angularClamped = true;\r\n            }\r\n        }\r\n\r\n        // Y-axis leashing\r\n        const angle = this._angleBetweenVectorAndPlane(currentToTarget, right) * (this._scene.useRightHandedSystem ? -1 : 1);\r\n        const minMaxAngle = ((this.maxViewHorizontalDegrees * Math.PI) / 180) * 0.5;\r\n        if (angle < -minMaxAngle) {\r\n            Quaternion.RotationAxisToRef(up, -angle - minMaxAngle, rotationQuat);\r\n            currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n            angularClamped = true;\r\n        } else if (angle > minMaxAngle) {\r\n            Quaternion.RotationAxisToRef(up, -angle + minMaxAngle, rotationQuat);\r\n            currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n            angularClamped = true;\r\n        }\r\n\r\n        return angularClamped;\r\n    }\r\n\r\n    private _orientationClamp(currentToTarget: Vector3, rotationQuaternion: Quaternion) {\r\n        // Construct a rotation quat from up vector and target vector\r\n        const toFollowed = this._tmpVectors[0];\r\n        toFollowed.copyFrom(currentToTarget).scaleInPlace(-1).normalize();\r\n\r\n        const up = this._tmpVectors[1];\r\n        const right = this._tmpVectors[2];\r\n        // We use global up vector to orient the following node (global +Y)\r\n        up.copyFromFloats(0, 1, 0);\r\n\r\n        // Gram-Schmidt to create an orthonormal frame\r\n        Vector3.CrossToRef(toFollowed, up, right);\r\n        const length = right.length();\r\n\r\n        if (length < Epsilon) {\r\n            return;\r\n        }\r\n\r\n        right.normalizeFromLength(length);\r\n\r\n        Vector3.CrossToRef(right, toFollowed, up);\r\n        if (this.attachedNode?.getScene().useRightHandedSystem) {\r\n            Quaternion.FromLookDirectionRHToRef(toFollowed, up, rotationQuaternion);\r\n        } else {\r\n            Quaternion.FromLookDirectionLHToRef(toFollowed, up, rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    private _passedOrientationDeadzone(currentToTarget: Vector3, forward: Vector3) {\r\n        const leashToFollow = this._tmpVectors[5];\r\n        leashToFollow.copyFrom(currentToTarget);\r\n        leashToFollow.normalize();\r\n\r\n        const angle = Math.abs(Vector3.GetAngleBetweenVectorsOnPlane(forward, leashToFollow, Vector3.UpReadOnly));\r\n        return (angle * 180) / Math.PI > this.orientToCameraDeadzoneDegrees;\r\n    }\r\n\r\n    private _updateLeashing(camera: Camera) {\r\n        if (this.attachedNode && this._enabled) {\r\n            const oldParent = this.attachedNode.parent;\r\n            this.attachedNode.setParent(null);\r\n\r\n            const worldMatrix = this.attachedNode.getWorldMatrix();\r\n            const currentToTarget = this._workingPosition;\r\n            const rotationQuaternion = this._workingQuaternion;\r\n            const pivot = this.attachedNode.getPivotPoint();\r\n            const invertView = this._tmpInvertView;\r\n            invertView.copyFrom(camera.getViewMatrix());\r\n            invertView.invert();\r\n\r\n            Vector3.TransformCoordinatesToRef(pivot, worldMatrix, currentToTarget);\r\n            const position = this._tmpPosition;\r\n            position.copyFromFloats(0, 0, 0);\r\n            Vector3.TransformCoordinatesToRef(position, worldMatrix, position);\r\n            position.scaleInPlace(-1).subtractInPlace(pivot);\r\n            currentToTarget.subtractInPlace(camera.globalPosition);\r\n\r\n            if (this.ignoreCameraPitchAndRoll) {\r\n                this._applyPitchOffset(invertView);\r\n            }\r\n\r\n            let angularClamped = false;\r\n            const forward = this._tmpForward;\r\n            forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n            Vector3.TransformNormalToRef(forward, invertView, forward);\r\n\r\n            const nodeForward = this._tmpNodeForward;\r\n            nodeForward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n            Vector3.TransformNormalToRef(nodeForward, worldMatrix, nodeForward);\r\n\r\n            if (this._recenterNextUpdate) {\r\n                currentToTarget.copyFrom(forward).scaleInPlace(this.defaultDistance);\r\n            } else {\r\n                if (this.ignoreAngleClamp) {\r\n                    const currentDistance = currentToTarget.length();\r\n                    currentToTarget.copyFrom(forward).scaleInPlace(currentDistance);\r\n                } else {\r\n                    angularClamped = this._angularClamp(invertView, currentToTarget);\r\n                }\r\n            }\r\n\r\n            let distanceClamped = false;\r\n            if (!this.ignoreDistanceClamp) {\r\n                distanceClamped = this._distanceClamp(currentToTarget, angularClamped);\r\n                this._applyVerticalClamp(currentToTarget);\r\n            }\r\n\r\n            if (this.useFixedVerticalOffset) {\r\n                currentToTarget.y = position.y - camera.globalPosition.y + this.fixedVerticalOffset;\r\n            }\r\n\r\n            if (angularClamped || distanceClamped || this._passedOrientationDeadzone(currentToTarget, nodeForward) || this._recenterNextUpdate) {\r\n                this._orientationClamp(currentToTarget, rotationQuaternion);\r\n            }\r\n\r\n            this._workingPosition.subtractInPlace(pivot);\r\n            this._recenterNextUpdate = false;\r\n\r\n            this.attachedNode.setParent(oldParent);\r\n        }\r\n    }\r\n\r\n    private _updateTransformToGoal(elapsed: number) {\r\n        if (!this.attachedNode || !this.followedCamera || !this._enabled) {\r\n            return;\r\n        }\r\n\r\n        if (!this.attachedNode.rotationQuaternion) {\r\n            this.attachedNode.rotationQuaternion = Quaternion.Identity();\r\n        }\r\n\r\n        const oldParent = this.attachedNode.parent;\r\n        this.attachedNode.setParent(null);\r\n\r\n        if (!this.interpolatePose) {\r\n            this.attachedNode.position.copyFrom(this.followedCamera.globalPosition).addInPlace(this._workingPosition);\r\n            this.attachedNode.rotationQuaternion.copyFrom(this._workingQuaternion);\r\n            return;\r\n        }\r\n\r\n        // position\r\n        const currentDirection = new Vector3();\r\n        currentDirection.copyFrom(this.attachedNode.position).subtractInPlace(this.followedCamera.globalPosition);\r\n        Vector3.SmoothToRef(currentDirection, this._workingPosition, elapsed, this.lerpTime, currentDirection);\r\n        currentDirection.addInPlace(this.followedCamera.globalPosition);\r\n        this.attachedNode.position.copyFrom(currentDirection);\r\n\r\n        // rotation\r\n        const currentRotation = new Quaternion();\r\n        currentRotation.copyFrom(this.attachedNode.rotationQuaternion);\r\n        Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this.attachedNode.rotationQuaternion);\r\n\r\n        this.attachedNode.setParent(oldParent);\r\n    }\r\n\r\n    private _addObservables() {\r\n        this._lastTick = Date.now();\r\n        this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {\r\n            if (!this.followedCamera) {\r\n                return;\r\n            }\r\n\r\n            const tick = Date.now();\r\n            this._updateLeashing(this.followedCamera);\r\n            this._updateTransformToGoal(tick - this._lastTick);\r\n            this._lastTick = tick;\r\n        });\r\n    }\r\n\r\n    private _removeObservables() {\r\n        if (this._onBeforeRender) {\r\n            this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);\r\n        }\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { Camera } from \"../../Cameras/camera\";\r\nimport type { Ray } from \"../../Culling/ray\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\n\r\n/**\r\n * Data store to track virtual pointers movement\r\n */\r\ntype VirtualMeshInfo = {\r\n    dragging: boolean;\r\n    moving: boolean;\r\n    dragMesh: TransformNode;\r\n    originMesh: TransformNode;\r\n    pivotMesh: TransformNode;\r\n    startingPivotPosition: Vector3;\r\n    startingPivotOrientation: Quaternion;\r\n    startingPosition: Vector3;\r\n    startingOrientation: Quaternion;\r\n    lastOriginPosition: Vector3;\r\n    lastDragPosition: Vector3;\r\n};\r\n\r\n/**\r\n * Base behavior for six degrees of freedom interactions in XR experiences.\r\n * Creates virtual meshes that are dragged around\r\n * And observables for position/rotation changes\r\n */\r\nexport class BaseSixDofDragBehavior implements Behavior<Mesh> {\r\n    protected static _virtualScene: Scene;\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>>;\r\n    private _attachedToElement: boolean = false;\r\n    protected _virtualMeshesInfo: {\r\n        [id: number]: VirtualMeshInfo;\r\n    } = {};\r\n\r\n    private _tmpVector: Vector3 = new Vector3();\r\n    private _tmpQuaternion: Quaternion = new Quaternion();\r\n\r\n    protected _dragType = {\r\n        NONE: 0,\r\n        DRAG: 1,\r\n        DRAG_WITH_CONTROLLER: 2,\r\n        NEAR_DRAG: 3,\r\n    };\r\n\r\n    protected _scene: Scene;\r\n    protected _moving = false;\r\n    protected _ownerNode: TransformNode;\r\n    protected _dragging = this._dragType.NONE;\r\n\r\n    /**\r\n     * The list of child meshes that can receive drag events\r\n     * If `null`, all child meshes will receive drag event\r\n     */\r\n    public draggableMeshes: Nullable<AbstractMesh[]> = null;\r\n\r\n    /**\r\n     * How much faster the object should move when the controller is moving towards it. This is useful to bring objects that are far away from the user to them faster. Set this to 0 to avoid any speed increase. (Default: 3)\r\n     */\r\n    public zDragFactor = 3;\r\n    /**\r\n     * The id of the pointer that is currently interacting with the behavior (-1 when no pointer is active)\r\n     */\r\n    public get currentDraggingPointerId() {\r\n        if (this.currentDraggingPointerIds[0] !== undefined) {\r\n            return this.currentDraggingPointerIds[0];\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public set currentDraggingPointerId(value: number) {\r\n        this.currentDraggingPointerIds[0] = value;\r\n    }\r\n\r\n    /**\r\n     * In case of multipointer interaction, all pointer ids currently active are stored here\r\n     */\r\n    public currentDraggingPointerIds: number[] = [];\r\n\r\n    /**\r\n     * Get or set the currentDraggingPointerId\r\n     * @deprecated Please use currentDraggingPointerId instead\r\n     */\r\n    public get currentDraggingPointerID(): number {\r\n        return this.currentDraggingPointerId;\r\n    }\r\n    public set currentDraggingPointerID(currentDraggingPointerID: number) {\r\n        this.currentDraggingPointerId = currentDraggingPointerID;\r\n    }\r\n    /**\r\n    /**\r\n     * If camera controls should be detached during the drag\r\n     */\r\n    public detachCameraControls = true;\r\n\r\n    /**\r\n     * Fires each time a drag starts\r\n     */\r\n    public onDragStartObservable = new Observable<{ position: Vector3 }>();\r\n    /**\r\n     * Fires each time a drag happens\r\n     */\r\n    public onDragObservable = new Observable<{ delta: Vector3; position: Vector3; pickInfo: PickingInfo }>();\r\n    /**\r\n     *  Fires each time a drag ends (eg. mouse release after drag)\r\n     */\r\n    public onDragEndObservable = new Observable<{}>();\r\n\r\n    /**\r\n     * Should the behavior allow simultaneous pointers to interact with the owner node.\r\n     */\r\n    public allowMultiPointer: boolean = true;\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"BaseSixDofDrag\";\r\n    }\r\n\r\n    /**\r\n     *  Returns true if the attached mesh is currently moving with this behavior\r\n     */\r\n    public get isMoving(): boolean {\r\n        return this._moving;\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() {}\r\n\r\n    /**\r\n     * In the case of multiple active cameras, the cameraToUseForPointers should be used if set instead of active camera\r\n     */\r\n    private get _pointerCamera() {\r\n        if (this._scene.cameraToUseForPointers) {\r\n            return this._scene.cameraToUseForPointers;\r\n        } else {\r\n            return this._scene.activeCamera;\r\n        }\r\n    }\r\n\r\n    private _createVirtualMeshInfo() {\r\n        // Setup virtual meshes to be used for dragging without dirtying the existing scene\r\n\r\n        const dragMesh = new TransformNode(\"\", BaseSixDofDragBehavior._virtualScene);\r\n        dragMesh.rotationQuaternion = new Quaternion();\r\n        const originMesh = new TransformNode(\"\", BaseSixDofDragBehavior._virtualScene);\r\n        originMesh.rotationQuaternion = new Quaternion();\r\n        const pivotMesh = new TransformNode(\"\", BaseSixDofDragBehavior._virtualScene);\r\n        pivotMesh.rotationQuaternion = new Quaternion();\r\n\r\n        return {\r\n            dragging: false,\r\n            moving: false,\r\n            dragMesh,\r\n            originMesh,\r\n            pivotMesh,\r\n            startingPivotPosition: new Vector3(),\r\n            startingPivotOrientation: new Quaternion(),\r\n            startingPosition: new Vector3(),\r\n            startingOrientation: new Quaternion(),\r\n            lastOriginPosition: new Vector3(),\r\n            lastDragPosition: new Vector3(),\r\n        };\r\n    }\r\n\r\n    protected _resetVirtualMeshesPosition() {\r\n        for (let i = 0; i < this.currentDraggingPointerIds.length; i++) {\r\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.position.copyFrom(this._ownerNode.getAbsolutePivotPoint());\r\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.rotationQuaternion!.copyFrom(this._ownerNode.rotationQuaternion!);\r\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPivotPosition.copyFrom(\r\n                this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.position\r\n            );\r\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPivotOrientation.copyFrom(\r\n                this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.rotationQuaternion!\r\n            );\r\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPosition.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].dragMesh.position);\r\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingOrientation.copyFrom(\r\n                this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].dragMesh.rotationQuaternion!\r\n            );\r\n        }\r\n    }\r\n\r\n    private _pointerUpdate2D(ray: Ray, pointerId: number, zDragFactor: number) {\r\n        if (this._pointerCamera && this._pointerCamera.cameraRigMode == Camera.RIG_MODE_NONE && !this._pointerCamera._isLeftCamera && !this._pointerCamera._isRightCamera) {\r\n            ray.origin.copyFrom(this._pointerCamera!.globalPosition);\r\n            zDragFactor = 0;\r\n        }\r\n\r\n        const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];\r\n\r\n        // Calculate controller drag distance in controller space\r\n        const originDragDifference = TmpVectors.Vector3[11];\r\n        ray.origin.subtractToRef(virtualMeshesInfo.lastOriginPosition, originDragDifference);\r\n        virtualMeshesInfo.lastOriginPosition.copyFrom(ray.origin);\r\n        const localOriginDragDifference = -Vector3.Dot(originDragDifference, ray.direction);\r\n\r\n        virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.dragMesh);\r\n        virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.pivotMesh);\r\n\r\n        this._applyZOffset(virtualMeshesInfo.dragMesh, localOriginDragDifference, zDragFactor);\r\n        this._applyZOffset(virtualMeshesInfo.pivotMesh, localOriginDragDifference, zDragFactor);\r\n\r\n        // Update the controller position\r\n        virtualMeshesInfo.originMesh.position.copyFrom(ray.origin);\r\n        const lookAt = TmpVectors.Vector3[10];\r\n        ray.origin.addToRef(ray.direction, lookAt);\r\n        virtualMeshesInfo.originMesh.lookAt(lookAt);\r\n\r\n        virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.dragMesh);\r\n        virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.pivotMesh);\r\n    }\r\n\r\n    private _pointerUpdateXR(controllerAimTransform: TransformNode, controllerGripTransform: Nullable<TransformNode>, pointerId: number, zDragFactor: number) {\r\n        const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];\r\n        virtualMeshesInfo.originMesh.position.copyFrom(controllerAimTransform.position);\r\n        if (this._dragging === this._dragType.NEAR_DRAG && controllerGripTransform) {\r\n            virtualMeshesInfo.originMesh.rotationQuaternion!.copyFrom(controllerGripTransform.rotationQuaternion!);\r\n        } else {\r\n            virtualMeshesInfo.originMesh.rotationQuaternion!.copyFrom(controllerAimTransform.rotationQuaternion!);\r\n        }\r\n\r\n        virtualMeshesInfo.pivotMesh.computeWorldMatrix(true);\r\n        virtualMeshesInfo.dragMesh.computeWorldMatrix(true);\r\n\r\n        // Z scaling logic\r\n        if (zDragFactor !== 0) {\r\n            // Camera.getForwardRay modifies TmpVectors.Vector[0-3], so cache it in advance\r\n            const cameraForwardVec = TmpVectors.Vector3[10];\r\n            const originDragDirection = TmpVectors.Vector3[11];\r\n            cameraForwardVec.copyFrom(this._pointerCamera!.getForwardRay().direction);\r\n            virtualMeshesInfo.originMesh.position.subtractToRef(virtualMeshesInfo.lastOriginPosition, originDragDirection);\r\n            virtualMeshesInfo.lastOriginPosition.copyFrom(virtualMeshesInfo.originMesh.position);\r\n            const controllerDragDistance = originDragDirection.length();\r\n            originDragDirection.normalize();\r\n\r\n            const cameraToDrag = TmpVectors.Vector3[12];\r\n            const controllerToDrag = TmpVectors.Vector3[9];\r\n            virtualMeshesInfo.dragMesh.absolutePosition.subtractToRef(this._pointerCamera!.globalPosition, cameraToDrag);\r\n            virtualMeshesInfo.dragMesh.absolutePosition.subtractToRef(virtualMeshesInfo.originMesh.position, controllerToDrag);\r\n            const controllerToDragDistance = controllerToDrag.length();\r\n            cameraToDrag.normalize();\r\n            controllerToDrag.normalize();\r\n\r\n            const controllerDragScaling = Math.abs(Vector3.Dot(originDragDirection, controllerToDrag)) * Vector3.Dot(originDragDirection, cameraForwardVec);\r\n            let zOffsetScaling = controllerDragScaling * zDragFactor * controllerDragDistance * controllerToDragDistance;\r\n\r\n            // Prevent pulling the mesh through the controller\r\n            const minDistanceFromControllerToDragMesh = 0.01;\r\n            if (zOffsetScaling < 0 && minDistanceFromControllerToDragMesh - controllerToDragDistance > zOffsetScaling) {\r\n                zOffsetScaling = Math.min(minDistanceFromControllerToDragMesh - controllerToDragDistance, 0);\r\n            }\r\n            controllerToDrag.scaleInPlace(zOffsetScaling);\r\n\r\n            controllerToDrag.addToRef(virtualMeshesInfo.pivotMesh.absolutePosition, this._tmpVector);\r\n            virtualMeshesInfo.pivotMesh.setAbsolutePosition(this._tmpVector);\r\n            controllerToDrag.addToRef(virtualMeshesInfo.dragMesh.absolutePosition, this._tmpVector);\r\n            virtualMeshesInfo.dragMesh.setAbsolutePosition(this._tmpVector);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attaches the scale behavior the passed in mesh\r\n     * @param ownerNode The mesh that will be scaled around once attached\r\n     */\r\n    public attach(ownerNode: TransformNode): void {\r\n        this._ownerNode = ownerNode;\r\n        this._scene = this._ownerNode.getScene();\r\n        if (!BaseSixDofDragBehavior._virtualScene) {\r\n            BaseSixDofDragBehavior._virtualScene = new Scene(this._scene.getEngine(), { virtual: true });\r\n            BaseSixDofDragBehavior._virtualScene.detachControl();\r\n        }\r\n\r\n        const pickPredicate = (m: AbstractMesh) => {\r\n            return this._ownerNode === m || (m.isDescendantOf(this._ownerNode) && (!this.draggableMeshes || this.draggableMeshes.indexOf(m) !== -1));\r\n        };\r\n\r\n        this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {\r\n            const pointerId = (<IPointerEvent>pointerInfo.event).pointerId;\r\n            if (!this._virtualMeshesInfo[pointerId]) {\r\n                this._virtualMeshesInfo[pointerId] = this._createVirtualMeshInfo();\r\n            }\r\n            const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];\r\n            const isXRPointer = (<IPointerEvent>pointerInfo.event).pointerType === \"xr-near\" || (<IPointerEvent>pointerInfo.event).pointerType === \"xr\";\r\n            const isNearXRPointer = (<IPointerEvent>pointerInfo.event).pointerType === \"xr-near\";\r\n            if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {\r\n                if (\r\n                    !virtualMeshesInfo.dragging &&\r\n                    pointerInfo.pickInfo &&\r\n                    pointerInfo.pickInfo.hit &&\r\n                    pointerInfo.pickInfo.pickedMesh &&\r\n                    pointerInfo.pickInfo.pickedPoint &&\r\n                    pointerInfo.pickInfo.ray &&\r\n                    (!isNearXRPointer || pointerInfo.pickInfo.aimTransform) &&\r\n                    pickPredicate(pointerInfo.pickInfo.pickedMesh)\r\n                ) {\r\n                    if ((!this.allowMultiPointer || isXRPointer) && this.currentDraggingPointerIds.length > 0) {\r\n                        return;\r\n                    }\r\n\r\n                    if (\r\n                        this._pointerCamera &&\r\n                        this._pointerCamera.cameraRigMode === Camera.RIG_MODE_NONE &&\r\n                        !this._pointerCamera._isLeftCamera &&\r\n                        !this._pointerCamera._isRightCamera\r\n                    ) {\r\n                        pointerInfo.pickInfo.ray.origin.copyFrom(this._pointerCamera!.globalPosition);\r\n                    }\r\n\r\n                    this._ownerNode.computeWorldMatrix(true);\r\n                    const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];\r\n\r\n                    if (isXRPointer) {\r\n                        this._dragging = pointerInfo.pickInfo.originMesh ? this._dragType.NEAR_DRAG : this._dragType.DRAG_WITH_CONTROLLER;\r\n                        virtualMeshesInfo.originMesh.position.copyFrom(pointerInfo.pickInfo.aimTransform!.position);\r\n                        if (this._dragging === this._dragType.NEAR_DRAG && pointerInfo.pickInfo.gripTransform) {\r\n                            virtualMeshesInfo.originMesh.rotationQuaternion!.copyFrom(pointerInfo.pickInfo.gripTransform.rotationQuaternion!);\r\n                        } else {\r\n                            virtualMeshesInfo.originMesh.rotationQuaternion!.copyFrom(pointerInfo.pickInfo.aimTransform!.rotationQuaternion!);\r\n                        }\r\n                    } else {\r\n                        this._dragging = this._dragType.DRAG;\r\n                        virtualMeshesInfo.originMesh.position.copyFrom(pointerInfo.pickInfo.ray.origin);\r\n                    }\r\n\r\n                    virtualMeshesInfo.lastOriginPosition.copyFrom(virtualMeshesInfo.originMesh.position);\r\n\r\n                    virtualMeshesInfo.dragMesh.position.copyFrom(pointerInfo.pickInfo.pickedPoint);\r\n                    virtualMeshesInfo.lastDragPosition.copyFrom(pointerInfo.pickInfo.pickedPoint);\r\n\r\n                    virtualMeshesInfo.pivotMesh.position.copyFrom(this._ownerNode.getAbsolutePivotPoint());\r\n                    virtualMeshesInfo.pivotMesh.rotationQuaternion!.copyFrom(this._ownerNode.absoluteRotationQuaternion);\r\n\r\n                    virtualMeshesInfo.startingPosition.copyFrom(virtualMeshesInfo.dragMesh.position);\r\n                    virtualMeshesInfo.startingPivotPosition.copyFrom(virtualMeshesInfo.pivotMesh.position);\r\n                    virtualMeshesInfo.startingOrientation.copyFrom(virtualMeshesInfo.dragMesh.rotationQuaternion!);\r\n                    virtualMeshesInfo.startingPivotOrientation.copyFrom(virtualMeshesInfo.pivotMesh.rotationQuaternion!);\r\n\r\n                    if (isNearXRPointer) {\r\n                        virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.dragMesh);\r\n                        virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.pivotMesh);\r\n                    } else {\r\n                        virtualMeshesInfo.originMesh.lookAt(virtualMeshesInfo.dragMesh.position);\r\n                    }\r\n\r\n                    // Update state\r\n                    virtualMeshesInfo.dragging = true;\r\n\r\n                    if (this.currentDraggingPointerIds.indexOf(pointerId) === -1) {\r\n                        this.currentDraggingPointerIds.push(pointerId);\r\n                    }\r\n\r\n                    // Detach camera controls\r\n                    if (this.detachCameraControls && this._pointerCamera && !this._pointerCamera.leftCamera) {\r\n                        if (this._pointerCamera.inputs && this._pointerCamera.inputs.attachedToElement) {\r\n                            this._pointerCamera.detachControl();\r\n                            this._attachedToElement = true;\r\n                        } else if (!this.allowMultiPointer || this.currentDraggingPointerIds.length === 0) {\r\n                            this._attachedToElement = false;\r\n                        }\r\n                    }\r\n\r\n                    this._targetDragStart(virtualMeshesInfo.pivotMesh.position, virtualMeshesInfo.pivotMesh.rotationQuaternion!, pointerId);\r\n                    this.onDragStartObservable.notifyObservers({ position: virtualMeshesInfo.pivotMesh.position });\r\n                }\r\n            } else if (pointerInfo.type == PointerEventTypes.POINTERUP || pointerInfo.type == PointerEventTypes.POINTERDOUBLETAP) {\r\n                const registeredPointerIndex = this.currentDraggingPointerIds.indexOf(pointerId);\r\n\r\n                // Update state\r\n                virtualMeshesInfo.dragging = false;\r\n\r\n                if (registeredPointerIndex !== -1) {\r\n                    this.currentDraggingPointerIds.splice(registeredPointerIndex, 1);\r\n                    if (this.currentDraggingPointerIds.length === 0) {\r\n                        this._moving = false;\r\n                        this._dragging = this._dragType.NONE;\r\n\r\n                        // Reattach camera controls\r\n                        if (this.detachCameraControls && this._attachedToElement && this._pointerCamera && !this._pointerCamera.leftCamera) {\r\n                            this._reattachCameraControls();\r\n                            this._attachedToElement = false;\r\n                        }\r\n                    }\r\n\r\n                    virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.dragMesh);\r\n                    virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.pivotMesh);\r\n                    this._targetDragEnd(pointerId);\r\n                    this.onDragEndObservable.notifyObservers({});\r\n                }\r\n            } else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {\r\n                const registeredPointerIndex = this.currentDraggingPointerIds.indexOf(pointerId);\r\n\r\n                if (registeredPointerIndex !== -1 && virtualMeshesInfo.dragging && pointerInfo.pickInfo && (pointerInfo.pickInfo.ray || pointerInfo.pickInfo.aimTransform)) {\r\n                    let zDragFactor = this.zDragFactor;\r\n\r\n                    // 2 pointer interaction should not have a z axis drag factor\r\n                    // as well as near interaction\r\n                    if (this.currentDraggingPointerIds.length > 1 || pointerInfo.pickInfo.originMesh) {\r\n                        zDragFactor = 0;\r\n                    }\r\n\r\n                    this._ownerNode.computeWorldMatrix(true);\r\n                    if (!isNearXRPointer) {\r\n                        this._pointerUpdate2D(pointerInfo.pickInfo.ray!, pointerId, zDragFactor);\r\n                    } else {\r\n                        this._pointerUpdateXR(pointerInfo.pickInfo.aimTransform!, pointerInfo.pickInfo.gripTransform, pointerId, zDragFactor);\r\n                    }\r\n\r\n                    // Get change in rotation\r\n                    this._tmpQuaternion.copyFrom(virtualMeshesInfo.startingPivotOrientation);\r\n                    this._tmpQuaternion.x = -this._tmpQuaternion.x;\r\n                    this._tmpQuaternion.y = -this._tmpQuaternion.y;\r\n                    this._tmpQuaternion.z = -this._tmpQuaternion.z;\r\n                    virtualMeshesInfo.pivotMesh.absoluteRotationQuaternion!.multiplyToRef(this._tmpQuaternion, this._tmpQuaternion);\r\n                    virtualMeshesInfo.pivotMesh.absolutePosition.subtractToRef(virtualMeshesInfo.startingPivotPosition, this._tmpVector);\r\n\r\n                    this.onDragObservable.notifyObservers({ delta: this._tmpVector, position: virtualMeshesInfo.pivotMesh.position, pickInfo: pointerInfo.pickInfo });\r\n\r\n                    // Notify herited methods and observables\r\n                    this._targetDrag(this._tmpVector, this._tmpQuaternion, pointerId);\r\n                    virtualMeshesInfo.lastDragPosition.copyFrom(virtualMeshesInfo.dragMesh.absolutePosition);\r\n\r\n                    this._moving = true;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private _applyZOffset(node: TransformNode, localOriginDragDifference: number, zDragFactor: number) {\r\n        // Determine how much the controller moved to/away towards the dragged object and use this to move the object further when its further away\r\n        node.position.z -= node.position.z < 1 ? localOriginDragDifference * zDragFactor : localOriginDragDifference * zDragFactor * node.position.z;\r\n        if (node.position.z < 0) {\r\n            node.position.z = 0;\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _targetDragStart(worldPosition: Vector3, worldRotation: Quaternion, pointerId: number) {\r\n        // Herited classes can override that\r\n    }\r\n\r\n    protected _targetDrag(worldDeltaPosition: Vector3, worldDeltaRotation: Quaternion, pointerId: number) {\r\n        // Herited classes can override that\r\n    }\r\n\r\n    protected _targetDragEnd(pointerId: number) {\r\n        // Herited classes can override that\r\n    }\r\n\r\n    protected _reattachCameraControls() {\r\n        if (this._pointerCamera) {\r\n            // If the camera is an ArcRotateCamera, preserve the settings from the camera\r\n            // when reattaching control\r\n            if (this._pointerCamera.getClassName() === \"ArcRotateCamera\") {\r\n                const arcRotateCamera = this._pointerCamera as ArcRotateCamera;\r\n                arcRotateCamera.attachControl(\r\n                    arcRotateCamera.inputs ? arcRotateCamera.inputs.noPreventDefault : true,\r\n                    arcRotateCamera._useCtrlForPanning,\r\n                    arcRotateCamera._panningMouseButton\r\n                );\r\n            } else {\r\n                // preserve the settings from the camera when reattaching control\r\n                this._pointerCamera.attachControl(this._pointerCamera.inputs ? this._pointerCamera.inputs.noPreventDefault : true);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        if (this._scene) {\r\n            if (this.detachCameraControls && this._attachedToElement && this._pointerCamera && !this._pointerCamera.leftCamera) {\r\n                this._reattachCameraControls();\r\n                this._attachedToElement = false;\r\n            }\r\n            this._scene.onPointerObservable.remove(this._pointerObserver);\r\n        }\r\n\r\n        for (const pointerId in this._virtualMeshesInfo) {\r\n            this._virtualMeshesInfo[pointerId].originMesh.dispose();\r\n            this._virtualMeshesInfo[pointerId].dragMesh.dispose();\r\n        }\r\n\r\n        this.onDragEndObservable.clear();\r\n        this.onDragObservable.clear();\r\n        this.onDragStartObservable.clear();\r\n    }\r\n}\r\n", "import type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Vector3, Quaternion, Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { BaseSixDofDragBehavior } from \"./baseSixDofDragBehavior\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Space } from \"../../Maths/math.axis\";\r\n\r\n/**\r\n * A behavior that when attached to a mesh will allow the mesh to be dragged around based on directions and origin of the pointer's ray\r\n */\r\nexport class SixDofDragBehavior extends BaseSixDofDragBehavior {\r\n    private _sceneRenderObserver: Nullable<Observer<Scene>> = null;\r\n    private _virtualTransformNode: TransformNode;\r\n\r\n    protected _targetPosition = new Vector3(0, 0, 0);\r\n    protected _targetOrientation = new Quaternion();\r\n    protected _targetScaling = new Vector3(1, 1, 1);\r\n    protected _startingPosition = new Vector3(0, 0, 0);\r\n    protected _startingOrientation = new Quaternion();\r\n    protected _startingScaling = new Vector3(1, 1, 1);\r\n\r\n    /**\r\n     * Fires when position is updated\r\n     */\r\n    public onPositionChangedObservable = new Observable<{ position: Vector3 }>();\r\n\r\n    /**\r\n     * The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)\r\n     */\r\n    public dragDeltaRatio = 0.2;\r\n\r\n    /**\r\n     * If the object should rotate to face the drag origin\r\n     */\r\n    public rotateDraggedObject = true;\r\n\r\n    /**\r\n     * If `rotateDraggedObject` is set to `true`, this parameter determines if we are only rotating around the y axis (yaw)\r\n     */\r\n    public rotateAroundYOnly = false;\r\n\r\n    /**\r\n     * Should the behavior rotate 1:1 with the motion controller, when one is used.\r\n     */\r\n    public rotateWithMotionController = true;\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public override get name(): string {\r\n        return \"SixDofDrag\";\r\n    }\r\n\r\n    /**\r\n     * Use this flag to update the target but not move the owner node towards the target\r\n     */\r\n    public disableMovement: boolean = false;\r\n\r\n    /**\r\n     * Should the object rotate towards the camera when we start dragging it\r\n     */\r\n    public faceCameraOnDragStart = false;\r\n\r\n    /**\r\n     * Attaches the six DoF drag behavior\r\n     * In XR mode the mesh and its children will have their isNearGrabbable property set to true\r\n     * @param ownerNode The mesh that will be dragged around once attached\r\n     */\r\n    public override attach(ownerNode: Mesh): void {\r\n        super.attach(ownerNode);\r\n\r\n        ownerNode.isNearGrabbable = true;\r\n        // if it has children, make sure they are grabbable too\r\n        ownerNode.getChildMeshes().forEach((m) => {\r\n            m.isNearGrabbable = true;\r\n        });\r\n\r\n        // Node that will save the owner's transform\r\n        this._virtualTransformNode = new TransformNode(\"virtual_sixDof\", BaseSixDofDragBehavior._virtualScene);\r\n        this._virtualTransformNode.rotationQuaternion = Quaternion.Identity();\r\n\r\n        // On every frame move towards target scaling to avoid jitter caused by vr controllers\r\n        this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(() => {\r\n            if (this.currentDraggingPointerIds.length === 1 && this._moving && !this.disableMovement) {\r\n                // 1 pointer only drags mesh\r\n                const deltaToAdd = TmpVectors.Vector3[0];\r\n                deltaToAdd.copyFrom(this._targetPosition).subtractInPlace(ownerNode.absolutePosition).scaleInPlace(this.dragDeltaRatio);\r\n                const deltaToAddTransformed = TmpVectors.Vector3[1];\r\n                deltaToAddTransformed.copyFrom(deltaToAdd);\r\n                // If the node has a parent, transform the delta to local space, so it can be added to the\r\n                // position in local space\r\n                if (ownerNode.parent) {\r\n                    const parentRotationMatrixInverse = TmpVectors.Matrix[0];\r\n                    (ownerNode.parent as TransformNode).absoluteRotationQuaternion.toRotationMatrix(parentRotationMatrixInverse);\r\n                    parentRotationMatrixInverse.invert();\r\n                    Vector3.TransformNormalToRef(deltaToAdd, parentRotationMatrixInverse, deltaToAddTransformed);\r\n                }\r\n                ownerNode.position.addInPlace(deltaToAddTransformed);\r\n\r\n                this.onPositionChangedObservable.notifyObservers({ position: ownerNode.absolutePosition });\r\n\r\n                // Only rotate the mesh if it's parent has uniform scaling\r\n                if (!ownerNode.parent || ((ownerNode.parent as TransformNode).scaling && !(ownerNode.parent as TransformNode).scaling.isNonUniformWithinEpsilon(0.001))) {\r\n                    const rotationToApply = TmpVectors.Quaternion[0];\r\n                    rotationToApply.copyFrom(this._targetOrientation);\r\n                    if (ownerNode.parent) {\r\n                        const parentRotationInverse = TmpVectors.Quaternion[0];\r\n                        parentRotationInverse.copyFrom((ownerNode.parent as TransformNode).absoluteRotationQuaternion);\r\n                        parentRotationInverse.invertInPlace();\r\n                        parentRotationInverse.multiplyToRef(this._targetOrientation, rotationToApply);\r\n                    }\r\n                    Quaternion.SlerpToRef(ownerNode.rotationQuaternion!, rotationToApply, this.dragDeltaRatio, ownerNode.rotationQuaternion!);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private _getPositionOffsetAround(transformationLocalOrigin: Vector3, scaling: number, rotation: Quaternion): Vector3 {\r\n        const translationMatrix = TmpVectors.Matrix[0]; // T\r\n        const translationMatrixInv = TmpVectors.Matrix[1]; // T'\r\n        const rotationMatrix = TmpVectors.Matrix[2]; // R\r\n        const scaleMatrix = TmpVectors.Matrix[3]; // S\r\n        const finalMatrix = TmpVectors.Matrix[4]; // T' x R x S x T\r\n\r\n        Matrix.TranslationToRef(transformationLocalOrigin.x, transformationLocalOrigin.y, transformationLocalOrigin.z, translationMatrix); // T\r\n        Matrix.TranslationToRef(-transformationLocalOrigin.x, -transformationLocalOrigin.y, -transformationLocalOrigin.z, translationMatrixInv); // T'\r\n        Matrix.FromQuaternionToRef(rotation, rotationMatrix); // R\r\n        Matrix.ScalingToRef(scaling, scaling, scaling, scaleMatrix);\r\n        translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix); // T' x R\r\n        finalMatrix.multiplyToRef(scaleMatrix, finalMatrix); // T' x R x S\r\n        finalMatrix.multiplyToRef(translationMatrix, finalMatrix); // T' x R x S x T\r\n\r\n        return finalMatrix.getTranslation();\r\n    }\r\n\r\n    private _onePointerPositionUpdated(worldDeltaPosition: Vector3, worldDeltaRotation: Quaternion) {\r\n        const pointerDelta = TmpVectors.Vector3[0];\r\n        pointerDelta.setAll(0);\r\n\r\n        if (this._dragging === this._dragType.DRAG) {\r\n            if (this.rotateDraggedObject) {\r\n                if (this.rotateAroundYOnly) {\r\n                    // Convert change in rotation to only y axis rotation\r\n                    Quaternion.RotationYawPitchRollToRef(worldDeltaRotation.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);\r\n                } else {\r\n                    TmpVectors.Quaternion[0].copyFrom(worldDeltaRotation);\r\n                }\r\n                TmpVectors.Quaternion[0].multiplyToRef(this._startingOrientation, this._targetOrientation);\r\n            }\r\n        } else if (this._dragging === this._dragType.NEAR_DRAG || (this._dragging === this._dragType.DRAG_WITH_CONTROLLER && this.rotateWithMotionController)) {\r\n            worldDeltaRotation.multiplyToRef(this._startingOrientation, this._targetOrientation);\r\n        }\r\n\r\n        this._targetPosition.copyFrom(this._startingPosition).addInPlace(worldDeltaPosition);\r\n    }\r\n\r\n    private _twoPointersPositionUpdated() {\r\n        const startingPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].startingPosition;\r\n        const startingPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].startingPosition;\r\n        const startingCenter = TmpVectors.Vector3[0];\r\n        startingPosition0.addToRef(startingPosition1, startingCenter);\r\n        startingCenter.scaleInPlace(0.5);\r\n        const startingVector = TmpVectors.Vector3[1];\r\n        startingPosition1.subtractToRef(startingPosition0, startingVector);\r\n\r\n        const currentPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].dragMesh.absolutePosition;\r\n        const currentPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].dragMesh.absolutePosition;\r\n        const currentCenter = TmpVectors.Vector3[2];\r\n        currentPosition0.addToRef(currentPosition1, currentCenter);\r\n        currentCenter.scaleInPlace(0.5);\r\n        const currentVector = TmpVectors.Vector3[3];\r\n        currentPosition1.subtractToRef(currentPosition0, currentVector);\r\n\r\n        const scaling = currentVector.length() / startingVector.length();\r\n        const translation = currentCenter.subtract(startingCenter);\r\n        const rotationQuaternion = Quaternion.FromEulerAngles(\r\n            0,\r\n            Vector3.GetAngleBetweenVectorsOnPlane(startingVector.normalize(), currentVector.normalize(), Vector3.UpReadOnly),\r\n            0\r\n        );\r\n\r\n        const oldParent = this._ownerNode.parent;\r\n        this._ownerNode.setParent(null);\r\n\r\n        const positionOffset = this._getPositionOffsetAround(startingCenter.subtract(this._virtualTransformNode.getAbsolutePivotPoint()), scaling, rotationQuaternion);\r\n        this._virtualTransformNode.rotationQuaternion!.multiplyToRef(rotationQuaternion, this._ownerNode.rotationQuaternion!);\r\n        this._virtualTransformNode.scaling.scaleToRef(scaling, this._ownerNode.scaling);\r\n        this._virtualTransformNode.position.addToRef(translation.addInPlace(positionOffset), this._ownerNode.position);\r\n        this.onPositionChangedObservable.notifyObservers({ position: this._ownerNode.position });\r\n\r\n        this._ownerNode.setParent(oldParent);\r\n    }\r\n\r\n    protected override _targetDragStart() {\r\n        const pointerCount = this.currentDraggingPointerIds.length;\r\n\r\n        if (!this._ownerNode.rotationQuaternion) {\r\n            this._ownerNode.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._ownerNode.rotation.y, this._ownerNode.rotation.x, this._ownerNode.rotation.z);\r\n        }\r\n        const worldPivot = this._ownerNode.getAbsolutePivotPoint();\r\n\r\n        if (pointerCount === 1) {\r\n            this._targetPosition.copyFrom(this._ownerNode.absolutePosition);\r\n            this._targetOrientation.copyFrom(this._ownerNode.rotationQuaternion);\r\n            this._targetScaling.copyFrom(this._ownerNode.absoluteScaling);\r\n\r\n            if (this.faceCameraOnDragStart && this._scene.activeCamera) {\r\n                const toCamera = TmpVectors.Vector3[0];\r\n                this._scene.activeCamera.position.subtractToRef(worldPivot, toCamera);\r\n                toCamera.normalize();\r\n                const quat = TmpVectors.Quaternion[0];\r\n                if (this._scene.useRightHandedSystem) {\r\n                    Quaternion.FromLookDirectionRHToRef(toCamera, new Vector3(0, 1, 0), quat);\r\n                } else {\r\n                    Quaternion.FromLookDirectionLHToRef(toCamera, new Vector3(0, 1, 0), quat);\r\n                }\r\n                quat.normalize();\r\n                Quaternion.RotationYawPitchRollToRef(quat.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);\r\n                this._targetOrientation.copyFrom(TmpVectors.Quaternion[0]);\r\n            }\r\n            this._startingPosition.copyFrom(this._targetPosition);\r\n            this._startingOrientation.copyFrom(this._targetOrientation);\r\n            this._startingScaling.copyFrom(this._targetScaling);\r\n        } else if (pointerCount === 2) {\r\n            this._virtualTransformNode.setPivotPoint(new Vector3(0, 0, 0), Space.LOCAL);\r\n            this._virtualTransformNode.position.copyFrom(this._ownerNode.absolutePosition);\r\n            this._virtualTransformNode.scaling.copyFrom(this._ownerNode.absoluteScaling);\r\n            this._virtualTransformNode.rotationQuaternion!.copyFrom(this._ownerNode.absoluteRotationQuaternion);\r\n            this._virtualTransformNode.setPivotPoint(worldPivot, Space.WORLD);\r\n            this._resetVirtualMeshesPosition();\r\n        }\r\n    }\r\n\r\n    protected override _targetDrag(worldDeltaPosition: Vector3, worldDeltaRotation: Quaternion) {\r\n        if (this.currentDraggingPointerIds.length === 1) {\r\n            this._onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation);\r\n        } else if (this.currentDraggingPointerIds.length === 2) {\r\n            this._twoPointersPositionUpdated();\r\n        }\r\n    }\r\n\r\n    protected override _targetDragEnd() {\r\n        if (this.currentDraggingPointerIds.length === 1) {\r\n            // We still have 1 active pointer, we must simulate a dragstart with a reseted position/orientation\r\n            this._resetVirtualMeshesPosition();\r\n            const previousFaceCameraFlag = this.faceCameraOnDragStart;\r\n            this.faceCameraOnDragStart = false;\r\n            this._targetDragStart();\r\n            this.faceCameraOnDragStart = previousFaceCameraFlag;\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    public override detach(): void {\r\n        super.detach();\r\n\r\n        if (this._ownerNode) {\r\n            this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);\r\n        }\r\n\r\n        if (this._virtualTransformNode) {\r\n            this._virtualTransformNode.dispose();\r\n        }\r\n    }\r\n}\r\n", "import type { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Behavior } from \"../behavior\";\r\n\r\n/**\r\n * A behavior that allows a transform node to stick to a surface position/orientation\r\n * @since 5.0.0\r\n */\r\nexport class SurfaceMagnetismBehavior implements Behavior<Mesh> {\r\n    private _scene: Scene;\r\n    private _attachedMesh: Nullable<Mesh>;\r\n    private _attachPointLocalOffset: Vector3 = new Vector3();\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>>;\r\n    private _workingPosition: Vector3 = new Vector3();\r\n    private _workingQuaternion: Quaternion = new Quaternion();\r\n    private _lastTick: number = -1;\r\n    private _onBeforeRender: Nullable<Observer<Scene>>;\r\n    private _hit = false;\r\n\r\n    /**\r\n     * Distance offset from the hit point to place the target at, along the hit normal.\r\n     */\r\n    public hitNormalOffset: number = 0.05;\r\n\r\n    /**\r\n     * Name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"SurfaceMagnetism\";\r\n    }\r\n\r\n    /**\r\n     * Spatial mapping meshes to collide with\r\n     */\r\n    public meshes: AbstractMesh[] = [];\r\n\r\n    /**\r\n     * Function called when the behavior needs to be initialized (after attaching it to a target)\r\n     */\r\n    public init(): void {}\r\n\r\n    /**\r\n     * Set to false if the node should strictly follow the camera without any interpolation time\r\n     */\r\n    public interpolatePose = true;\r\n\r\n    /**\r\n     * Rate of interpolation of position and rotation of the attached node.\r\n     * Higher values will give a slower interpolation.\r\n     */\r\n    public lerpTime = 250;\r\n\r\n    /**\r\n     * If true, pitch and roll are omitted.\r\n     */\r\n    public keepOrientationVertical = true;\r\n\r\n    /**\r\n     * Is this behavior reacting to pointer events\r\n     */\r\n    public enabled = true;\r\n\r\n    /**\r\n     * Maximum distance for the node to stick to the surface\r\n     */\r\n    public maxStickingDistance = 0.8;\r\n\r\n    /**\r\n     * Attaches the behavior to a transform node\r\n     * @param target defines the target where the behavior is attached to\r\n     * @param scene the scene\r\n     */\r\n    public attach(target: Mesh, scene?: Scene): void {\r\n        this._attachedMesh = target;\r\n        this._scene = scene || target.getScene();\r\n        if (!this._attachedMesh.rotationQuaternion) {\r\n            this._attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._attachedMesh.rotation.y, this._attachedMesh.rotation.x, this._attachedMesh.rotation.z);\r\n        }\r\n        this.updateAttachPoint();\r\n\r\n        this._workingPosition.copyFrom(this._attachedMesh.position);\r\n        this._workingQuaternion.copyFrom(this._attachedMesh.rotationQuaternion);\r\n        this._addObservables();\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior\r\n     */\r\n    public detach(): void {\r\n        this._attachedMesh = null;\r\n        this._removeObservables();\r\n    }\r\n\r\n    private _getTargetPose(pickingInfo: PickingInfo): Nullable<{ position: Vector3; quaternion: Quaternion }> {\r\n        if (!this._attachedMesh) {\r\n            return null;\r\n        }\r\n\r\n        if (pickingInfo && pickingInfo.hit) {\r\n            const pickedNormal = pickingInfo.getNormal(true, true);\r\n            const pickedPoint = pickingInfo.pickedPoint;\r\n\r\n            if (!pickedNormal || !pickedPoint) {\r\n                return null;\r\n            }\r\n            pickedNormal.normalize();\r\n\r\n            const worldTarget = TmpVectors.Vector3[0];\r\n            worldTarget.copyFrom(pickedNormal);\r\n            worldTarget.scaleInPlace(this.hitNormalOffset);\r\n            worldTarget.addInPlace(pickedPoint);\r\n\r\n            if (this._attachedMesh.parent) {\r\n                TmpVectors.Matrix[0].copyFrom(this._attachedMesh.parent.getWorldMatrix()).invert();\r\n                Vector3.TransformNormalToRef(worldTarget, TmpVectors.Matrix[0], worldTarget);\r\n            }\r\n\r\n            return {\r\n                position: worldTarget,\r\n                quaternion: Quaternion.RotationYawPitchRoll(\r\n                    -Math.atan2(pickedNormal.x, -pickedNormal.z),\r\n                    this.keepOrientationVertical ? 0 : Math.atan2(pickedNormal.y, Math.sqrt(pickedNormal.z * pickedNormal.z + pickedNormal.x * pickedNormal.x)),\r\n                    0\r\n                ),\r\n            };\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Updates the attach point with the current geometry extents of the attached mesh\r\n     */\r\n    public updateAttachPoint() {\r\n        this._getAttachPointOffsetToRef(this._attachPointLocalOffset);\r\n    }\r\n\r\n    /**\r\n     * Finds the intersection point of the given ray onto the meshes and updates the target.\r\n     * Transformation will be interpolated according to `interpolatePose` and `lerpTime` properties.\r\n     * If no mesh of `meshes` are hit, this does nothing.\r\n     * @param pickInfo The input pickingInfo that will be used to intersect the meshes\r\n     * @returns a boolean indicating if we found a hit to stick to\r\n     */\r\n    public findAndUpdateTarget(pickInfo: PickingInfo): boolean {\r\n        this._hit = false;\r\n        if (!pickInfo.ray) {\r\n            return false;\r\n        }\r\n\r\n        const subPicking = pickInfo.ray.intersectsMeshes(this.meshes)[0];\r\n\r\n        if (this._attachedMesh && subPicking && subPicking.hit && subPicking.pickedMesh) {\r\n            const pose = this._getTargetPose(subPicking);\r\n            if (pose && Vector3.Distance(this._attachedMesh.position, pose.position) < this.maxStickingDistance) {\r\n                this._workingPosition.copyFrom(pose.position);\r\n                this._workingQuaternion.copyFrom(pose.quaternion);\r\n                this._hit = true;\r\n            }\r\n        }\r\n\r\n        return this._hit;\r\n    }\r\n\r\n    private _getAttachPointOffsetToRef(ref: Vector3) {\r\n        if (!this._attachedMesh) {\r\n            ref.setAll(0);\r\n            return;\r\n        }\r\n\r\n        const storedQuat = TmpVectors.Quaternion[0];\r\n        storedQuat.copyFrom(this._attachedMesh.rotationQuaternion!);\r\n        this._attachedMesh.rotationQuaternion!.copyFromFloats(0, 0, 0, 1);\r\n        this._attachedMesh.computeWorldMatrix();\r\n        const boundingMinMax = this._attachedMesh.getHierarchyBoundingVectors();\r\n        const center = TmpVectors.Vector3[0];\r\n        boundingMinMax.max.addToRef(boundingMinMax.min, center);\r\n        center.scaleInPlace(0.5);\r\n        center.z = boundingMinMax.max.z;\r\n        // We max the z coordinate because we want the attach point to be on the back of the mesh\r\n        const invWorld = TmpVectors.Matrix[0];\r\n        this._attachedMesh.getWorldMatrix().invertToRef(invWorld);\r\n        Vector3.TransformCoordinatesToRef(center, invWorld, ref);\r\n        this._attachedMesh.rotationQuaternion!.copyFrom(storedQuat);\r\n    }\r\n\r\n    private _updateTransformToGoal(elapsed: number) {\r\n        if (!this._attachedMesh || !this._hit) {\r\n            return;\r\n        }\r\n\r\n        const oldParent = this._attachedMesh.parent;\r\n        this._attachedMesh.setParent(null);\r\n\r\n        const worldOffset = TmpVectors.Vector3[0];\r\n        Vector3.TransformNormalToRef(this._attachPointLocalOffset, this._attachedMesh.getWorldMatrix(), worldOffset);\r\n\r\n        if (!this.interpolatePose) {\r\n            this._attachedMesh.position.copyFrom(this._workingPosition).subtractInPlace(worldOffset);\r\n            this._attachedMesh.rotationQuaternion!.copyFrom(this._workingQuaternion);\r\n            return;\r\n        }\r\n\r\n        // position\r\n        const interpolatedPosition = new Vector3();\r\n        Vector3.SmoothToRef(this._attachedMesh.position, this._workingPosition, elapsed, this.lerpTime, interpolatedPosition);\r\n        this._attachedMesh.position.copyFrom(interpolatedPosition);\r\n\r\n        // rotation\r\n        const currentRotation = new Quaternion();\r\n        currentRotation.copyFrom(this._attachedMesh.rotationQuaternion!);\r\n        Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this._attachedMesh.rotationQuaternion!);\r\n\r\n        this._attachedMesh.setParent(oldParent);\r\n    }\r\n\r\n    private _addObservables() {\r\n        this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {\r\n            if (this.enabled && pointerInfo.type == PointerEventTypes.POINTERMOVE && pointerInfo.pickInfo) {\r\n                this.findAndUpdateTarget(pointerInfo.pickInfo);\r\n            }\r\n        });\r\n\r\n        this._lastTick = Date.now();\r\n        this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {\r\n            const tick = Date.now();\r\n            this._updateTransformToGoal(tick - this._lastTick);\r\n            this._lastTick = tick;\r\n        });\r\n    }\r\n\r\n    private _removeObservables() {\r\n        this._scene.onPointerObservable.remove(this._pointerObserver);\r\n        this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);\r\n        this._pointerObserver = null;\r\n        this._onBeforeRender = null;\r\n    }\r\n}\r\n", "import type { IDisposable } from \"../scene\";\r\nimport { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { PointerInfoPre } from \"../Events/pointerEvents\";\r\nimport { PointerInfo, PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { HemisphericLight } from \"../Lights/hemisphericLight\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { IPointerEvent } from \"../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Renders a layer on top of an existing scene\r\n */\r\nexport class UtilityLayerRenderer implements IDisposable {\r\n    private _pointerCaptures: { [pointerId: number]: boolean } = {};\r\n    private _lastPointerEvents: { [pointerId: number]: boolean } = {};\r\n    /** @internal */\r\n    public static _DefaultUtilityLayer: Nullable<UtilityLayerRenderer> = null;\r\n    /** @internal */\r\n    public static _DefaultKeepDepthUtilityLayer: Nullable<UtilityLayerRenderer> = null;\r\n    private _sharedGizmoLight: Nullable<HemisphericLight> = null;\r\n\r\n    private _renderCamera: Nullable<Camera> = null;\r\n\r\n    /**\r\n     * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)\r\n     * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned\r\n     * @returns the camera that is used when rendering the utility layer\r\n     */\r\n    public getRenderCamera(getRigParentIfPossible?: boolean) {\r\n        if (this._renderCamera) {\r\n            return this._renderCamera;\r\n        } else {\r\n            let activeCam: Camera;\r\n            if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {\r\n                activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];\r\n            } else {\r\n                activeCam = <Camera>this.originalScene.activeCamera!;\r\n            }\r\n\r\n            if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {\r\n                return activeCam.rigParent!;\r\n            }\r\n            return activeCam;\r\n        }\r\n    }\r\n    /**\r\n     * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)\r\n     * @param cam the camera that should be used when rendering the utility layer\r\n     */\r\n    public setRenderCamera(cam: Nullable<Camera>) {\r\n        this._renderCamera = cam;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Light which used by gizmos to get light shading\r\n     */\r\n    public _getSharedGizmoLight(): HemisphericLight {\r\n        if (!this._sharedGizmoLight) {\r\n            this._sharedGizmoLight = new HemisphericLight(\"shared gizmo light\", new Vector3(0, 1, 0), this.utilityLayerScene);\r\n            this._sharedGizmoLight.intensity = 2;\r\n            this._sharedGizmoLight.groundColor = Color3.Gray();\r\n        }\r\n        return this._sharedGizmoLight;\r\n    }\r\n\r\n    /**\r\n     * If the picking should be done on the utility layer prior to the actual scene (Default: true)\r\n     */\r\n    public pickUtilitySceneFirst = true;\r\n    /**\r\n     * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)\r\n     */\r\n    public static get DefaultUtilityLayer(): UtilityLayerRenderer {\r\n        if (UtilityLayerRenderer._DefaultUtilityLayer == null) {\r\n            return UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(EngineStore.LastCreatedScene!);\r\n        }\r\n\r\n        return UtilityLayerRenderer._DefaultUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * Creates an utility layer, and set it as a default utility layer\r\n     * @param scene associated scene\r\n     * @internal\r\n     */\r\n    public static _CreateDefaultUtilityLayerFromScene(scene: Scene): UtilityLayerRenderer {\r\n        UtilityLayerRenderer._DefaultUtilityLayer = new UtilityLayerRenderer(scene);\r\n        UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\r\n            UtilityLayerRenderer._DefaultUtilityLayer = null;\r\n        });\r\n\r\n        return UtilityLayerRenderer._DefaultUtilityLayer;\r\n    }\r\n    /**\r\n     * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)\r\n     */\r\n    public static get DefaultKeepDepthUtilityLayer(): UtilityLayerRenderer {\r\n        if (UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene!);\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\r\n                UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\r\n            });\r\n        }\r\n        return UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * The scene that is rendered on top of the original scene\r\n     */\r\n    public utilityLayerScene: Scene;\r\n\r\n    /**\r\n     *  If the utility layer should automatically be rendered on top of existing scene\r\n     */\r\n    public shouldRender: boolean = true;\r\n    /**\r\n     * If set to true, only pointer down onPointerObservable events will be blocked when picking is occluded by original scene\r\n     */\r\n    public onlyCheckPointerDownEvents = true;\r\n\r\n    /**\r\n     * If set to false, only pointerUp, pointerDown and pointerMove will be sent to the utilityLayerScene (false by default)\r\n     */\r\n    public processAllEvents = false;\r\n\r\n    /**\r\n     * Set to false to disable picking\r\n     */\r\n    public pickingEnabled = true;\r\n\r\n    /**\r\n     * Observable raised when the pointer moves from the utility layer scene to the main scene\r\n     */\r\n    public onPointerOutObservable = new Observable<number>();\r\n\r\n    /** Gets or sets a predicate that will be used to indicate utility meshes present in the main scene */\r\n    public mainSceneTrackerPredicate: (mesh: Nullable<AbstractMesh>) => boolean;\r\n\r\n    private _afterRenderObserver: Nullable<Observer<Camera>>;\r\n    private _sceneDisposeObserver: Nullable<Observer<Scene>>;\r\n    private _originalPointerObserver: Nullable<Observer<PointerInfoPre>>;\r\n    /**\r\n     * Instantiates a UtilityLayerRenderer\r\n     * @param originalScene the original scene that will be rendered on top of\r\n     * @param handleEvents boolean indicating if the utility layer should handle events\r\n     * @param manualRender boolean indicating if the utility layer should render manually.\r\n     */\r\n    constructor(\r\n        /** the original scene that will be rendered on top of */\r\n        public originalScene: Scene,\r\n        public readonly handleEvents: boolean = true,\r\n        manualRender = false\r\n    ) {\r\n        // Create scene which will be rendered in the foreground and remove it from being referenced by engine to avoid interfering with existing app\r\n        this.utilityLayerScene = new Scene(originalScene.getEngine(), { virtual: true });\r\n        this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;\r\n        this.utilityLayerScene._allowPostProcessClearColor = false;\r\n\r\n        // Deactivate post processes\r\n        this.utilityLayerScene.postProcessesEnabled = false;\r\n\r\n        // Detach controls on utility scene, events will be fired by logic below to handle picking priority\r\n        this.utilityLayerScene.detachControl();\r\n\r\n        if (handleEvents) {\r\n            this._originalPointerObserver = originalScene.onPrePointerObservable.add((prePointerInfo) => {\r\n                if (!this.utilityLayerScene.activeCamera) {\r\n                    return;\r\n                }\r\n                if (!this.pickingEnabled) {\r\n                    return;\r\n                }\r\n\r\n                if (!this.processAllEvents) {\r\n                    if (\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERMOVE &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERUP &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERDOWN &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP\r\n                    ) {\r\n                        return;\r\n                    }\r\n                }\r\n                this.utilityLayerScene.pointerX = originalScene.pointerX;\r\n                this.utilityLayerScene.pointerY = originalScene.pointerY;\r\n                const pointerEvent = <IPointerEvent>prePointerInfo.event;\r\n                if (originalScene!.isPointerCaptured(pointerEvent.pointerId)) {\r\n                    this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                    return;\r\n                }\r\n\r\n                const getNearPickDataForScene = (scene: Scene) => {\r\n                    let scenePick = null;\r\n\r\n                    if (prePointerInfo.nearInteractionPickingInfo) {\r\n                        if (prePointerInfo.nearInteractionPickingInfo.pickedMesh!.getScene() == scene) {\r\n                            scenePick = prePointerInfo.nearInteractionPickingInfo;\r\n                        } else {\r\n                            scenePick = new PickingInfo();\r\n                        }\r\n                    } else if (scene !== this.utilityLayerScene && prePointerInfo.originalPickingInfo) {\r\n                        scenePick = prePointerInfo.originalPickingInfo;\r\n                    } else {\r\n                        let previousActiveCamera: Nullable<Camera> = null;\r\n                        // If a camera is set for rendering with this layer\r\n                        // it will also be used for the ray computation\r\n                        // To preserve back compat and because scene.pick always use activeCamera\r\n                        // it's substituted temporarily and a new scenePick is forced.\r\n                        // otherwise, the ray with previously active camera is always used.\r\n                        // It's set back to previous activeCamera after operation.\r\n                        if (this._renderCamera) {\r\n                            previousActiveCamera = scene._activeCamera;\r\n                            scene._activeCamera = this._renderCamera;\r\n                            prePointerInfo.ray = null;\r\n                        }\r\n                        scenePick = prePointerInfo.ray ? scene.pickWithRay(prePointerInfo.ray) : scene.pick(originalScene.pointerX, originalScene.pointerY);\r\n                        if (previousActiveCamera) {\r\n                            scene._activeCamera = previousActiveCamera;\r\n                        }\r\n                    }\r\n\r\n                    return scenePick;\r\n                };\r\n\r\n                const utilityScenePick = getNearPickDataForScene(this.utilityLayerScene);\r\n\r\n                if (!prePointerInfo.ray && utilityScenePick) {\r\n                    prePointerInfo.ray = utilityScenePick.ray;\r\n                }\r\n\r\n                if (prePointerInfo.originalPickingInfo?.aimTransform && utilityScenePick) {\r\n                    utilityScenePick.aimTransform = prePointerInfo.originalPickingInfo.aimTransform;\r\n                    utilityScenePick.gripTransform = prePointerInfo.originalPickingInfo.gripTransform;\r\n                }\r\n\r\n                // always fire the prepointer observable\r\n                this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo);\r\n\r\n                // allow every non pointer down event to flow to the utility layer\r\n                if (this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {\r\n                    if (!prePointerInfo.skipOnPointerObservable) {\r\n                        this.utilityLayerScene.onPointerObservable.notifyObservers(\r\n                            new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick),\r\n                            prePointerInfo.type\r\n                        );\r\n                    }\r\n                    if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\r\n                        this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                if (this.utilityLayerScene.autoClearDepthAndStencil || this.pickUtilitySceneFirst) {\r\n                    // If this layer is an overlay, check if this layer was hit and if so, skip pointer events for the main scene\r\n                    if (utilityScenePick && utilityScenePick.hit) {\r\n                        if (!prePointerInfo.skipOnPointerObservable) {\r\n                            this.utilityLayerScene.onPointerObservable.notifyObservers(\r\n                                new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick),\r\n                                prePointerInfo.type\r\n                            );\r\n                        }\r\n                        prePointerInfo.skipOnPointerObservable = true;\r\n                    }\r\n                } else {\r\n                    const originalScenePick = getNearPickDataForScene(originalScene);\r\n                    const pointerEvent = <IPointerEvent>prePointerInfo.event;\r\n\r\n                    // If the layer can be occluded by the original scene, only fire pointer events to the first layer that hit they ray\r\n                    if (originalScenePick && utilityScenePick) {\r\n                        // No pick in utility scene\r\n                        if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {\r\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\r\n                                // We touched an utility mesh present in the main scene\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                                prePointerInfo.skipOnPointerObservable = true;\r\n                            } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                                this._pointerCaptures[pointerEvent.pointerId] = true;\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                            } else if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                                if (this._lastPointerEvents[pointerEvent.pointerId]) {\r\n                                    // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\r\n                                    this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\r\n                                    delete this._lastPointerEvents[pointerEvent.pointerId];\r\n                                }\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                            }\r\n                        } else if (!this._pointerCaptures[pointerEvent.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {\r\n                            // We pick something in utility scene or the pick in utility is closer than the one in main scene\r\n                            this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\r\n                            // If a previous utility layer set this, do not unset this\r\n                            if (!prePointerInfo.skipOnPointerObservable) {\r\n                                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;\r\n                            }\r\n                        } else if (!this._pointerCaptures[pointerEvent.pointerId] && utilityScenePick.distance >= originalScenePick.distance) {\r\n                            // We have a pick in both scenes but main is closer than utility\r\n\r\n                            // We touched an utility mesh present in the main scene\r\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                                prePointerInfo.skipOnPointerObservable = true;\r\n                            } else {\r\n                                if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                                    if (this._lastPointerEvents[pointerEvent.pointerId]) {\r\n                                        // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\r\n                                        this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\r\n                                        delete this._lastPointerEvents[pointerEvent.pointerId];\r\n                                    }\r\n                                }\r\n                                this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\r\n                            }\r\n                        }\r\n\r\n                        if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\r\n                            this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n            // As a newly added utility layer will be rendered over the screen last, it's pointer events should be processed first\r\n            if (this._originalPointerObserver) {\r\n                originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);\r\n            }\r\n        }\r\n\r\n        // Render directly on top of existing scene without clearing\r\n        this.utilityLayerScene.autoClear = false;\r\n\r\n        if (!manualRender) {\r\n            this._afterRenderObserver = this.originalScene.onAfterRenderCameraObservable.add((camera) => {\r\n                // Only render when the render camera finishes rendering\r\n                if (this.shouldRender && camera == this.getRenderCamera()) {\r\n                    this.render();\r\n                }\r\n            });\r\n        }\r\n\r\n        this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        this._updateCamera();\r\n    }\r\n\r\n    private _notifyObservers(prePointerInfo: PointerInfoPre, pickInfo: PickingInfo, pointerEvent: IPointerEvent) {\r\n        if (!prePointerInfo.skipOnPointerObservable) {\r\n            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);\r\n            this._lastPointerEvents[pointerEvent.pointerId] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders the utility layers scene on top of the original scene\r\n     */\r\n    public render() {\r\n        this._updateCamera();\r\n        if (this.utilityLayerScene.activeCamera) {\r\n            // Set the camera's scene to utility layers scene\r\n            const oldScene = this.utilityLayerScene.activeCamera.getScene();\r\n            const camera = this.utilityLayerScene.activeCamera;\r\n            camera._scene = this.utilityLayerScene;\r\n            if (camera.leftCamera) {\r\n                camera.leftCamera._scene = this.utilityLayerScene;\r\n            }\r\n            if (camera.rightCamera) {\r\n                camera.rightCamera._scene = this.utilityLayerScene;\r\n            }\r\n\r\n            this.utilityLayerScene.render(false);\r\n\r\n            // Reset camera's scene back to original\r\n            camera._scene = oldScene;\r\n            if (camera.leftCamera) {\r\n                camera.leftCamera._scene = oldScene;\r\n            }\r\n            if (camera.rightCamera) {\r\n                camera.rightCamera._scene = oldScene;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the renderer\r\n     */\r\n    public dispose() {\r\n        this.onPointerOutObservable.clear();\r\n\r\n        if (this._afterRenderObserver) {\r\n            this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);\r\n        }\r\n        if (this._sceneDisposeObserver) {\r\n            this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);\r\n        }\r\n        if (this._originalPointerObserver) {\r\n            this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);\r\n        }\r\n        this.utilityLayerScene.dispose();\r\n    }\r\n\r\n    private _updateCamera() {\r\n        this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();\r\n        this.utilityLayerScene.activeCamera = this.getRenderCamera();\r\n    }\r\n}\r\n", "import type { Observer } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { Quaternion, Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport type { TargetCamera } from \"../Cameras/targetCamera\";\r\nimport type { Node } from \"../node\";\r\nimport type { Bone } from \"../Bones/bone\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport type { LinesMesh } from \"../Meshes/linesMesh\";\r\nimport type { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\r\nimport type { ShadowLight } from \"../Lights/shadowLight\";\r\nimport { Light } from \"../Lights/light\";\r\n\r\n/**\r\n * Cache built by each axis. Used for managing state between all elements of gizmo for enhanced UI\r\n */\r\nexport interface GizmoAxisCache {\r\n    /** Mesh used to render the Gizmo */\r\n    gizmoMeshes: Mesh[];\r\n    /** Mesh used to detect user interaction with Gizmo */\r\n    colliderMeshes: Mesh[];\r\n    /** Material used to indicate color of gizmo mesh */\r\n    material: StandardMaterial;\r\n    /** Material used to indicate hover state of the Gizmo */\r\n    hoverMaterial: StandardMaterial;\r\n    /** Material used to indicate disabled state of the Gizmo */\r\n    disableMaterial: StandardMaterial;\r\n    /** Used to indicate Active state of the Gizmo */\r\n    active: boolean;\r\n    /** DragBehavior */\r\n    dragBehavior: PointerDragBehavior;\r\n}\r\n\r\n/**\r\n * Anchor options where the Gizmo can be positioned in relation to its anchored node\r\n */\r\nexport const enum GizmoAnchorPoint {\r\n    /** The origin of the attached node */\r\n    Origin,\r\n    /** The pivot point of the attached node*/\r\n    Pivot,\r\n}\r\n\r\n/**\r\n * Coordinates mode: Local or World. Defines how axis is aligned: either on world axis or transform local axis\r\n */\r\nexport const enum GizmoCoordinatesMode {\r\n    World,\r\n    Local,\r\n}\r\n\r\n/**\r\n * Interface for basic gizmo\r\n */\r\nexport interface IGizmo extends IDisposable {\r\n    /** True when the mouse pointer is hovered a gizmo mesh */\r\n    readonly isHovered: boolean;\r\n    /** The root mesh of the gizmo */\r\n    _rootMesh: Mesh;\r\n    /** Ratio for the scale of the gizmo */\r\n    scaleRatio: number;\r\n    /**\r\n     * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    attachedMesh: Nullable<AbstractMesh>;\r\n    /**\r\n     * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    attachedNode: Nullable<Node>;\r\n    /**\r\n     * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\r\n     */\r\n    updateGizmoRotationToMatchAttachedMesh: boolean;\r\n    /** The utility layer the gizmo will be added to */\r\n    gizmoLayer: UtilityLayerRenderer;\r\n    /**\r\n     * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)\r\n     */\r\n    updateGizmoPositionToMatchAttachedMesh: boolean;\r\n    /**\r\n     * Defines where the gizmo will be positioned if `updateGizmoPositionToMatchAttachedMesh` is enabled.\r\n     * (Default: GizmoAnchorPoint.Origin)\r\n     */\r\n    anchorPoint: GizmoAnchorPoint;\r\n\r\n    /**\r\n     * Set the coordinate mode to use. By default it's local.\r\n     */\r\n    coordinatesMode: GizmoCoordinatesMode;\r\n\r\n    /**\r\n     * When set, the gizmo will always appear the same size no matter where the camera is (default: true)\r\n     */\r\n    updateScale: boolean;\r\n    /**\r\n     * posture that the gizmo will be display\r\n     * When set null, default value will be used (Quaternion(0, 0, 0, 1))\r\n     */\r\n    customRotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * Disposes and replaces the current meshes in the gizmo with the specified mesh\r\n     * @param mesh The mesh to replace the default mesh of the gizmo\r\n     */\r\n    setCustomMesh(mesh: Mesh): void;\r\n\r\n    /**\r\n     * Additional transform applied to the gizmo.\r\n     * It's useful when the gizmo is attached to a bone: if the bone is part of a skeleton attached to a mesh, you should define the mesh as additionalTransformNode if you want the gizmo to be displayed at the bone's correct location.\r\n     * Otherwise, as the gizmo is relative to the skeleton root, the mesh transformation will not be taken into account.\r\n     */\r\n    additionalTransformNode?: TransformNode | undefined;\r\n}\r\n/**\r\n * Renders gizmos on top of an existing scene which provide controls for position, rotation, etc.\r\n */\r\nexport class Gizmo implements IGizmo {\r\n    /**\r\n     * The root mesh of the gizmo\r\n     */\r\n    public _rootMesh: Mesh;\r\n    protected _attachedMesh: Nullable<AbstractMesh> = null;\r\n    protected _attachedNode: Nullable<Node> = null;\r\n    protected _customRotationQuaternion: Nullable<Quaternion> = null;\r\n    protected _additionalTransformNode?: TransformNode;\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    protected _scaleRatio = 1;\r\n\r\n    /**\r\n     * boolean updated by pointermove when a gizmo mesh is hovered\r\n     */\r\n    protected _isHovered = false;\r\n\r\n    /**\r\n     * When enabled, any gizmo operation will perserve scaling sign. Default is off.\r\n     * Only valid for TransformNode derived classes (Mesh, AbstractMesh, ...)\r\n     */\r\n    public static PreserveScaling = false;\r\n\r\n    /**\r\n     * There are 2 ways to preserve scaling: using mesh scaling or absolute scaling. Depending of hierarchy, non uniform scaling and LH or RH coordinates. One is preferable than the other.\r\n     * If the scaling to be preserved is the local scaling, then set this value to false.\r\n     * Default is true which means scaling to be preserved is absolute one (with hierarchy applied)\r\n     */\r\n    public static UseAbsoluteScaling = true;\r\n\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    public set scaleRatio(value: number) {\r\n        this._scaleRatio = value;\r\n    }\r\n\r\n    public get scaleRatio() {\r\n        return this._scaleRatio;\r\n    }\r\n\r\n    /**\r\n     * True when the mouse pointer is hovered a gizmo mesh\r\n     */\r\n    public get isHovered() {\r\n        return this._isHovered;\r\n    }\r\n\r\n    /**\r\n     * If a custom mesh has been set (Default: false)\r\n     */\r\n    protected _customMeshSet = false;\r\n    /**\r\n     * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    public get attachedMesh() {\r\n        return this._attachedMesh;\r\n    }\r\n    public set attachedMesh(value) {\r\n        this._attachedMesh = value;\r\n        if (value) {\r\n            this._attachedNode = value;\r\n        }\r\n        this._rootMesh.setEnabled(value ? true : false);\r\n        this._attachedNodeChanged(value);\r\n    }\r\n    /**\r\n     * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    public get attachedNode() {\r\n        return this._attachedNode;\r\n    }\r\n    public set attachedNode(value) {\r\n        this._attachedNode = value;\r\n        this._attachedMesh = null;\r\n        this._rootMesh.setEnabled(value ? true : false);\r\n        this._attachedNodeChanged(value);\r\n    }\r\n\r\n    /**\r\n     * Disposes and replaces the current meshes in the gizmo with the specified mesh\r\n     * @param mesh The mesh to replace the default mesh of the gizmo\r\n     */\r\n    public setCustomMesh(mesh: Mesh) {\r\n        if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)\";\r\n        }\r\n        this._rootMesh.getChildMeshes().forEach((c) => {\r\n            c.dispose();\r\n        });\r\n        mesh.parent = this._rootMesh;\r\n        this._customMeshSet = true;\r\n    }\r\n\r\n    /**\r\n     * Additional transform applied to the gizmo.\r\n     * It's useful when the gizmo is attached to a bone: if the bone is part of a skeleton attached to a mesh, you should define the mesh as additionalTransformNode if you want the gizmo to be displayed at the bone's correct location.\r\n     * Otherwise, as the gizmo is relative to the skeleton root, the mesh transformation will not be taken into account.\r\n     */\r\n    public get additionalTransformNode() {\r\n        return this._additionalTransformNode;\r\n    }\r\n\r\n    public set additionalTransformNode(value: TransformNode | undefined) {\r\n        this._additionalTransformNode = value;\r\n    }\r\n\r\n    protected _updateGizmoRotationToMatchAttachedMesh = true;\r\n    protected _updateGizmoPositionToMatchAttachedMesh = true;\r\n    protected _anchorPoint = GizmoAnchorPoint.Origin;\r\n    protected _updateScale = true;\r\n    protected _coordinatesMode = GizmoCoordinatesMode.Local;\r\n\r\n    /**\r\n     * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\r\n     * NOTE: This is only possible for meshes with uniform scaling, as otherwise it's not possible to decompose the rotation\r\n     */\r\n    public set updateGizmoRotationToMatchAttachedMesh(value: boolean) {\r\n        this._updateGizmoRotationToMatchAttachedMesh = value;\r\n    }\r\n    public get updateGizmoRotationToMatchAttachedMesh() {\r\n        return this._updateGizmoRotationToMatchAttachedMesh;\r\n    }\r\n    /**\r\n     * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)\r\n     */\r\n    public set updateGizmoPositionToMatchAttachedMesh(value: boolean) {\r\n        this._updateGizmoPositionToMatchAttachedMesh = value;\r\n    }\r\n    public get updateGizmoPositionToMatchAttachedMesh() {\r\n        return this._updateGizmoPositionToMatchAttachedMesh;\r\n    }\r\n\r\n    /**\r\n     * Defines where the gizmo will be positioned if `updateGizmoPositionToMatchAttachedMesh` is enabled.\r\n     * (Default: GizmoAnchorPoint.Origin)\r\n     */\r\n    public set anchorPoint(value: GizmoAnchorPoint) {\r\n        this._anchorPoint = value;\r\n    }\r\n    public get anchorPoint() {\r\n        return this._anchorPoint;\r\n    }\r\n\r\n    /**\r\n     * Set the coordinate system to use. By default it's local.\r\n     * But it's possible for a user to tweak so its local for translation and world for rotation.\r\n     * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`\r\n     */\r\n    public set coordinatesMode(coordinatesMode: GizmoCoordinatesMode) {\r\n        this._coordinatesMode = coordinatesMode;\r\n        const local = coordinatesMode == GizmoCoordinatesMode.Local;\r\n        this.updateGizmoRotationToMatchAttachedMesh = local;\r\n        this.updateGizmoPositionToMatchAttachedMesh = true;\r\n    }\r\n\r\n    public get coordinatesMode() {\r\n        return this._coordinatesMode;\r\n    }\r\n\r\n    /**\r\n     * When set, the gizmo will always appear the same size no matter where the camera is (default: true)\r\n     */\r\n\r\n    public set updateScale(value: boolean) {\r\n        this._updateScale = value;\r\n    }\r\n    public get updateScale() {\r\n        return this._updateScale;\r\n    }\r\n    protected _interactionsEnabled = true;\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _attachedNodeChanged(value: Nullable<Node>) {}\r\n\r\n    protected _beforeRenderObserver: Nullable<Observer<Scene>>;\r\n    private _rightHandtoLeftHandMatrix = Matrix.RotationY(Math.PI);\r\n\r\n    /**\r\n     * Creates a gizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     */\r\n    constructor(\r\n        /** [Object] The utility layer the gizmo will be added to */\r\n        public gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer\r\n    ) {\r\n        this._rootMesh = new Mesh(\"gizmoRootNode\", gizmoLayer.utilityLayerScene);\r\n        this._rootMesh.rotationQuaternion = Quaternion.Identity();\r\n\r\n        this._beforeRenderObserver = this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(() => {\r\n            this._update();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * posture that the gizmo will be display\r\n     * When set null, default value will be used (Quaternion(0, 0, 0, 1))\r\n     */\r\n    public get customRotationQuaternion(): Nullable<Quaternion> {\r\n        return this._customRotationQuaternion;\r\n    }\r\n\r\n    public set customRotationQuaternion(customRotationQuaternion: Nullable<Quaternion>) {\r\n        this._customRotationQuaternion = customRotationQuaternion;\r\n    }\r\n\r\n    /**\r\n     * Updates the gizmo to match the attached mesh's position/rotation\r\n     */\r\n    protected _update() {\r\n        if (this.attachedNode) {\r\n            let effectiveNode = this.attachedNode;\r\n            if (this.attachedMesh) {\r\n                effectiveNode = this.attachedMesh || this.attachedNode;\r\n            }\r\n\r\n            // Position\r\n            if (this.updateGizmoPositionToMatchAttachedMesh) {\r\n                if (this.anchorPoint == GizmoAnchorPoint.Pivot && (<TransformNode>effectiveNode).getAbsolutePivotPoint) {\r\n                    const position = (<TransformNode>effectiveNode).getAbsolutePivotPoint();\r\n                    this._rootMesh.position.copyFrom(position);\r\n                } else {\r\n                    const row = effectiveNode.getWorldMatrix().getRow(3);\r\n                    const position = row ? row.toVector3() : new Vector3(0, 0, 0);\r\n                    this._rootMesh.position.copyFrom(position);\r\n                }\r\n            }\r\n\r\n            // Rotation\r\n            if (this.updateGizmoRotationToMatchAttachedMesh) {\r\n                const supportedNode =\r\n                    (<Mesh>effectiveNode)._isMesh ||\r\n                    effectiveNode.getClassName() === \"AbstractMesh\" ||\r\n                    effectiveNode.getClassName() === \"TransformNode\" ||\r\n                    effectiveNode.getClassName() === \"InstancedMesh\";\r\n                const transformNode = supportedNode ? (effectiveNode as TransformNode) : undefined;\r\n                effectiveNode.getWorldMatrix().decompose(undefined, this._rootMesh.rotationQuaternion!, undefined, Gizmo.PreserveScaling ? transformNode : undefined);\r\n                this._rootMesh.rotationQuaternion!.normalize();\r\n            } else {\r\n                if (this._customRotationQuaternion) {\r\n                    this._rootMesh.rotationQuaternion!.copyFrom(this._customRotationQuaternion);\r\n                } else {\r\n                    this._rootMesh.rotationQuaternion!.set(0, 0, 0, 1);\r\n                }\r\n            }\r\n\r\n            // Scale\r\n            if (this.updateScale) {\r\n                const activeCamera = this.gizmoLayer.utilityLayerScene.activeCamera!;\r\n                const cameraPosition = activeCamera.globalPosition;\r\n                this._rootMesh.position.subtractToRef(cameraPosition, TmpVectors.Vector3[0]);\r\n                let scale = this.scaleRatio;\r\n                if (activeCamera.mode == Camera.ORTHOGRAPHIC_CAMERA) {\r\n                    if (activeCamera.orthoTop && activeCamera.orthoBottom) {\r\n                        const orthoHeight = activeCamera.orthoTop - activeCamera.orthoBottom;\r\n                        scale *= orthoHeight;\r\n                    }\r\n                } else {\r\n                    const camForward = activeCamera.getScene().useRightHandedSystem ? Vector3.RightHandedForwardReadOnly : Vector3.LeftHandedForwardReadOnly;\r\n                    const direction = activeCamera.getDirection(camForward);\r\n                    scale *= Vector3.Dot(TmpVectors.Vector3[0], direction);\r\n                }\r\n                this._rootMesh.scaling.setAll(scale);\r\n\r\n                // Account for handedness, similar to Matrix.decompose\r\n                if (effectiveNode._getWorldMatrixDeterminant() < 0 && !Gizmo.PreserveScaling) {\r\n                    this._rootMesh.scaling.y *= -1;\r\n                }\r\n            } else {\r\n                this._rootMesh.scaling.setAll(this.scaleRatio);\r\n            }\r\n        }\r\n\r\n        if (this.additionalTransformNode) {\r\n            this._rootMesh.computeWorldMatrix(true);\r\n            this._rootMesh.getWorldMatrix().multiplyToRef(this.additionalTransformNode.getWorldMatrix(), TmpVectors.Matrix[0]);\r\n            TmpVectors.Matrix[0].decompose(this._rootMesh.scaling, this._rootMesh.rotationQuaternion!, this._rootMesh.position);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * if transform has a pivot and is not using PostMultiplyPivotMatrix, then the worldMatrix contains the pivot matrix (it's not cancelled at the end)\r\n     * so, when extracting the world matrix component, the translation (and other components) is containing the pivot translation.\r\n     * And the pivot is applied each frame. Removing it anyway here makes it applied only in computeWorldMatrix.\r\n     * @param transform local transform that needs to be transform by the pivot inverse matrix\r\n     * @param localMatrix local matrix that needs to be transform by the pivot inverse matrix\r\n     * @param result resulting matrix transformed by pivot inverse if the transform node is using pivot without using post Multiply Pivot Matrix\r\n     */\r\n    protected _handlePivotMatrixInverse(transform: TransformNode, localMatrix: Matrix, result: Matrix): void {\r\n        if (transform.isUsingPivotMatrix() && !transform.isUsingPostMultiplyPivotMatrix()) {\r\n            transform.getPivotMatrix().invertToRef(TmpVectors.Matrix[5]);\r\n            TmpVectors.Matrix[5].multiplyToRef(localMatrix, result);\r\n            return;\r\n        }\r\n        result.copyFrom(localMatrix);\r\n    }\r\n    /**\r\n     * computes the rotation/scaling/position of the transform once the Node world matrix has changed.\r\n     */\r\n    protected _matrixChanged() {\r\n        if (!this._attachedNode) {\r\n            return;\r\n        }\r\n\r\n        if ((<Camera>this._attachedNode)._isCamera) {\r\n            const camera = this._attachedNode as Camera;\r\n            let worldMatrix;\r\n            let worldMatrixUC;\r\n            if (camera.parent) {\r\n                const parentInv = TmpVectors.Matrix[1];\r\n                camera.parent._worldMatrix.invertToRef(parentInv);\r\n                this._attachedNode._worldMatrix.multiplyToRef(parentInv, TmpVectors.Matrix[0]);\r\n                worldMatrix = TmpVectors.Matrix[0];\r\n            } else {\r\n                worldMatrix = this._attachedNode._worldMatrix;\r\n            }\r\n\r\n            if (camera.getScene().useRightHandedSystem) {\r\n                // avoid desync with RH matrix computation. Otherwise, rotation of PI around Y axis happens each frame resulting in axis flipped because worldMatrix is computed as inverse of viewMatrix.\r\n                this._rightHandtoLeftHandMatrix.multiplyToRef(worldMatrix, TmpVectors.Matrix[1]);\r\n                worldMatrixUC = TmpVectors.Matrix[1];\r\n            } else {\r\n                worldMatrixUC = worldMatrix;\r\n            }\r\n\r\n            worldMatrixUC.decompose(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);\r\n\r\n            const inheritsTargetCamera =\r\n                this._attachedNode.getClassName() === \"FreeCamera\" ||\r\n                this._attachedNode.getClassName() === \"FlyCamera\" ||\r\n                this._attachedNode.getClassName() === \"ArcFollowCamera\" ||\r\n                this._attachedNode.getClassName() === \"TargetCamera\" ||\r\n                this._attachedNode.getClassName() === \"TouchCamera\" ||\r\n                this._attachedNode.getClassName() === \"UniversalCamera\";\r\n\r\n            if (inheritsTargetCamera) {\r\n                const targetCamera = this._attachedNode as TargetCamera;\r\n                targetCamera.rotation = TmpVectors.Quaternion[0].toEulerAngles();\r\n\r\n                if (targetCamera.rotationQuaternion) {\r\n                    targetCamera.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);\r\n                    targetCamera.rotationQuaternion.normalize();\r\n                }\r\n            }\r\n\r\n            camera.position.copyFrom(TmpVectors.Vector3[0]);\r\n        } else if (\r\n            (<Mesh>this._attachedNode)._isMesh ||\r\n            this._attachedNode.getClassName() === \"AbstractMesh\" ||\r\n            this._attachedNode.getClassName() === \"TransformNode\" ||\r\n            this._attachedNode.getClassName() === \"InstancedMesh\"\r\n        ) {\r\n            const transform = this._attachedNode as TransformNode;\r\n            if (transform.parent) {\r\n                const parentInv = TmpVectors.Matrix[0];\r\n                const localMat = TmpVectors.Matrix[1];\r\n                transform.parent.getWorldMatrix().invertToRef(parentInv);\r\n                this._attachedNode.getWorldMatrix().multiplyToRef(parentInv, localMat);\r\n                const matrixToDecompose = TmpVectors.Matrix[4];\r\n                this._handlePivotMatrixInverse(transform, localMat, matrixToDecompose);\r\n                matrixToDecompose.decompose(\r\n                    TmpVectors.Vector3[0],\r\n                    TmpVectors.Quaternion[0],\r\n                    transform.position,\r\n                    Gizmo.PreserveScaling ? transform : undefined,\r\n                    Gizmo.UseAbsoluteScaling\r\n                );\r\n                TmpVectors.Quaternion[0].normalize();\r\n                if (transform.isUsingPivotMatrix()) {\r\n                    // Calculate the local matrix without the translation.\r\n                    // Copied from TranslateNode.computeWorldMatrix\r\n                    const r = TmpVectors.Quaternion[1];\r\n                    Quaternion.RotationYawPitchRollToRef(transform.rotation.y, transform.rotation.x, transform.rotation.z, r);\r\n\r\n                    const scaleMatrix = TmpVectors.Matrix[2];\r\n                    Matrix.ScalingToRef(transform.scaling.x, transform.scaling.y, transform.scaling.z, scaleMatrix);\r\n\r\n                    const rotationMatrix = TmpVectors.Matrix[2];\r\n                    r.toRotationMatrix(rotationMatrix);\r\n\r\n                    const pivotMatrix = transform.getPivotMatrix();\r\n                    const invPivotMatrix = TmpVectors.Matrix[3];\r\n                    pivotMatrix.invertToRef(invPivotMatrix);\r\n\r\n                    pivotMatrix.multiplyToRef(scaleMatrix, TmpVectors.Matrix[4]);\r\n                    TmpVectors.Matrix[4].multiplyToRef(rotationMatrix, TmpVectors.Matrix[5]);\r\n                    TmpVectors.Matrix[5].multiplyToRef(invPivotMatrix, TmpVectors.Matrix[6]);\r\n\r\n                    TmpVectors.Matrix[6].getTranslationToRef(TmpVectors.Vector3[1]);\r\n\r\n                    transform.position.subtractInPlace(TmpVectors.Vector3[1]);\r\n                }\r\n            } else {\r\n                const matrixToDecompose = TmpVectors.Matrix[4];\r\n                this._handlePivotMatrixInverse(transform, this._attachedNode._worldMatrix, matrixToDecompose);\r\n                matrixToDecompose.decompose(\r\n                    TmpVectors.Vector3[0],\r\n                    TmpVectors.Quaternion[0],\r\n                    transform.position,\r\n                    Gizmo.PreserveScaling ? transform : undefined,\r\n                    Gizmo.UseAbsoluteScaling\r\n                );\r\n            }\r\n            TmpVectors.Vector3[0].scaleInPlace(1.0 / transform.scalingDeterminant);\r\n            transform.scaling.copyFrom(TmpVectors.Vector3[0]);\r\n            if (!transform.billboardMode) {\r\n                if (transform.rotationQuaternion) {\r\n                    transform.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);\r\n                    transform.rotationQuaternion.normalize();\r\n                } else {\r\n                    transform.rotation = TmpVectors.Quaternion[0].toEulerAngles();\r\n                }\r\n            }\r\n        } else if (this._attachedNode.getClassName() === \"Bone\") {\r\n            const bone = this._attachedNode as Bone;\r\n            const parent = bone.getParent();\r\n\r\n            if (parent) {\r\n                const invParent = TmpVectors.Matrix[0];\r\n                const boneLocalMatrix = TmpVectors.Matrix[1];\r\n                parent.getFinalMatrix().invertToRef(invParent);\r\n                bone.getFinalMatrix().multiplyToRef(invParent, boneLocalMatrix);\r\n                const lmat = bone.getLocalMatrix();\r\n                lmat.copyFrom(boneLocalMatrix);\r\n            } else {\r\n                const lmat = bone.getLocalMatrix();\r\n                lmat.copyFrom(bone.getFinalMatrix());\r\n            }\r\n            bone.markAsDirty();\r\n        } else {\r\n            const light = this._attachedNode as ShadowLight;\r\n            if (light.getTypeID) {\r\n                const type = light.getTypeID();\r\n                if (type === Light.LIGHTTYPEID_DIRECTIONALLIGHT || type === Light.LIGHTTYPEID_SPOTLIGHT || type === Light.LIGHTTYPEID_POINTLIGHT) {\r\n                    const parent = light.parent;\r\n\r\n                    if (parent) {\r\n                        const invParent = TmpVectors.Matrix[0];\r\n                        const nodeLocalMatrix = TmpVectors.Matrix[1];\r\n                        parent.getWorldMatrix().invertToRef(invParent);\r\n                        light.getWorldMatrix().multiplyToRef(invParent, nodeLocalMatrix);\r\n                        nodeLocalMatrix.decompose(undefined, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);\r\n                    } else {\r\n                        this._attachedNode._worldMatrix.decompose(undefined, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);\r\n                    }\r\n                    // setter doesn't copy values. Need a new Vector3\r\n                    light.position = new Vector3(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z);\r\n                    if (light.direction) {\r\n                        light.direction = new Vector3(light.direction.x, light.direction.y, light.direction.z);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * refresh gizmo mesh material\r\n     * @param gizmoMeshes\r\n     * @param material material to apply\r\n     */\r\n    protected _setGizmoMeshMaterial(gizmoMeshes: Mesh[], material: StandardMaterial) {\r\n        if (gizmoMeshes) {\r\n            gizmoMeshes.forEach((m: Mesh) => {\r\n                m.material = material;\r\n                if ((<LinesMesh>m).color) {\r\n                    (<LinesMesh>m).color = material.diffuseColor;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Subscribes to pointer up, down, and hover events. Used for responsive gizmos.\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\r\n     * @returns {Observer<PointerInfo>} pointerObserver\r\n     */\r\n    public static GizmoAxisPointerObserver(gizmoLayer: UtilityLayerRenderer, gizmoAxisCache: Map<Mesh, GizmoAxisCache>): Observer<PointerInfo> {\r\n        let dragging = false;\r\n        let activeDragButton = -1;\r\n        let forcePointerUp = false;\r\n\r\n        const pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\r\n            if (pointerInfo.pickInfo) {\r\n                // If we are dragging and the user presses another button, end the drag.\r\n                // Otherwise, tracking when the drag should end becomes very complex.\r\n                // pointerDragBehavior.ts has similar logic.\r\n                forcePointerUp = dragging && pointerInfo.event.button !== -1 && pointerInfo.event.button !== activeDragButton;\r\n\r\n                if (forcePointerUp || pointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                    // On Mouse Up\r\n\r\n                    gizmoAxisCache.forEach((cache) => {\r\n                        cache.active = false;\r\n                        dragging = false;\r\n                        activeDragButton = -1;\r\n                        cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                            m.material = cache.dragBehavior.enabled ? cache.material : cache.disableMaterial;\r\n                            if ((m as LinesMesh).color) {\r\n                                (m as LinesMesh).color = cache.material.diffuseColor;\r\n                            }\r\n                        });\r\n                    });\r\n                } else if (pointerInfo.type === PointerEventTypes.POINTERMOVE) {\r\n                    // On Hover Logic\r\n                    if (dragging) {\r\n                        return;\r\n                    }\r\n                    gizmoAxisCache.forEach((cache) => {\r\n                        if (cache.colliderMeshes && cache.gizmoMeshes) {\r\n                            const isHovered = cache.colliderMeshes?.indexOf(pointerInfo?.pickInfo?.pickedMesh as Mesh) != -1;\r\n                            const material = cache.dragBehavior.enabled ? (isHovered || cache.active ? cache.hoverMaterial : cache.material) : cache.disableMaterial;\r\n                            cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                                m.material = material;\r\n                                if ((m as LinesMesh).color) {\r\n                                    (m as LinesMesh).color = material.diffuseColor;\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                } else if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                    // On Mouse Down\r\n                    // If user Clicked Gizmo\r\n                    if (gizmoAxisCache.has(pointerInfo.pickInfo.pickedMesh?.parent as Mesh)) {\r\n                        dragging = true;\r\n                        activeDragButton = pointerInfo.event.button;\r\n                        const statusMap = gizmoAxisCache.get(pointerInfo.pickInfo.pickedMesh?.parent as Mesh);\r\n                        statusMap!.active = true;\r\n                        gizmoAxisCache.forEach((cache) => {\r\n                            const isHovered = cache.colliderMeshes?.indexOf(pointerInfo?.pickInfo?.pickedMesh as Mesh) != -1;\r\n                            const material = (isHovered || cache.active) && cache.dragBehavior.enabled ? cache.hoverMaterial : cache.disableMaterial;\r\n                            cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                                m.material = material;\r\n                                if ((m as LinesMesh).color) {\r\n                                    (m as LinesMesh).color = material.diffuseColor;\r\n                                }\r\n                            });\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        return pointerObserver!;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the gizmo\r\n     */\r\n    public dispose() {\r\n        this._rootMesh.dispose();\r\n        if (this._beforeRenderObserver) {\r\n            this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver);\r\n        }\r\n    }\r\n}\r\n", "import { Vector3, Matrix } from \"../Maths/math.vector\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\n\r\n/**\r\n * Class containing a set of static utilities functions for managing Pivots\r\n * @internal\r\n */\r\nexport class PivotTools {\r\n    // Stores the state of the pivot cache (_oldPivotPoint, _pivotTranslation)\r\n    // store/remove pivot point should only be applied during their outermost calls\r\n    private static _PivotCached = 0;\r\n    private static _OldPivotPoint = new Vector3();\r\n    private static _PivotTranslation = new Vector3();\r\n    private static _PivotTmpVector = new Vector3();\r\n    private static _PivotPostMultiplyPivotMatrix = false;\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _RemoveAndStorePivotPoint(mesh: TransformNode) {\r\n        if (mesh && PivotTools._PivotCached === 0) {\r\n            // Save old pivot and set pivot to 0,0,0\r\n            mesh.getPivotPointToRef(PivotTools._OldPivotPoint);\r\n            PivotTools._PivotPostMultiplyPivotMatrix = mesh._postMultiplyPivotMatrix;\r\n            if (!PivotTools._OldPivotPoint.equalsToFloats(0, 0, 0)) {\r\n                mesh.setPivotMatrix(Matrix.IdentityReadOnly);\r\n                PivotTools._OldPivotPoint.subtractToRef(mesh.getPivotPoint(), PivotTools._PivotTranslation);\r\n                PivotTools._PivotTmpVector.copyFromFloats(1, 1, 1);\r\n                PivotTools._PivotTmpVector.subtractInPlace(mesh.scaling);\r\n                PivotTools._PivotTmpVector.multiplyInPlace(PivotTools._PivotTranslation);\r\n                mesh.position.addInPlace(PivotTools._PivotTmpVector);\r\n            }\r\n        }\r\n        PivotTools._PivotCached++;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _RestorePivotPoint(mesh: TransformNode) {\r\n        if (mesh && !PivotTools._OldPivotPoint.equalsToFloats(0, 0, 0) && PivotTools._PivotCached === 1) {\r\n            mesh.setPivotPoint(PivotTools._OldPivotPoint);\r\n            mesh._postMultiplyPivotMatrix = PivotTools._PivotPostMultiplyPivotMatrix;\r\n            PivotTools._PivotTmpVector.copyFromFloats(1, 1, 1);\r\n            PivotTools._PivotTmpVector.subtractInPlace(mesh.scaling);\r\n            PivotTools._PivotTmpVector.multiplyInPlace(PivotTools._PivotTranslation);\r\n            mesh.position.subtractInPlace(PivotTools._PivotTmpVector);\r\n        }\r\n        this._PivotCached--;\r\n    }\r\n}\r\n", "import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { PivotTools } from \"../../Misc/pivotTools\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { CreatePlane } from \"../../Meshes/Builders/planeBuilder\";\r\n\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\n\r\n/**\r\n * A behavior that when attached to a mesh will allow the mesh to be dragged around the screen based on pointer events\r\n */\r\nexport class PointerDragBehavior implements Behavior<AbstractMesh> {\r\n    private static _AnyMouseId = -2;\r\n    /**\r\n     * Abstract mesh the behavior is set on\r\n     */\r\n    public attachedNode: AbstractMesh;\r\n    protected _dragPlane: Mesh;\r\n    private _scene: Scene;\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>>;\r\n    private _beforeRenderObserver: Nullable<Observer<Scene>>;\r\n    private static _PlaneScene: Scene;\r\n    private _useAlternatePickedPointAboveMaxDragAngleDragSpeed = -1.1;\r\n    private _activeDragButton: number = -1;\r\n    private _activePointerInfo: Nullable<PointerInfo>;\r\n    /**\r\n     * The maximum tolerated angle between the drag plane and dragging pointer rays to trigger pointer events. Set to 0 to allow any angle (default: 0)\r\n     */\r\n    public maxDragAngle = 0;\r\n    /**\r\n     * Butttons that can be used to initiate a drag\r\n     */\r\n    public dragButtons = [0, 1, 2];\r\n    /**\r\n     * @internal\r\n     */\r\n    public _useAlternatePickedPointAboveMaxDragAngle = false;\r\n    /**\r\n     * Get or set the currentDraggingPointerId\r\n     * @deprecated Please use currentDraggingPointerId instead\r\n     */\r\n    public get currentDraggingPointerID(): number {\r\n        return this.currentDraggingPointerId;\r\n    }\r\n    public set currentDraggingPointerID(currentDraggingPointerID: number) {\r\n        this.currentDraggingPointerId = currentDraggingPointerID;\r\n    }\r\n    /**\r\n     * The id of the pointer that is currently interacting with the behavior (-1 when no pointer is active)\r\n     */\r\n    public currentDraggingPointerId = -1;\r\n    /**\r\n     * The last position where the pointer hit the drag plane in world space\r\n     */\r\n    public lastDragPosition: Vector3;\r\n    /**\r\n     * If the behavior is currently in a dragging state\r\n     */\r\n    public dragging = false;\r\n    /**\r\n     * The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)\r\n     */\r\n    public dragDeltaRatio = 0.2;\r\n    /**\r\n     * If the drag plane orientation should be updated during the dragging (Default: true)\r\n     */\r\n    public updateDragPlane = true;\r\n    // Debug mode will display drag planes to help visualize behavior\r\n    private _debugMode = false;\r\n    private _moving = false;\r\n    /**\r\n     *  Fires each time the attached mesh is dragged with the pointer\r\n     *  * delta between last drag position and current drag position in world space\r\n     *  * dragDistance along the drag axis\r\n     *  * dragPlaneNormal normal of the current drag plane used during the drag\r\n     *  * dragPlanePoint in world space where the drag intersects the drag plane\r\n     *\r\n     *  (if validatedDrag is used, the position of the attached mesh might not equal dragPlanePoint)\r\n     */\r\n    public onDragObservable = new Observable<{\r\n        delta: Vector3;\r\n        dragPlanePoint: Vector3;\r\n        dragPlaneNormal: Vector3;\r\n        dragDistance: number;\r\n        pointerId: number;\r\n        pointerInfo: Nullable<PointerInfo>;\r\n    }>();\r\n    /**\r\n     *  Fires each time a drag begins (eg. mouse down on mesh)\r\n     *  * dragPlanePoint in world space where the drag intersects the drag plane\r\n     *\r\n     *  (if validatedDrag is used, the position of the attached mesh might not equal dragPlanePoint)\r\n     */\r\n    public onDragStartObservable = new Observable<{ dragPlanePoint: Vector3; pointerId: number; pointerInfo: Nullable<PointerInfo> }>();\r\n    /**\r\n     *  Fires each time a drag ends (eg. mouse release after drag)\r\n     *  * dragPlanePoint in world space where the drag intersects the drag plane\r\n     *\r\n     *  (if validatedDrag is used, the position of the attached mesh might not equal dragPlanePoint)\r\n     */\r\n    public onDragEndObservable = new Observable<{ dragPlanePoint: Vector3; pointerId: number; pointerInfo: Nullable<PointerInfo> }>();\r\n    /**\r\n     *  Fires each time behavior enabled state changes\r\n     */\r\n    public onEnabledObservable = new Observable<boolean>();\r\n\r\n    /**\r\n     *  If the attached mesh should be moved when dragged\r\n     */\r\n    public moveAttached = true;\r\n\r\n    /**\r\n     *  If the drag behavior will react to drag events (Default: true)\r\n     */\r\n    public set enabled(value: boolean) {\r\n        if (value != this._enabled) {\r\n            this.onEnabledObservable.notifyObservers(value);\r\n        }\r\n        this._enabled = value;\r\n    }\r\n\r\n    public get enabled() {\r\n        return this._enabled;\r\n    }\r\n    private _enabled = true;\r\n\r\n    /**\r\n     * If pointer events should start and release the drag (Default: true)\r\n     */\r\n    public startAndReleaseDragOnPointerEvents = true;\r\n    /**\r\n     * If camera controls should be detached during the drag\r\n     */\r\n    public detachCameraControls = true;\r\n\r\n    /**\r\n     * If set, the drag plane/axis will be rotated based on the attached mesh's world rotation (Default: true)\r\n     */\r\n    public useObjectOrientationForDragging = true;\r\n\r\n    private _options: { dragAxis?: Vector3; dragPlaneNormal?: Vector3 };\r\n\r\n    /**\r\n     * Gets the options used by the behavior\r\n     */\r\n    public get options(): { dragAxis?: Vector3; dragPlaneNormal?: Vector3 } {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * Sets the options used by the behavior\r\n     */\r\n    public set options(options: { dragAxis?: Vector3; dragPlaneNormal?: Vector3 }) {\r\n        this._options = options;\r\n    }\r\n\r\n    /**\r\n     * Creates a pointer drag behavior that can be attached to a mesh\r\n     * @param options The drag axis or normal of the plane that will be dragged across. If no options are specified the drag plane will always face the ray's origin (eg. camera)\r\n     * @param options.dragAxis\r\n     * @param options.dragPlaneNormal\r\n     */\r\n    constructor(options?: { dragAxis?: Vector3; dragPlaneNormal?: Vector3 }) {\r\n        this._options = options ? options : {};\r\n\r\n        let optionCount = 0;\r\n        if (this._options.dragAxis) {\r\n            optionCount++;\r\n        }\r\n        if (this._options.dragPlaneNormal) {\r\n            optionCount++;\r\n        }\r\n        if (optionCount > 1) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"Multiple drag modes specified in dragBehavior options. Only one expected\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Predicate to determine if it is valid to move the object to a new position when it is moved.\r\n     * In the case of rotation gizmo, target contains the angle.\r\n     * @param target destination position or desired angle delta\r\n     * @returns boolean for whether or not it is valid to move\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public validateDrag = (target: Vector3) => {\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"PointerDrag\";\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() {}\r\n\r\n    private _tmpVector = new Vector3(0, 0, 0);\r\n    private _alternatePickedPoint = new Vector3(0, 0, 0);\r\n    private _worldDragAxis = new Vector3(0, 0, 0);\r\n    private _targetPosition = new Vector3(0, 0, 0);\r\n    private _attachedToElement: boolean = false;\r\n    /**\r\n     * Attaches the drag behavior the passed in mesh\r\n     * @param ownerNode The mesh that will be dragged around once attached\r\n     * @param predicate Predicate to use for pick filtering\r\n     */\r\n    public attach(ownerNode: AbstractMesh, predicate?: (m: AbstractMesh) => boolean): void {\r\n        this._scene = ownerNode.getScene();\r\n        ownerNode.isNearGrabbable = true;\r\n        this.attachedNode = ownerNode;\r\n\r\n        // Initialize drag plane to not interfere with existing scene\r\n        if (!PointerDragBehavior._PlaneScene) {\r\n            if (this._debugMode) {\r\n                PointerDragBehavior._PlaneScene = this._scene;\r\n            } else {\r\n                PointerDragBehavior._PlaneScene = new Scene(this._scene.getEngine(), { virtual: true });\r\n                PointerDragBehavior._PlaneScene.detachControl();\r\n                this._scene.onDisposeObservable.addOnce(() => {\r\n                    PointerDragBehavior._PlaneScene.dispose();\r\n                    (<any>PointerDragBehavior._PlaneScene) = null;\r\n                });\r\n            }\r\n        }\r\n        this._dragPlane = CreatePlane(\r\n            \"pointerDragPlane\",\r\n            { size: this._debugMode ? 1 : 10000, updatable: false, sideOrientation: Mesh.DOUBLESIDE },\r\n            PointerDragBehavior._PlaneScene\r\n        );\r\n\r\n        // State of the drag\r\n        this.lastDragPosition = new Vector3(0, 0, 0);\r\n\r\n        const pickPredicate = predicate\r\n            ? predicate\r\n            : (m: AbstractMesh) => {\r\n                  return this.attachedNode == m || m.isDescendantOf(this.attachedNode);\r\n              };\r\n\r\n        this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {\r\n            if (!this.enabled) {\r\n                // If behavior is disabled before releaseDrag is ever called, call it now.\r\n                if (this._attachedToElement) {\r\n                    this.releaseDrag();\r\n                }\r\n\r\n                return;\r\n            }\r\n\r\n            // If we are dragging and the user presses another button on the same pointer, end the drag. Otherwise,\r\n            // tracking when the drag should end becomes very complex.\r\n            // gizmo.ts has similar behavior.\r\n            if (\r\n                this.dragging &&\r\n                this.currentDraggingPointerId == (<IPointerEvent>pointerInfo.event).pointerId &&\r\n                pointerInfo.event.button !== -1 &&\r\n                pointerInfo.event.button !== this._activeDragButton\r\n            ) {\r\n                this.releaseDrag();\r\n                return;\r\n            }\r\n\r\n            if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {\r\n                if (\r\n                    this.startAndReleaseDragOnPointerEvents &&\r\n                    !this.dragging &&\r\n                    pointerInfo.pickInfo &&\r\n                    pointerInfo.pickInfo.hit &&\r\n                    pointerInfo.pickInfo.pickedMesh &&\r\n                    pointerInfo.pickInfo.pickedPoint &&\r\n                    pointerInfo.pickInfo.ray &&\r\n                    pickPredicate(pointerInfo.pickInfo.pickedMesh)\r\n                ) {\r\n                    if (this._activeDragButton === -1 && this.dragButtons.indexOf(pointerInfo.event.button) !== -1) {\r\n                        this._activeDragButton = pointerInfo.event.button;\r\n                        this._activePointerInfo = pointerInfo;\r\n                        this._startDrag((<IPointerEvent>pointerInfo.event).pointerId, pointerInfo.pickInfo.ray, pointerInfo.pickInfo.pickedPoint);\r\n                    }\r\n                }\r\n            } else if (pointerInfo.type == PointerEventTypes.POINTERUP) {\r\n                if (\r\n                    this.startAndReleaseDragOnPointerEvents &&\r\n                    this.currentDraggingPointerId == (<IPointerEvent>pointerInfo.event).pointerId &&\r\n                    (this._activeDragButton === pointerInfo.event.button || this._activeDragButton === -1)\r\n                ) {\r\n                    this.releaseDrag();\r\n                }\r\n            } else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {\r\n                const pointerId = (<IPointerEvent>pointerInfo.event).pointerId;\r\n\r\n                // If drag was started with anyMouseID specified, set pointerID to the next mouse that moved\r\n                if (this.currentDraggingPointerId === PointerDragBehavior._AnyMouseId && pointerId !== PointerDragBehavior._AnyMouseId) {\r\n                    const evt = <IPointerEvent>pointerInfo.event;\r\n                    const isMouseEvent = evt.pointerType === \"mouse\" || (!this._scene.getEngine().hostInformation.isMobile && evt instanceof MouseEvent);\r\n                    if (isMouseEvent) {\r\n                        if (this._lastPointerRay[this.currentDraggingPointerId]) {\r\n                            this._lastPointerRay[pointerId] = this._lastPointerRay[this.currentDraggingPointerId];\r\n                            delete this._lastPointerRay[this.currentDraggingPointerId];\r\n                        }\r\n                        this.currentDraggingPointerId = pointerId;\r\n                    }\r\n                }\r\n\r\n                // Keep track of last pointer ray, this is used simulating the start of a drag in startDrag()\r\n                if (!this._lastPointerRay[pointerId]) {\r\n                    this._lastPointerRay[pointerId] = new Ray(new Vector3(), new Vector3());\r\n                }\r\n                if (pointerInfo.pickInfo && pointerInfo.pickInfo.ray) {\r\n                    this._lastPointerRay[pointerId].origin.copyFrom(pointerInfo.pickInfo.ray.origin);\r\n                    this._lastPointerRay[pointerId].direction.copyFrom(pointerInfo.pickInfo.ray.direction);\r\n\r\n                    if (this.currentDraggingPointerId == pointerId && this.dragging) {\r\n                        this._moveDrag(pointerInfo.pickInfo.ray);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        this._beforeRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\r\n            if (this._moving && this.moveAttached) {\r\n                let needMatrixUpdate = false;\r\n                PivotTools._RemoveAndStorePivotPoint(this.attachedNode);\r\n                // Slowly move mesh to avoid jitter\r\n                this._targetPosition.subtractToRef(this.attachedNode.absolutePosition, this._tmpVector);\r\n                this._tmpVector.scaleInPlace(this.dragDeltaRatio);\r\n                this.attachedNode.getAbsolutePosition().addToRef(this._tmpVector, this._tmpVector);\r\n                if (this.validateDrag(this._tmpVector)) {\r\n                    this.attachedNode.setAbsolutePosition(this._tmpVector);\r\n                    needMatrixUpdate = true;\r\n                }\r\n                PivotTools._RestorePivotPoint(this.attachedNode);\r\n                if (needMatrixUpdate) {\r\n                    this.attachedNode.computeWorldMatrix();\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Force release the drag action by code.\r\n     */\r\n    public releaseDrag() {\r\n        if (this.dragging) {\r\n            this.dragging = false;\r\n            this.onDragEndObservable.notifyObservers({ dragPlanePoint: this.lastDragPosition, pointerId: this.currentDraggingPointerId, pointerInfo: this._activePointerInfo });\r\n        }\r\n\r\n        this.currentDraggingPointerId = -1;\r\n        this._activeDragButton = -1;\r\n        this._activePointerInfo = null;\r\n        this._moving = false;\r\n\r\n        // Reattach camera controls\r\n        if (this.detachCameraControls && this._attachedToElement && this._scene.activeCamera && !this._scene.activeCamera.leftCamera) {\r\n            if (this._scene.activeCamera.getClassName() === \"ArcRotateCamera\") {\r\n                const arcRotateCamera = this._scene.activeCamera as ArcRotateCamera;\r\n                arcRotateCamera.attachControl(\r\n                    arcRotateCamera.inputs ? arcRotateCamera.inputs.noPreventDefault : true,\r\n                    arcRotateCamera._useCtrlForPanning,\r\n                    arcRotateCamera._panningMouseButton\r\n                );\r\n            } else {\r\n                this._scene.activeCamera.attachControl(this._scene.activeCamera.inputs ? this._scene.activeCamera.inputs.noPreventDefault : true);\r\n            }\r\n            this._attachedToElement = false;\r\n        }\r\n    }\r\n\r\n    private _startDragRay = new Ray(new Vector3(), new Vector3());\r\n    private _lastPointerRay: { [key: number]: Ray } = {};\r\n    /**\r\n     * Simulates the start of a pointer drag event on the behavior\r\n     * @param pointerId pointerID of the pointer that should be simulated (Default: Any mouse pointer ID)\r\n     * @param fromRay initial ray of the pointer to be simulated (Default: Ray from camera to attached mesh)\r\n     * @param startPickedPoint picked point of the pointer to be simulated (Default: attached mesh position)\r\n     */\r\n    public startDrag(pointerId: number = PointerDragBehavior._AnyMouseId, fromRay?: Ray, startPickedPoint?: Vector3) {\r\n        this._startDrag(pointerId, fromRay, startPickedPoint);\r\n\r\n        let lastRay = this._lastPointerRay[pointerId];\r\n        if (pointerId === PointerDragBehavior._AnyMouseId) {\r\n            lastRay = this._lastPointerRay[<any>Object.keys(this._lastPointerRay)[0]];\r\n        }\r\n\r\n        if (lastRay) {\r\n            // if there was a last pointer ray drag the object there\r\n            this._moveDrag(lastRay);\r\n        }\r\n    }\r\n\r\n    protected _startDrag(pointerId: number, fromRay?: Ray, startPickedPoint?: Vector3) {\r\n        if (!this._scene.activeCamera || this.dragging || !this.attachedNode) {\r\n            return;\r\n        }\r\n\r\n        PivotTools._RemoveAndStorePivotPoint(this.attachedNode);\r\n        // Create start ray from the camera to the object\r\n        if (fromRay) {\r\n            this._startDragRay.direction.copyFrom(fromRay.direction);\r\n            this._startDragRay.origin.copyFrom(fromRay.origin);\r\n        } else {\r\n            this._startDragRay.origin.copyFrom(this._scene.activeCamera.position);\r\n            this.attachedNode.getWorldMatrix().getTranslationToRef(this._tmpVector);\r\n            this._tmpVector.subtractToRef(this._scene.activeCamera.position, this._startDragRay.direction);\r\n        }\r\n\r\n        this._updateDragPlanePosition(this._startDragRay, startPickedPoint ? startPickedPoint : this._tmpVector);\r\n\r\n        const pickedPoint = this._pickWithRayOnDragPlane(this._startDragRay);\r\n        if (pickedPoint) {\r\n            this.dragging = true;\r\n            this.currentDraggingPointerId = pointerId;\r\n            this.lastDragPosition.copyFrom(pickedPoint);\r\n            this.onDragStartObservable.notifyObservers({ dragPlanePoint: pickedPoint, pointerId: this.currentDraggingPointerId, pointerInfo: this._activePointerInfo });\r\n            this._targetPosition.copyFrom(this.attachedNode.getAbsolutePosition());\r\n\r\n            // Detatch camera controls\r\n            if (this.detachCameraControls && this._scene.activeCamera && this._scene.activeCamera.inputs && !this._scene.activeCamera.leftCamera) {\r\n                if (this._scene.activeCamera.inputs.attachedToElement) {\r\n                    this._scene.activeCamera.detachControl();\r\n                    this._attachedToElement = true;\r\n                } else {\r\n                    this._attachedToElement = false;\r\n                }\r\n            }\r\n        } else {\r\n            this.releaseDrag();\r\n        }\r\n        PivotTools._RestorePivotPoint(this.attachedNode);\r\n    }\r\n\r\n    private _dragDelta = new Vector3();\r\n    protected _moveDrag(ray: Ray) {\r\n        this._moving = true;\r\n        const pickedPoint = this._pickWithRayOnDragPlane(ray);\r\n\r\n        if (pickedPoint) {\r\n            PivotTools._RemoveAndStorePivotPoint(this.attachedNode);\r\n\r\n            if (this.updateDragPlane) {\r\n                this._updateDragPlanePosition(ray, pickedPoint);\r\n            }\r\n            let dragLength = 0;\r\n            // depending on the drag mode option drag accordingly\r\n            if (this._options.dragAxis) {\r\n                // Convert local drag axis to world if useObjectOrientationForDragging\r\n                this.useObjectOrientationForDragging\r\n                    ? Vector3.TransformCoordinatesToRef(this._options.dragAxis, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._worldDragAxis)\r\n                    : this._worldDragAxis.copyFrom(this._options.dragAxis);\r\n                // Project delta drag from the drag plane onto the drag axis\r\n                pickedPoint.subtractToRef(this.lastDragPosition, this._tmpVector);\r\n\r\n                this._worldDragAxis.normalize();\r\n                dragLength = Vector3.Dot(this._tmpVector, this._worldDragAxis);\r\n                this._worldDragAxis.scaleToRef(dragLength, this._dragDelta);\r\n            } else {\r\n                dragLength = this._dragDelta.length();\r\n                pickedPoint.subtractToRef(this.lastDragPosition, this._dragDelta);\r\n            }\r\n            this._targetPosition.addInPlace(this._dragDelta);\r\n            this.onDragObservable.notifyObservers({\r\n                dragDistance: dragLength,\r\n                delta: this._dragDelta,\r\n                dragPlanePoint: pickedPoint,\r\n                dragPlaneNormal: this._dragPlane.forward,\r\n                pointerId: this.currentDraggingPointerId,\r\n                pointerInfo: this._activePointerInfo,\r\n            });\r\n            this.lastDragPosition.copyFrom(pickedPoint);\r\n\r\n            PivotTools._RestorePivotPoint(this.attachedNode);\r\n        }\r\n    }\r\n\r\n    private _pickWithRayOnDragPlane(ray: Nullable<Ray>) {\r\n        if (!ray) {\r\n            return null;\r\n        }\r\n\r\n        // Calculate angle between plane normal and ray\r\n        let angle = Math.acos(Vector3.Dot(this._dragPlane.forward, ray.direction));\r\n        // Correct if ray is casted from oposite side\r\n        if (angle > Math.PI / 2) {\r\n            angle = Math.PI - angle;\r\n        }\r\n\r\n        // If the angle is too perpendicular to the plane pick another point on the plane where it is looking\r\n        if (this.maxDragAngle > 0 && angle > this.maxDragAngle) {\r\n            if (this._useAlternatePickedPointAboveMaxDragAngle) {\r\n                // Invert ray direction along the towards object axis\r\n                this._tmpVector.copyFrom(ray.direction);\r\n                this.attachedNode.absolutePosition.subtractToRef(ray.origin, this._alternatePickedPoint);\r\n                this._alternatePickedPoint.normalize();\r\n                this._alternatePickedPoint.scaleInPlace(this._useAlternatePickedPointAboveMaxDragAngleDragSpeed * Vector3.Dot(this._alternatePickedPoint, this._tmpVector));\r\n                this._tmpVector.addInPlace(this._alternatePickedPoint);\r\n\r\n                // Project resulting vector onto the drag plane and add it to the attached nodes absolute position to get a picked point\r\n                const dot = Vector3.Dot(this._dragPlane.forward, this._tmpVector);\r\n                this._dragPlane.forward.scaleToRef(-dot, this._alternatePickedPoint);\r\n                this._alternatePickedPoint.addInPlace(this._tmpVector);\r\n                this._alternatePickedPoint.addInPlace(this.attachedNode.absolutePosition);\r\n                return this._alternatePickedPoint;\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        // use an infinite plane instead of ray picking a mesh that must be updated every frame\r\n        const planeNormal = this._dragPlane.forward;\r\n        const planePosition = this._dragPlane.position;\r\n        const dotProduct = ray.direction.dot(planeNormal);\r\n        if (Math.abs(dotProduct) < Epsilon) {\r\n            // Ray and plane are parallel, no intersection\r\n            return null;\r\n        }\r\n\r\n        planePosition.subtractToRef(ray.origin, TmpVectors.Vector3[0]);\r\n        const t = TmpVectors.Vector3[0].dot(planeNormal) / dotProduct;\r\n        // Ensure the intersection point is in front of the ray (t must be positive)\r\n        if (t < 0) {\r\n            // Intersection point is behind the ray\r\n            return null;\r\n        }\r\n\r\n        // Calculate the intersection point using the parameter t\r\n        ray.direction.scaleToRef(t, TmpVectors.Vector3[0]);\r\n        const intersectionPoint = ray.origin.add(TmpVectors.Vector3[0]);\r\n        return intersectionPoint;\r\n    }\r\n\r\n    // Variables to avoid instantiation in the below method\r\n    private _pointA = new Vector3(0, 0, 0);\r\n    private _pointC = new Vector3(0, 0, 0);\r\n    private _localAxis = new Vector3(0, 0, 0);\r\n    private _lookAt = new Vector3(0, 0, 0);\r\n    // Position the drag plane based on the attached mesh position, for single axis rotate the plane along the axis to face the camera\r\n    private _updateDragPlanePosition(ray: Ray, dragPlanePosition: Vector3) {\r\n        this._pointA.copyFrom(dragPlanePosition);\r\n        if (this._options.dragAxis) {\r\n            this.useObjectOrientationForDragging\r\n                ? Vector3.TransformCoordinatesToRef(this._options.dragAxis, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis)\r\n                : this._localAxis.copyFrom(this._options.dragAxis);\r\n\r\n            // Calculate plane normal that is the cross product of local axis and (eye-dragPlanePosition)\r\n            ray.origin.subtractToRef(this._pointA, this._pointC);\r\n            this._pointC.normalize();\r\n            if (Math.abs(Vector3.Dot(this._localAxis, this._pointC)) > 0.999) {\r\n                // the drag axis is colinear with the (eye to position) ray. The cross product will give jittered values.\r\n                // A new axis vector need to be computed\r\n                if (Math.abs(Vector3.Dot(Vector3.UpReadOnly, this._pointC)) > 0.999) {\r\n                    this._lookAt.copyFrom(Vector3.Right());\r\n                } else {\r\n                    this._lookAt.copyFrom(Vector3.UpReadOnly);\r\n                }\r\n            } else {\r\n                Vector3.CrossToRef(this._localAxis, this._pointC, this._lookAt);\r\n                // Get perpendicular line from previous result and drag axis to adjust lineB to be perpendicular to camera\r\n                Vector3.CrossToRef(this._localAxis, this._lookAt, this._lookAt);\r\n                this._lookAt.normalize();\r\n            }\r\n\r\n            this._dragPlane.position.copyFrom(this._pointA);\r\n            this._pointA.addToRef(this._lookAt, this._lookAt);\r\n            this._dragPlane.lookAt(this._lookAt);\r\n        } else if (this._options.dragPlaneNormal) {\r\n            this.useObjectOrientationForDragging\r\n                ? Vector3.TransformCoordinatesToRef(this._options.dragPlaneNormal, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis)\r\n                : this._localAxis.copyFrom(this._options.dragPlaneNormal);\r\n            this._dragPlane.position.copyFrom(this._pointA);\r\n            this._pointA.addToRef(this._localAxis, this._lookAt);\r\n            this._dragPlane.lookAt(this._lookAt);\r\n        } else {\r\n            if (this._scene.activeCamera) {\r\n                this._scene.activeCamera.getForwardRay().direction.normalizeToRef(this._localAxis);\r\n            }\r\n            this._dragPlane.position.copyFrom(this._pointA);\r\n            this._dragPlane.lookAt(this._pointA.add(this._localAxis));\r\n        }\r\n        // Update the position of the drag plane so it doesn't get out of sync with the node (eg. when moving back and forth quickly)\r\n        this._dragPlane.position.copyFrom(this.attachedNode.getAbsolutePosition());\r\n\r\n        this._dragPlane.computeWorldMatrix(true);\r\n    }\r\n\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        this._lastPointerRay = {};\r\n        if (this.attachedNode) {\r\n            this.attachedNode.isNearGrabbable = false;\r\n        }\r\n        if (this._pointerObserver) {\r\n            this._scene.onPointerObservable.remove(this._pointerObserver);\r\n        }\r\n        if (this._beforeRenderObserver) {\r\n            this._scene.onBeforeRenderObservable.remove(this._beforeRenderObserver);\r\n        }\r\n        if (this._dragPlane) {\r\n            this._dragPlane.dispose();\r\n        }\r\n        this.releaseDrag();\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["featureName", "HandConstraintZone", "HandConstraintOrientation", "HandConstraintVisibility", "SceneLoaderAnimationGroupLoadingMode", "_a", "request", "scene", "angle", "minMaxAngle", "virtualMeshesInfo", "pointerEvent", "GizmoAnchorPoint", "GizmoCoordinatesMode", "_a", "_b"]
}
