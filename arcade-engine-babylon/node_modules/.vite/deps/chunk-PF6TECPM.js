import {
  Logger
} from "./chunk-OJJXGLTO.js";
import {
  Color3,
  Color4
} from "./chunk-U2XMHILU.js";
import {
  Vector2,
  Vector3
} from "./chunk-4FZTLWAK.js";
import {
  Observable
} from "./chunk-GWFZRJMO.js";
import {
  RegisterClass
} from "./chunk-LMH7SWDS.js";

// node_modules/@babylonjs/core/Actions/action.js
var Action = class {
  /**
   * Creates a new Action
   * @param triggerOptions the trigger, with or without parameters, for the action
   * @param condition an optional determinant of action
   */
  constructor(triggerOptions, condition) {
    this.triggerOptions = triggerOptions;
    this.onBeforeExecuteObservable = new Observable();
    if (triggerOptions.parameter) {
      this.trigger = triggerOptions.trigger;
      this._triggerParameter = triggerOptions.parameter;
    } else if (triggerOptions.trigger) {
      this.trigger = triggerOptions.trigger;
    } else {
      this.trigger = triggerOptions;
    }
    this._nextActiveAction = this;
    this._condition = condition;
  }
  /**
   * Internal only
   * @internal
   */
  _prepare() {
  }
  /**
   * Gets the trigger parameter
   * @returns the trigger parameter
   */
  getTriggerParameter() {
    return this._triggerParameter;
  }
  /**
   * Sets the trigger parameter
   * @param value defines the new trigger parameter
   */
  setTriggerParameter(value) {
    this._triggerParameter = value;
  }
  /**
   * Internal only - Returns if the current condition allows to run the action
   * @internal
   */
  _evaluateConditionForCurrentFrame() {
    const condition = this._condition;
    if (!condition) {
      return true;
    }
    const currentRenderId = this._actionManager.getScene().getRenderId();
    if (condition._evaluationId !== currentRenderId) {
      condition._evaluationId = currentRenderId;
      condition._currentResult = condition.isValid();
    }
    return condition._currentResult;
  }
  /**
   * Internal only - executes current action event
   * @internal
   */
  _executeCurrent(evt) {
    const isConditionValid = this._evaluateConditionForCurrentFrame();
    if (!isConditionValid) {
      return;
    }
    this.onBeforeExecuteObservable.notifyObservers(this);
    this._nextActiveAction.execute(evt);
    this.skipToNextActiveAction();
  }
  /**
   * Execute placeholder for child classes
   * @param evt optional action event
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  execute(evt) {
  }
  /**
   * Skips to next active action
   */
  skipToNextActiveAction() {
    if (this._nextActiveAction._child) {
      if (!this._nextActiveAction._child._actionManager) {
        this._nextActiveAction._child._actionManager = this._actionManager;
      }
      this._nextActiveAction = this._nextActiveAction._child;
    } else {
      this._nextActiveAction = this;
    }
  }
  /**
   * Adds action to chain of actions, may be a DoNothingAction
   * @param action defines the next action to execute
   * @returns The action passed in
   * @see https://www.babylonjs-playground.com/#1T30HR#0
   */
  then(action) {
    this._child = action;
    action._actionManager = this._actionManager;
    action._prepare();
    return action;
  }
  /**
   * Internal only
   * @internal
   */
  _getProperty(propertyPath) {
    return this._actionManager._getProperty(propertyPath);
  }
  /**
   * @internal
   */
  _getEffectiveTarget(target, propertyPath) {
    return this._actionManager._getEffectiveTarget(target, propertyPath);
  }
  /**
   * Serialize placeholder for child classes
   * @param parent of child
   * @returns the serialized object
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  serialize(parent) {
    return null;
  }
  /**
   * Internal only called by serialize
   * @internal
   */
  _serialize(serializedAction, parent) {
    const serializationObject = {
      type: 1,
      children: [],
      name: serializedAction.name,
      properties: serializedAction.properties || []
    };
    if (this._child) {
      this._child.serialize(serializationObject);
    }
    if (this._condition) {
      const serializedCondition = this._condition.serialize();
      serializedCondition.children.push(serializationObject);
      if (parent) {
        parent.children.push(serializedCondition);
      }
      return serializedCondition;
    }
    if (parent) {
      parent.children.push(serializationObject);
    }
    return serializationObject;
  }
};
Action._SerializeValueAsString = (value) => {
  if (typeof value === "number") {
    return value.toString();
  }
  if (typeof value === "boolean") {
    return value ? "true" : "false";
  }
  if (value instanceof Vector2) {
    return value.x + ", " + value.y;
  }
  if (value instanceof Vector3) {
    return value.x + ", " + value.y + ", " + value.z;
  }
  if (value instanceof Color3) {
    return value.r + ", " + value.g + ", " + value.b;
  }
  if (value instanceof Color4) {
    return value.r + ", " + value.g + ", " + value.b + ", " + value.a;
  }
  return value;
};
Action._GetTargetProperty = (target) => {
  return {
    name: "target",
    targetType: target._isMesh ? "MeshProperties" : target._isLight ? "LightProperties" : target._isCamera ? "CameraProperties" : target._isMaterial ? "MaterialProperties" : "SceneProperties",
    value: target._isScene ? "Scene" : target.name
  };
};
RegisterClass("BABYLON.Action", Action);

// node_modules/@babylonjs/core/Actions/directActions.js
var SwitchBooleanAction = class extends Action {
  /**
   * Instantiate the action
   * @param triggerOptions defines the trigger options
   * @param target defines the object containing the boolean
   * @param propertyPath defines the path to the boolean property in the target object
   * @param condition defines the trigger related conditions
   */
  constructor(triggerOptions, target, propertyPath, condition) {
    super(triggerOptions, condition);
    this.propertyPath = propertyPath;
    this._target = this._effectiveTarget = target;
  }
  /** @internal */
  _prepare() {
    this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);
    this._property = this._getProperty(this.propertyPath);
  }
  /**
   * Execute the action toggle the boolean value.
   */
  execute() {
    this._effectiveTarget[this._property] = !this._effectiveTarget[this._property];
  }
  /**
   * Serializes the actions and its related information.
   * @param parent defines the object to serialize in
   * @returns the serialized object
   */
  serialize(parent) {
    return super._serialize({
      name: "SwitchBooleanAction",
      properties: [Action._GetTargetProperty(this._target), { name: "propertyPath", value: this.propertyPath }]
    }, parent);
  }
};
var SetStateAction = class extends Action {
  /**
   * Instantiate the action
   * @param triggerOptions defines the trigger options
   * @param target defines the object containing the state property
   * @param value defines the value to store in the state field
   * @param condition defines the trigger related conditions
   */
  constructor(triggerOptions, target, value, condition) {
    super(triggerOptions, condition);
    this.value = value;
    this._target = target;
  }
  /**
   * Execute the action and store the value on the target state property.
   */
  execute() {
    this._target.state = this.value;
  }
  /**
   * Serializes the actions and its related information.
   * @param parent defines the object to serialize in
   * @returns the serialized object
   */
  serialize(parent) {
    return super._serialize({
      name: "SetStateAction",
      properties: [Action._GetTargetProperty(this._target), { name: "value", value: this.value }]
    }, parent);
  }
};
var SetValueAction = class extends Action {
  /**
   * Instantiate the action
   * @param triggerOptions defines the trigger options
   * @param target defines the object containing the property
   * @param propertyPath defines the path of the property to set in the target
   * @param value defines the value to set in the property
   * @param condition defines the trigger related conditions
   */
  constructor(triggerOptions, target, propertyPath, value, condition) {
    super(triggerOptions, condition);
    this.propertyPath = propertyPath;
    this.value = value;
    this._target = this._effectiveTarget = target;
  }
  /** @internal */
  _prepare() {
    this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);
    this._property = this._getProperty(this.propertyPath);
  }
  /**
   * Execute the action and set the targeted property to the desired value.
   */
  execute() {
    this._effectiveTarget[this._property] = this.value;
    if (this._target.markAsDirty) {
      this._target.markAsDirty(this._property);
    }
  }
  /**
   * Serializes the actions and its related information.
   * @param parent defines the object to serialize in
   * @returns the serialized object
   */
  serialize(parent) {
    return super._serialize({
      name: "SetValueAction",
      properties: [
        Action._GetTargetProperty(this._target),
        { name: "propertyPath", value: this.propertyPath },
        { name: "value", value: Action._SerializeValueAsString(this.value) }
      ]
    }, parent);
  }
};
var IncrementValueAction = class extends Action {
  /**
   * Instantiate the action
   * @param triggerOptions defines the trigger options
   * @param target defines the object containing the property
   * @param propertyPath defines the path of the property to increment in the target
   * @param value defines the value value we should increment the property by
   * @param condition defines the trigger related conditions
   */
  constructor(triggerOptions, target, propertyPath, value, condition) {
    super(triggerOptions, condition);
    this.propertyPath = propertyPath;
    this.value = value;
    this._target = this._effectiveTarget = target;
  }
  /** @internal */
  _prepare() {
    this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);
    this._property = this._getProperty(this.propertyPath);
    if (typeof this._effectiveTarget[this._property] !== "number") {
      Logger.Warn("Warning: IncrementValueAction can only be used with number values");
    }
  }
  /**
   * Execute the action and increment the target of the value amount.
   */
  execute() {
    this._effectiveTarget[this._property] += this.value;
    if (this._target.markAsDirty) {
      this._target.markAsDirty(this._property);
    }
  }
  /**
   * Serializes the actions and its related information.
   * @param parent defines the object to serialize in
   * @returns the serialized object
   */
  serialize(parent) {
    return super._serialize({
      name: "IncrementValueAction",
      properties: [
        Action._GetTargetProperty(this._target),
        { name: "propertyPath", value: this.propertyPath },
        { name: "value", value: Action._SerializeValueAsString(this.value) }
      ]
    }, parent);
  }
};
var PlayAnimationAction = class extends Action {
  /**
   * Instantiate the action
   * @param triggerOptions defines the trigger options
   * @param target defines the target animation or animation name
   * @param from defines from where the animation should start (animation frame)
   * @param to defines where the animation should stop (animation frame)
   * @param loop defines if the animation should loop or stop after the first play
   * @param condition defines the trigger related conditions
   */
  constructor(triggerOptions, target, from, to, loop, condition) {
    super(triggerOptions, condition);
    this.from = from;
    this.to = to;
    this.loop = loop;
    this._target = target;
  }
  /** @internal */
  _prepare() {
  }
  /**
   * Execute the action and play the animation.
   */
  execute() {
    const scene = this._actionManager.getScene();
    scene.beginAnimation(this._target, this.from, this.to, this.loop);
  }
  /**
   * Serializes the actions and its related information.
   * @param parent defines the object to serialize in
   * @returns the serialized object
   */
  serialize(parent) {
    return super._serialize({
      name: "PlayAnimationAction",
      properties: [
        Action._GetTargetProperty(this._target),
        { name: "from", value: String(this.from) },
        { name: "to", value: String(this.to) },
        { name: "loop", value: Action._SerializeValueAsString(this.loop) || false }
      ]
    }, parent);
  }
};
var StopAnimationAction = class extends Action {
  /**
   * Instantiate the action
   * @param triggerOptions defines the trigger options
   * @param target defines the target animation or animation name
   * @param condition defines the trigger related conditions
   */
  constructor(triggerOptions, target, condition) {
    super(triggerOptions, condition);
    this._target = target;
  }
  /** @internal */
  _prepare() {
  }
  /**
   * Execute the action and stop the animation.
   */
  execute() {
    const scene = this._actionManager.getScene();
    scene.stopAnimation(this._target);
  }
  /**
   * Serializes the actions and its related information.
   * @param parent defines the object to serialize in
   * @returns the serialized object
   */
  serialize(parent) {
    return super._serialize({
      name: "StopAnimationAction",
      properties: [Action._GetTargetProperty(this._target)]
    }, parent);
  }
};
var DoNothingAction = class extends Action {
  /**
   * Instantiate the action
   * @param triggerOptions defines the trigger options
   * @param condition defines the trigger related conditions
   */
  constructor(triggerOptions = 0, condition) {
    super(triggerOptions, condition);
  }
  /**
   * Execute the action and do nothing.
   */
  execute() {
  }
  /**
   * Serializes the actions and its related information.
   * @param parent defines the object to serialize in
   * @returns the serialized object
   */
  serialize(parent) {
    return super._serialize({
      name: "DoNothingAction",
      properties: []
    }, parent);
  }
};
var CombineAction = class extends Action {
  /**
   * Instantiate the action
   * @param triggerOptions defines the trigger options
   * @param children defines the list of aggregated animations to run
   * @param condition defines the trigger related conditions
   * @param enableChildrenConditions defines if the children actions conditions should be check before execution
   */
  constructor(triggerOptions, children, condition, enableChildrenConditions = true) {
    super(triggerOptions, condition);
    this.children = children;
    this.enableChildrenConditions = enableChildrenConditions;
  }
  /** @internal */
  _prepare() {
    for (let index = 0; index < this.children.length; index++) {
      this.children[index]._actionManager = this._actionManager;
      this.children[index]._prepare();
    }
  }
  /**
   * Execute the action and executes all the aggregated actions.
   * @param evt event to execute
   */
  execute(evt) {
    for (const action of this.children) {
      if (!this.enableChildrenConditions || action._evaluateConditionForCurrentFrame()) {
        action.execute(evt);
      }
    }
  }
  /**
   * Serializes the actions and its related information.
   * @param parent defines the object to serialize in
   * @returns the serialized object
   */
  serialize(parent) {
    const serializationObject = super._serialize({
      name: "CombineAction",
      properties: [],
      combine: []
    }, parent);
    for (let i = 0; i < this.children.length; i++) {
      serializationObject.combine.push(this.children[i].serialize(null));
    }
    return serializationObject;
  }
};
var ExecuteCodeAction = class extends Action {
  /**
   * Instantiate the action
   * @param triggerOptions defines the trigger options
   * @param func defines the callback function to run
   * @param condition defines the trigger related conditions
   */
  constructor(triggerOptions, func, condition) {
    super(triggerOptions, condition);
    this.func = func;
  }
  /**
   * Execute the action and run the attached code.
   * @param evt event to execute
   */
  execute(evt) {
    this.func(evt);
  }
};
var SetParentAction = class extends Action {
  /**
   * Instantiate the action
   * @param triggerOptions defines the trigger options
   * @param target defines the target containing the parent property
   * @param parent defines from where the animation should start (animation frame)
   * @param condition defines the trigger related conditions
   */
  constructor(triggerOptions, target, parent, condition) {
    super(triggerOptions, condition);
    this._target = target;
    this._parent = parent;
  }
  /** @internal */
  _prepare() {
  }
  /**
   * Execute the action and set the parent property.
   */
  execute() {
    if (this._target.parent === this._parent) {
      return;
    }
    const invertParentWorldMatrix = this._parent.getWorldMatrix().clone();
    invertParentWorldMatrix.invert();
    this._target.position = Vector3.TransformCoordinates(this._target.position, invertParentWorldMatrix);
    this._target.parent = this._parent;
  }
  /**
   * Serializes the actions and its related information.
   * @param parent defines the object to serialize in
   * @returns the serialized object
   */
  serialize(parent) {
    return super._serialize({
      name: "SetParentAction",
      properties: [Action._GetTargetProperty(this._target), Action._GetTargetProperty(this._parent)]
    }, parent);
  }
};
RegisterClass("BABYLON.SetParentAction", SetParentAction);
RegisterClass("BABYLON.ExecuteCodeAction", ExecuteCodeAction);
RegisterClass("BABYLON.DoNothingAction", DoNothingAction);
RegisterClass("BABYLON.StopAnimationAction", StopAnimationAction);
RegisterClass("BABYLON.PlayAnimationAction", PlayAnimationAction);
RegisterClass("BABYLON.IncrementValueAction", IncrementValueAction);
RegisterClass("BABYLON.SetValueAction", SetValueAction);
RegisterClass("BABYLON.SetStateAction", SetStateAction);
RegisterClass("BABYLON.SetParentAction", SetParentAction);
RegisterClass("BABYLON.SwitchBooleanAction", SwitchBooleanAction);
RegisterClass("BABYLON.CombineAction", CombineAction);

export {
  Action,
  SwitchBooleanAction,
  SetStateAction,
  SetValueAction,
  IncrementValueAction,
  PlayAnimationAction,
  StopAnimationAction,
  DoNothingAction,
  CombineAction,
  ExecuteCodeAction,
  SetParentAction
};
//# sourceMappingURL=chunk-PF6TECPM.js.map
