import {
  AdvancedDynamicTexture,
  AdvancedDynamicTextureInstrumentation,
  BaseGradient,
  BaseSlider,
  Button,
  Checkbox,
  CheckboxGroup,
  ColorPicker,
  Container,
  Control,
  DisplayGrid,
  Ellipse,
  FocusableButton,
  FrameGraphGUITask,
  Grid,
  Image,
  ImageBasedSlider,
  ImageScrollBar,
  InputPassword,
  InputText,
  InputTextArea,
  KeyPropertySet,
  Line,
  LinearGradient,
  MathTools,
  Matrix2D,
  Measure,
  MultiLine,
  MultiLinePoint,
  NodeRenderGraphGUIBlock,
  RadialGradient,
  RadioButton,
  RadioGroup,
  Rectangle,
  ScrollBar,
  ScrollViewer,
  SelectionPanel,
  SelectorGroup,
  Slider,
  SliderGroup,
  StackPanel,
  Style,
  TextBlock,
  TextWrapper,
  TextWrapping,
  ToggleButton,
  ValueAndUnit,
  Vector2WithInfo,
  VirtualKeyboard,
  XmlLoader,
  name
} from "./chunk-2LITGB2K.js";
import {
  BaseSixDofDragBehavior,
  FadeInOutBehavior,
  FollowBehavior,
  Gizmo,
  HandConstraintBehavior,
  PivotTools,
  PointerDragBehavior,
  Scalar,
  SceneLoader,
  SixDofDragBehavior,
  SurfaceMagnetismBehavior,
  UtilityLayerRenderer
} from "./chunk-4EGWVJC7.js";
import {
  AnimationGroup
} from "./chunk-E7ADST2D.js";
import "./chunk-KFOE3IAG.js";
import {
  Animation
} from "./chunk-TUHL35NE.js";
import {
  Constants
} from "./chunk-WEVR5FGZ.js";
import {
  MaterialDefines,
  StandardMaterial
} from "./chunk-G4XM5GPZ.js";
import "./chunk-4JNS43TI.js";
import "./chunk-SVOYENBZ.js";
import {
  CreateBox,
  CreatePlane,
  ShaderMaterial
} from "./chunk-YNUOXOE2.js";
import {
  Mesh
} from "./chunk-ZNUSQ4HW.js";
import {
  AbstractMesh,
  TransformNode,
  VertexData
} from "./chunk-EB6Z7H3C.js";
import {
  EffectFallbacks,
  PushMaterial
} from "./chunk-A36SOHOT.js";
import {
  Texture
} from "./chunk-KEAGEMAY.js";
import "./chunk-AZ7ITQQF.js";
import {
  HandleFallbacksForShadows,
  PrepareAttributesForInstances,
  PrepareDefinesForAttributes,
  PrepareUniformsAndSamplersList
} from "./chunk-QZDP5VDB.js";
import "./chunk-5AQS7OFY.js";
import "./chunk-BMUDXUCN.js";
import "./chunk-D6TYAGYM.js";
import "./chunk-D7ZGTD65.js";
import "./chunk-VEJWL4DR.js";
import "./chunk-YC7U4GEU.js";
import "./chunk-YQW3U5C7.js";
import "./chunk-BYGPOSYT.js";
import "./chunk-WKXRXUEO.js";
import "./chunk-E4RC5JBY.js";
import {
  VertexBuffer
} from "./chunk-SGWWALOD.js";
import "./chunk-LJSODA3L.js";
import "./chunk-I2PO3XEU.js";
import "./chunk-3K4DIDWO.js";
import "./chunk-BAGGFIFW.js";
import {
  PointerEventTypes
} from "./chunk-2QGSP72X.js";
import "./chunk-6NEHHYC7.js";
import {
  Viewport
} from "./chunk-5LTYGTJL.js";
import "./chunk-SZB5QSYK.js";
import "./chunk-FQPHW5Y5.js";
import "./chunk-4PADJKRJ.js";
import {
  Axis
} from "./chunk-QHH6DDKY.js";
import "./chunk-F7GYARAY.js";
import {
  HemisphericLight
} from "./chunk-Y7PMIX7Z.js";
import "./chunk-FWVUTNBJ.js";
import "./chunk-HWNH73LD.js";
import "./chunk-ZXVFJ3IO.js";
import "./chunk-TBN5BH3M.js";
import {
  Tools
} from "./chunk-MGWIDVXV.js";
import "./chunk-BC6V5D55.js";
import {
  SerializationHelper
} from "./chunk-HLXCXV77.js";
import {
  __decorate,
  expandToProperty,
  serialize,
  serializeAsColor3,
  serializeAsColor4,
  serializeAsTexture,
  serializeAsVector3
} from "./chunk-S2HVPJYT.js";
import "./chunk-NDLZWJHM.js";
import "./chunk-2ZEUD233.js";
import "./chunk-IW7YW5OA.js";
import "./chunk-VFWUTG4V.js";
import "./chunk-4GUORC2E.js";
import {
  IsDocumentAvailable
} from "./chunk-AZNEH5GV.js";
import {
  ShaderStore
} from "./chunk-FX6MN5HL.js";
import "./chunk-QPP7FIQR.js";
import {
  Logger
} from "./chunk-OJJXGLTO.js";
import {
  Color3,
  Color4,
  TmpColors
} from "./chunk-U2XMHILU.js";
import {
  Matrix,
  Quaternion,
  TmpVectors,
  Vector2,
  Vector3,
  Vector4
} from "./chunk-4FZTLWAK.js";
import {
  EngineStore
} from "./chunk-AYMFJBP3.js";
import {
  Observable
} from "./chunk-GWFZRJMO.js";
import {
  Epsilon
} from "./chunk-AQLPQ2Z4.js";
import {
  RegisterClass
} from "./chunk-LMH7SWDS.js";
import "./chunk-SHOW5Q5T.js";
import "./chunk-5FUTL2UF.js";

// node_modules/@babylonjs/gui/3D/vector3WithInfo.js
var Vector3WithInfo = class extends Vector3 {
  /**
   * Creates a new Vector3WithInfo
   * @param source defines the vector3 data to transport
   * @param buttonIndex defines the current mouse button index
   */
  constructor(source, buttonIndex = 0) {
    super(source.x, source.y, source.z);
    this.buttonIndex = buttonIndex;
  }
};

// node_modules/@babylonjs/gui/3D/controls/control3D.js
var Control3D = class {
  /** Gets or sets the control position in world space */
  get position() {
    if (!this._node) {
      this._position = this._position || Vector3.Zero();
      return this._position;
    }
    return this._node.position;
  }
  set position(value) {
    this._position = value;
    if (!this._node) {
      return;
    }
    this._node.position = this._position;
  }
  /** Gets or sets the control scaling in world space */
  get scaling() {
    if (!this._node) {
      this._scaling = this.scaling || new Vector3(1, 1, 1);
      return this._scaling;
    }
    return this._node.scaling;
  }
  set scaling(value) {
    this._scaling = value;
    if (!this._node) {
      return;
    }
    this._isScaledByManager = false;
    this._node.scaling = this._scaling;
  }
  /**
   * Gets the list of attached behaviors
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
   */
  get behaviors() {
    return this._behaviors;
  }
  /**
   * Attach a behavior to the control
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
   * @param behavior defines the behavior to attach
   * @returns the current control
   */
  addBehavior(behavior) {
    const index = this._behaviors.indexOf(behavior);
    if (index !== -1) {
      return this;
    }
    behavior.init();
    const scene = this._host.scene;
    if (scene.isLoading) {
      scene.onDataLoadedObservable.addOnce(() => {
        behavior.attach(this);
      });
    } else {
      behavior.attach(this);
    }
    this._behaviors.push(behavior);
    return this;
  }
  /**
   * Remove an attached behavior
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
   * @param behavior defines the behavior to attach
   * @returns the current control
   */
  removeBehavior(behavior) {
    const index = this._behaviors.indexOf(behavior);
    if (index === -1) {
      return this;
    }
    this._behaviors[index].detach();
    this._behaviors.splice(index, 1);
    return this;
  }
  /**
   * Gets an attached behavior by name
   * @param name defines the name of the behavior to look for
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
   * @returns null if behavior was not found else the requested behavior
   */
  getBehaviorByName(name22) {
    for (const behavior of this._behaviors) {
      if (behavior.name === name22) {
        return behavior;
      }
    }
    return null;
  }
  /** Gets or sets a boolean indicating if the control is visible */
  get isVisible() {
    return this._isVisible;
  }
  set isVisible(value) {
    if (this._isVisible === value) {
      return;
    }
    this._isVisible = value;
    const mesh = this.mesh;
    if (mesh) {
      mesh.setEnabled(value);
    }
  }
  /**
   * Creates a new control
   * @param name defines the control name
   */
  constructor(name22) {
    this.name = name22;
    this._downCount = 0;
    this._enterCount = -1;
    this._downPointerIds = {};
    this._isVisible = true;
    this._isScaledByManager = false;
    this.onPointerMoveObservable = new Observable();
    this.onPointerOutObservable = new Observable();
    this.onPointerDownObservable = new Observable();
    this.onPointerUpObservable = new Observable();
    this.onPointerClickObservable = new Observable();
    this.onPointerEnterObservable = new Observable();
    this._behaviors = new Array();
  }
  /**
   * Gets a string representing the class name
   */
  get typeName() {
    return this._getTypeName();
  }
  /**
   * Get the current class name of the control.
   * @returns current class name
   */
  getClassName() {
    return this._getTypeName();
  }
  _getTypeName() {
    return "Control3D";
  }
  /**
   * Gets the transform node used by this control
   */
  get node() {
    return this._node;
  }
  /**
   * Gets the mesh used to render this control
   */
  get mesh() {
    if (this._node instanceof AbstractMesh) {
      return this._node;
    }
    return null;
  }
  /**
   * Link the control as child of the given node
   * @param node defines the node to link to. Use null to unlink the control
   * @returns the current control
   */
  linkToTransformNode(node) {
    if (this._node) {
      this._node.parent = node;
    }
    return this;
  }
  /**
   * @internal
   */
  _prepareNode(scene) {
    if (!this._node) {
      this._node = this._createNode(scene);
      if (!this.node) {
        return;
      }
      if (this._position) {
        this.node.position = this._position;
      }
      if (this._scaling) {
        this.node.scaling = this._scaling;
      }
      this._injectGUI3DReservedDataStore(this.node).control = this;
      const mesh = this.mesh;
      if (mesh) {
        mesh.isPickable = true;
        this._affectMaterial(mesh);
      }
    }
  }
  _injectGUI3DReservedDataStore(node) {
    node.reservedDataStore = node.reservedDataStore ?? {};
    node.reservedDataStore.GUI3D = node.reservedDataStore.GUI3D ?? {};
    return node.reservedDataStore.GUI3D;
  }
  /**
   * Node creation.
   * Can be overriden by children
   * @param scene defines the scene where the node must be attached
   * @returns the attached node or null if none. Must return a Mesh or AbstractMesh if there is an attached visible object
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _createNode(scene) {
    return null;
  }
  /**
   * Affect a material to the given mesh
   * @param mesh defines the mesh which will represent the control
   */
  _affectMaterial(mesh) {
    mesh.material = null;
  }
  _isTouchButton3D(control) {
    return control._generatePointerEventType !== void 0;
  }
  // Pointers
  /**
   * @internal
   */
  _onPointerMove(target, coordinates) {
    this.onPointerMoveObservable.notifyObservers(coordinates, -1, target, this);
  }
  /**
   * @internal
   */
  _onPointerEnter(target) {
    if (this._enterCount === -1) {
      this._enterCount = 0;
    }
    this._enterCount++;
    if (this._enterCount > 1) {
      return false;
    }
    this.onPointerEnterObservable.notifyObservers(this, -1, target, this);
    if (this.pointerEnterAnimation) {
      this.pointerEnterAnimation();
    }
    return true;
  }
  /**
   * @internal
   */
  _onPointerOut(target) {
    this._enterCount--;
    if (this._enterCount > 0) {
      return;
    }
    this._enterCount = 0;
    this.onPointerOutObservable.notifyObservers(this, -1, target, this);
    if (this.pointerOutAnimation) {
      this.pointerOutAnimation();
    }
  }
  /**
   * @internal
   */
  _onPointerDown(target, coordinates, pointerId, buttonIndex) {
    this._downCount++;
    this._downPointerIds[pointerId] = this._downPointerIds[pointerId] + 1 || 1;
    if (this._downCount !== 1) {
      return false;
    }
    this.onPointerDownObservable.notifyObservers(new Vector3WithInfo(coordinates, buttonIndex), -1, target, this);
    if (this.pointerDownAnimation) {
      this.pointerDownAnimation();
    }
    return true;
  }
  /**
   * @internal
   */
  _onPointerUp(target, coordinates, pointerId, buttonIndex, notifyClick) {
    this._downCount--;
    this._downPointerIds[pointerId]--;
    if (this._downPointerIds[pointerId] <= 0) {
      delete this._downPointerIds[pointerId];
    }
    if (this._downCount < 0) {
      this._downCount = 0;
      return;
    }
    if (this._downCount == 0) {
      if (notifyClick && (this._enterCount > 0 || this._enterCount === -1)) {
        this.onPointerClickObservable.notifyObservers(new Vector3WithInfo(coordinates, buttonIndex), -1, target, this);
      }
      this.onPointerUpObservable.notifyObservers(new Vector3WithInfo(coordinates, buttonIndex), -1, target, this);
      if (this.pointerUpAnimation) {
        this.pointerUpAnimation();
      }
    }
  }
  /**
   * @internal
   */
  forcePointerUp(pointerId = null) {
    if (pointerId !== null) {
      this._onPointerUp(this, Vector3.Zero(), pointerId, 0, true);
    } else {
      for (const key in this._downPointerIds) {
        this._onPointerUp(this, Vector3.Zero(), +key, 0, true);
      }
      if (this._downCount > 0) {
        this._downCount = 1;
        this._onPointerUp(this, Vector3.Zero(), 0, 0, true);
      }
    }
  }
  /**
   * @internal
   */
  _processObservables(type, pickedPoint, originMeshPosition, pointerId, buttonIndex) {
    if (this._isTouchButton3D(this) && originMeshPosition) {
      type = this._generatePointerEventType(type, originMeshPosition, this._downCount);
    }
    if (type === PointerEventTypes.POINTERMOVE) {
      this._onPointerMove(this, pickedPoint);
      const previousControlOver = this._host._lastControlOver[pointerId];
      if (previousControlOver && previousControlOver !== this) {
        previousControlOver._onPointerOut(this);
      }
      if (previousControlOver !== this) {
        this._onPointerEnter(this);
      }
      this._host._lastControlOver[pointerId] = this;
      return true;
    }
    if (type === PointerEventTypes.POINTERDOWN) {
      this._onPointerDown(this, pickedPoint, pointerId, buttonIndex);
      this._host._lastControlDown[pointerId] = this;
      this._host._lastPickedControl = this;
      return true;
    }
    if (type === PointerEventTypes.POINTERUP || type === PointerEventTypes.POINTERDOUBLETAP) {
      if (this._host._lastControlDown[pointerId]) {
        this._host._lastControlDown[pointerId]._onPointerUp(this, pickedPoint, pointerId, buttonIndex, true);
      }
      delete this._host._lastControlDown[pointerId];
      return true;
    }
    return false;
  }
  /** @internal */
  _disposeNode() {
    if (this._node) {
      this._node.dispose();
      this._node = null;
    }
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    this.onPointerDownObservable.clear();
    this.onPointerEnterObservable.clear();
    this.onPointerMoveObservable.clear();
    this.onPointerOutObservable.clear();
    this.onPointerUpObservable.clear();
    this.onPointerClickObservable.clear();
    this._disposeNode();
    for (const behavior of this._behaviors) {
      behavior.detach();
    }
  }
};

// node_modules/@babylonjs/gui/3D/controls/contentDisplay3D.js
var ContentDisplay3D = class extends Control3D {
  constructor() {
    super(...arguments);
    this._contentResolution = 512;
    this._contentScaleRatio = 2;
  }
  /**
   * Gets or sets the GUI 2D content used to display the button's facade
   */
  get content() {
    return this._content;
  }
  set content(value) {
    this._content = value;
    if (!value || !this._host || !this._host.utilityLayer) {
      return;
    }
    if (!this._facadeTexture) {
      const width = typeof this._contentResolution === "number" ? this._contentResolution : this._contentResolution.width;
      const height = typeof this._contentResolution === "number" ? this._contentResolution : this._contentResolution.height;
      this._facadeTexture = new AdvancedDynamicTexture("Facade", width, height, this._host.utilityLayer.utilityLayerScene, true, Texture.TRILINEAR_SAMPLINGMODE);
      this._setFacadeTextureScaling();
      this._facadeTexture.premulAlpha = true;
    } else {
      this._facadeTexture.rootContainer.clearControls();
    }
    this._facadeTexture.addControl(value);
    this._applyFacade(this._facadeTexture);
  }
  _setFacadeTextureScaling() {
    if (this._facadeTexture) {
      if (typeof this._contentResolution !== "number") {
        this._contentScaleRatioY = this._contentResolution.height / this._contentResolution.width * this._contentScaleRatio;
      }
      this._facadeTexture.rootContainer.scaleX = this._contentScaleRatio;
      this._facadeTexture.rootContainer.scaleY = this._contentScaleRatioY ?? this._contentScaleRatio;
    }
  }
  /**
   * Gets or sets the texture resolution used to render content (512 by default)
   */
  get contentResolution() {
    return this._contentResolution;
  }
  set contentResolution(value) {
    const incomingWidth = typeof value === "number" ? value : value.width;
    const incomingHeight = typeof value === "number" ? value : value.height;
    const currentWidth = typeof this._contentResolution === "number" ? this._contentResolution : this._contentResolution.width;
    const currentHeight = typeof this._contentResolution === "number" ? this._contentResolution : this._contentResolution.height;
    if (incomingWidth === currentWidth && incomingHeight === currentHeight) {
      return;
    }
    this._contentResolution = value;
    this._resetContent();
  }
  _disposeFacadeTexture() {
    if (this._facadeTexture) {
      this._facadeTexture.dispose();
      this._facadeTexture = null;
    }
  }
  _resetContent() {
    this._disposeFacadeTexture();
    this.content = this._content;
  }
  /**
   * Apply the facade texture (created from the content property).
   * This function can be overloaded by child classes
   * @param facadeTexture defines the AdvancedDynamicTexture to use
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _applyFacade(facadeTexture) {
  }
};

// node_modules/@babylonjs/gui/3D/controls/abstractButton3D.js
var AbstractButton3D = class extends ContentDisplay3D {
  /**
   * Creates a new button
   * @param name defines the control name
   */
  constructor(name22) {
    super(name22);
  }
  _getTypeName() {
    return "AbstractButton3D";
  }
  // Mesh association
  _createNode(scene) {
    return new TransformNode("button" + this.name, scene);
  }
};

// node_modules/@babylonjs/gui/3D/controls/button3D.js
var Button3D = class extends AbstractButton3D {
  /**
   * Creates a new button
   * @param name defines the control name
   * @param options defines the options used to create the button
   */
  constructor(name22, options) {
    super(name22);
    this._options = {
      width: 1,
      height: 1,
      depth: 0.08,
      ...options
    };
    this.pointerEnterAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this._currentMaterial.emissiveColor = Color3.Red();
    };
    this.pointerOutAnimation = () => {
      this._currentMaterial.emissiveColor = Color3.Black();
    };
    this.pointerDownAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this.mesh.scaling.scaleInPlace(0.95);
    };
    this.pointerUpAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this.mesh.scaling.scaleInPlace(1 / 0.95);
    };
  }
  /**
   * Apply the facade texture (created from the content property).
   * @param facadeTexture defines the AdvancedDynamicTexture to use
   */
  _applyFacade(facadeTexture) {
    this._currentMaterial.emissiveTexture = facadeTexture;
  }
  _getTypeName() {
    return "Button3D";
  }
  // Mesh association
  _createNode(scene) {
    const faceUV = new Array(6);
    for (let i = 0; i < 6; i++) {
      faceUV[i] = new Vector4(0, 0, 0, 0);
    }
    if (scene.useRightHandedSystem) {
      faceUV[0].copyFromFloats(1, 0, 0, 1);
    } else {
      faceUV[1].copyFromFloats(0, 0, 1, 1);
    }
    const mesh = CreateBox(this.name + "_rootMesh", {
      width: this._options.width,
      height: this._options.height,
      depth: this._options.depth,
      faceUV,
      wrap: true
    }, scene);
    this._contentScaleRatioY = this._contentScaleRatio * this._options.width / this._options.height;
    this._setFacadeTextureScaling();
    return mesh;
  }
  _affectMaterial(mesh) {
    const material = new StandardMaterial(this.name + "Material", mesh.getScene());
    material.specularColor = Color3.Black();
    mesh.material = material;
    this._currentMaterial = material;
    this._resetContent();
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    super.dispose();
    this._disposeFacadeTexture();
    if (this._currentMaterial) {
      this._currentMaterial.dispose();
    }
  }
};

// node_modules/@babylonjs/gui/3D/controls/container3D.js
var Container3D = class extends Control3D {
  /**
   * Gets the list of child controls
   */
  get children() {
    return this._children;
  }
  /**
   * Gets or sets a boolean indicating if the layout must be blocked (default is false).
   * This is helpful to optimize layout operation when adding multiple children in a row
   */
  get blockLayout() {
    return this._blockLayout;
  }
  set blockLayout(value) {
    if (this._blockLayout === value) {
      return;
    }
    this._blockLayout = value;
    if (!this._blockLayout) {
      this._arrangeChildren();
    }
  }
  /**
   * Creates a new container
   * @param name defines the container name
   */
  constructor(name22) {
    super(name22);
    this._blockLayout = false;
    this._children = new Array();
  }
  /**
   * Force the container to update the layout. Please note that it will not take blockLayout property in account
   * @returns the current container
   */
  updateLayout() {
    this._arrangeChildren();
    return this;
  }
  /**
   * Gets a boolean indicating if the given control is in the children of this control
   * @param control defines the control to check
   * @returns true if the control is in the child list
   */
  containsControl(control) {
    return this._children.indexOf(control) !== -1;
  }
  /**
   * Adds a control to the children of this control
   * @param control defines the control to add
   * @returns the current container
   */
  addControl(control) {
    const index = this._children.indexOf(control);
    if (index !== -1) {
      return this;
    }
    control.parent = this;
    control._host = this._host;
    this._children.push(control);
    if (this._host.utilityLayer) {
      control._prepareNode(this._host.utilityLayer.utilityLayerScene);
      if (control.node) {
        control.node.parent = this.node;
      }
      if (!this.blockLayout) {
        this._arrangeChildren();
      }
    }
    return this;
  }
  /**
   * This function will be called everytime a new control is added
   */
  _arrangeChildren() {
  }
  _createNode(scene) {
    return new TransformNode("ContainerNode", scene);
  }
  /**
   * Removes a control from the children of this control
   * @param control defines the control to remove
   * @returns the current container
   */
  removeControl(control) {
    const index = this._children.indexOf(control);
    if (index !== -1) {
      this._children.splice(index, 1);
      control.parent = null;
      control._disposeNode();
    }
    return this;
  }
  _getTypeName() {
    return "Container3D";
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    for (const control of this._children) {
      control.dispose();
    }
    this._children.length = 0;
    super.dispose();
  }
};
Container3D.UNSET_ORIENTATION = 0;
Container3D.FACEORIGIN_ORIENTATION = 1;
Container3D.FACEORIGINREVERSED_ORIENTATION = 2;
Container3D.FACEFORWARD_ORIENTATION = 3;
Container3D.FACEFORWARDREVERSED_ORIENTATION = 4;

// node_modules/@babylonjs/gui/3D/controls/volumeBasedPanel.js
var VolumeBasedPanel = class extends Container3D {
  /**
   * Gets or sets the orientation to apply to all controls (BABYLON.Container3D.FaceOriginReversedOrientation by default)
   * | Value | Type                                | Description |
   * | ----- | ----------------------------------- | ----------- |
   * | 0     | UNSET_ORIENTATION                   |  Control rotation will remain unchanged |
   * | 1     | FACEORIGIN_ORIENTATION              |  Control will rotate to make it look at sphere central axis |
   * | 2     | FACEORIGINREVERSED_ORIENTATION      |  Control will rotate to make it look back at sphere central axis |
   * | 3     | FACEFORWARD_ORIENTATION             |  Control will rotate to look at z axis (0, 0, 1) |
   * | 4     | FACEFORWARDREVERSED_ORIENTATION     |  Control will rotate to look at negative z axis (0, 0, -1) |
   */
  get orientation() {
    return this._orientation;
  }
  set orientation(value) {
    if (this._orientation === value) {
      return;
    }
    this._orientation = value;
    Tools.SetImmediate(() => {
      this._arrangeChildren();
    });
  }
  /**
   * Gets or sets the number of columns requested (10 by default).
   * The panel will automatically compute the number of rows based on number of child controls.
   */
  get columns() {
    return this._columns;
  }
  set columns(value) {
    if (this._columns === value) {
      return;
    }
    this._columns = value;
    this._rowThenColum = true;
    Tools.SetImmediate(() => {
      this._arrangeChildren();
    });
  }
  /**
   * Gets or sets a the number of rows requested.
   * The panel will automatically compute the number of columns based on number of child controls.
   */
  get rows() {
    return this._rows;
  }
  set rows(value) {
    if (this._rows === value) {
      return;
    }
    this._rows = value;
    this._rowThenColum = false;
    Tools.SetImmediate(() => {
      this._arrangeChildren();
    });
  }
  /**
   * Creates new VolumeBasedPanel
   * @param name
   */
  constructor(name22) {
    super(name22);
    this._columns = 10;
    this._rows = 0;
    this._rowThenColum = true;
    this._orientation = Container3D.FACEORIGIN_ORIENTATION;
    this.margin = 0;
  }
  _arrangeChildren() {
    this._cellWidth = 0;
    this._cellHeight = 0;
    let rows = 0;
    let columns = 0;
    let controlCount = 0;
    for (const child of this._children) {
      if (!child.mesh) {
        continue;
      }
      controlCount++;
      child.mesh.computeWorldMatrix(true);
      const extendSize = child.mesh.getBoundingInfo().boundingBox.extendSize;
      const descendants = child.mesh.getDescendants(false);
      for (const descendant of descendants) {
        descendant.computeWorldMatrix(true);
        const casted = descendant;
        if (typeof casted.getBoundingInfo === "function") {
          const extendSizeChild = casted.getBoundingInfo().boundingBox.extendSize;
          extendSize.x = Math.max(extendSize.x, extendSizeChild.x);
          extendSize.y = Math.max(extendSize.y, extendSizeChild.y);
          extendSize.z = Math.max(extendSize.z, extendSizeChild.z);
        }
      }
      this._cellWidth = Math.max(this._cellWidth, extendSize.x * 2);
      this._cellHeight = Math.max(this._cellHeight, extendSize.y * 2);
    }
    this._cellWidth += this.margin * 2;
    this._cellHeight += this.margin * 2;
    if (this._rowThenColum) {
      columns = this._columns;
      rows = Math.ceil(controlCount / this._columns);
    } else {
      rows = this._rows;
      columns = Math.ceil(controlCount / this._rows);
    }
    const startOffsetX = columns * 0.5 * this._cellWidth;
    const startOffsetY = rows * 0.5 * this._cellHeight;
    const nodeGrid = [];
    let cellCounter = 0;
    if (this._rowThenColum) {
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < columns; c++) {
          nodeGrid.push(new Vector3(c * this._cellWidth - startOffsetX + this._cellWidth / 2, r * this._cellHeight - startOffsetY + this._cellHeight / 2, 0));
          cellCounter++;
          if (cellCounter > controlCount) {
            break;
          }
        }
      }
    } else {
      for (let c = 0; c < columns; c++) {
        for (let r = 0; r < rows; r++) {
          nodeGrid.push(new Vector3(c * this._cellWidth - startOffsetX + this._cellWidth / 2, r * this._cellHeight - startOffsetY + this._cellHeight / 2, 0));
          cellCounter++;
          if (cellCounter > controlCount) {
            break;
          }
        }
      }
    }
    cellCounter = 0;
    for (const child of this._children) {
      if (!child.mesh) {
        continue;
      }
      this._mapGridNode(child, nodeGrid[cellCounter]);
      cellCounter++;
    }
    this._finalProcessing();
  }
  /** Child classes can implement this function to provide additional processing */
  _finalProcessing() {
  }
};

// node_modules/@babylonjs/gui/3D/controls/cylinderPanel.js
var CylinderPanel = class extends VolumeBasedPanel {
  constructor() {
    super(...arguments);
    this._radius = 5;
  }
  /**
   * Gets or sets the radius of the cylinder where to project controls (5 by default)
   */
  get radius() {
    return this._radius;
  }
  set radius(value) {
    if (this._radius === value) {
      return;
    }
    this._radius = value;
    Tools.SetImmediate(() => {
      this._arrangeChildren();
    });
  }
  _mapGridNode(control, nodePosition) {
    const mesh = control.mesh;
    if (!mesh) {
      return;
    }
    const newPos = this._cylindricalMapping(nodePosition);
    control.position = newPos;
    switch (this.orientation) {
      case Container3D.FACEORIGIN_ORIENTATION:
        mesh.lookAt(new Vector3(2 * newPos.x, newPos.y, 2 * newPos.z));
        break;
      case Container3D.FACEORIGINREVERSED_ORIENTATION:
        mesh.lookAt(new Vector3(-newPos.x, newPos.y, -newPos.z));
        break;
      case Container3D.FACEFORWARD_ORIENTATION:
        break;
      case Container3D.FACEFORWARDREVERSED_ORIENTATION:
        mesh.rotate(
          Axis.Y,
          Math.PI,
          0
          /* Space.LOCAL */
        );
        break;
    }
  }
  _cylindricalMapping(source) {
    const newPos = new Vector3(0, source.y, this._radius);
    const yAngle = source.x / this._radius;
    Matrix.RotationYawPitchRollToRef(yAngle, 0, 0, TmpVectors.Matrix[0]);
    return Vector3.TransformNormal(newPos, TmpVectors.Matrix[0]);
  }
};

// node_modules/@babylonjs/gui/3D/materials/fluent/shaders/fluent.vertex.js
var name2 = "fluentVertexShader";
var shader = `precision highp float;attribute vec3 position;attribute vec3 normal;attribute vec2 uv;uniform mat4 world;uniform mat4 viewProjection;varying vec2 vUV;
#ifdef BORDER
varying vec2 scaleInfo;uniform float borderWidth;uniform vec3 scaleFactor;
#endif
#ifdef HOVERLIGHT
varying vec3 worldPosition;
#endif
void main(void) {vUV=uv;
#ifdef BORDER
vec3 scale=scaleFactor;float minScale=min(min(scale.x,scale.y),scale.z);float maxScale=max(max(scale.x,scale.y),scale.z);float minOverMiddleScale=minScale/(scale.x+scale.y+scale.z-minScale-maxScale);float areaYZ=scale.y*scale.z;float areaXZ=scale.x*scale.z;float areaXY=scale.x*scale.y;float scaledBorderWidth=borderWidth; 
if (abs(normal.x)==1.0) 
{scale.x=scale.y;scale.y=scale.z;if (areaYZ>areaXZ && areaYZ>areaXY)
{scaledBorderWidth*=minOverMiddleScale;}}
else if (abs(normal.y)==1.0) 
{scale.x=scale.z;if (areaXZ>areaXY && areaXZ>areaYZ)
{scaledBorderWidth*=minOverMiddleScale;}}
else 
{if (areaXY>areaYZ && areaXY>areaXZ)
{scaledBorderWidth*=minOverMiddleScale;}}
float scaleRatio=min(scale.x,scale.y)/max(scale.x,scale.y);if (scale.x>scale.y)
{scaleInfo.x=1.0-(scaledBorderWidth*scaleRatio);scaleInfo.y=1.0-scaledBorderWidth;}
else
{scaleInfo.x=1.0-scaledBorderWidth;scaleInfo.y=1.0-(scaledBorderWidth*scaleRatio);} 
#endif 
vec4 worldPos=world*vec4(position,1.0);
#ifdef HOVERLIGHT
worldPosition=worldPos.xyz;
#endif
gl_Position=viewProjection*worldPos;}
`;
if (!ShaderStore.ShadersStore[name2]) {
  ShaderStore.ShadersStore[name2] = shader;
}

// node_modules/@babylonjs/gui/3D/materials/fluent/shaders/fluent.fragment.js
var name3 = "fluentPixelShader";
var shader2 = `precision highp float;varying vec2 vUV;uniform vec4 albedoColor;
#ifdef INNERGLOW
uniform vec4 innerGlowColor;
#endif
#ifdef BORDER
varying vec2 scaleInfo;uniform float edgeSmoothingValue;uniform float borderMinValue;
#endif
#ifdef HOVERLIGHT
varying vec3 worldPosition;uniform vec3 hoverPosition;uniform vec4 hoverColor;uniform float hoverRadius;
#endif
#ifdef TEXTURE
uniform sampler2D albedoSampler;uniform mat4 textureMatrix;vec2 finalUV;
#endif
void main(void) {vec3 albedo=albedoColor.rgb;float alpha=albedoColor.a;
#ifdef TEXTURE
finalUV=vec2(textureMatrix*vec4(vUV,1.0,0.0));albedo=texture2D(albedoSampler,finalUV).rgb;
#endif
#ifdef HOVERLIGHT
float pointToHover=(1.0-clamp(length(hoverPosition-worldPosition)/hoverRadius,0.,1.))*hoverColor.a;albedo=clamp(albedo+hoverColor.rgb*pointToHover,0.,1.);
#else
float pointToHover=1.0;
#endif
#ifdef BORDER 
float borderPower=10.0;float inverseBorderPower=1.0/borderPower;vec3 borderColor=albedo*borderPower;vec2 distanceToEdge;distanceToEdge.x=abs(vUV.x-0.5)*2.0;distanceToEdge.y=abs(vUV.y-0.5)*2.0;float borderValue=max(smoothstep(scaleInfo.x-edgeSmoothingValue,scaleInfo.x+edgeSmoothingValue,distanceToEdge.x),
smoothstep(scaleInfo.y-edgeSmoothingValue,scaleInfo.y+edgeSmoothingValue,distanceToEdge.y));borderColor=borderColor*borderValue*max(borderMinValue*inverseBorderPower,pointToHover); 
albedo+=borderColor;alpha=max(alpha,borderValue);
#endif
#ifdef INNERGLOW
vec2 uvGlow=(vUV-vec2(0.5,0.5))*(innerGlowColor.a*2.0);uvGlow=uvGlow*uvGlow;uvGlow=uvGlow*uvGlow;albedo+=mix(vec3(0.0,0.0,0.0),innerGlowColor.rgb,uvGlow.x+uvGlow.y); 
#endif
gl_FragColor=vec4(albedo,alpha);}`;
if (!ShaderStore.ShadersStore[name3]) {
  ShaderStore.ShadersStore[name3] = shader2;
}

// node_modules/@babylonjs/gui/3D/materials/fluent/fluentMaterial.js
var FluentMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.INNERGLOW = false;
    this.BORDER = false;
    this.HOVERLIGHT = false;
    this.TEXTURE = false;
    this.rebuild();
  }
};
var FluentMaterial = class _FluentMaterial extends PushMaterial {
  /**
   * Creates a new Fluent material
   * @param name defines the name of the material
   * @param scene defines the hosting scene
   */
  constructor(name22, scene) {
    super(name22, scene);
    this.innerGlowColorIntensity = 0.5;
    this.innerGlowColor = new Color3(1, 1, 1);
    this.albedoColor = new Color3(0.3, 0.35, 0.4);
    this.renderBorders = false;
    this.borderWidth = 0.5;
    this.edgeSmoothingValue = 0.02;
    this.borderMinValue = 0.1;
    this.renderHoverLight = false;
    this.hoverRadius = 0.01;
    this.hoverColor = new Color4(0.3, 0.3, 0.3, 1);
    this.hoverPosition = Vector3.Zero();
  }
  needAlphaBlending() {
    return this.alpha !== 1;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  isReadyForSubMesh(mesh, subMesh) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new FluentMaterialDefines();
    }
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!this.checkReadyOnEveryCall && subMesh.effect) {
      if (defines._renderId === scene.getRenderId()) {
        return true;
      }
    }
    if (defines._areTexturesDirty) {
      defines.INNERGLOW = this.innerGlowColorIntensity > 0;
      defines.BORDER = this.renderBorders;
      defines.HOVERLIGHT = this.renderHoverLight;
      if (this._albedoTexture) {
        if (!this._albedoTexture.isReadyOrNotBlocking()) {
          return false;
        } else {
          defines.TEXTURE = true;
        }
      } else {
        defines.TEXTURE = false;
      }
    }
    const engine = scene.getEngine();
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const attribs = [VertexBuffer.PositionKind];
      attribs.push(VertexBuffer.NormalKind);
      attribs.push(VertexBuffer.UVKind);
      const shaderName = "fluent";
      const uniforms = [
        "world",
        "viewProjection",
        "innerGlowColor",
        "albedoColor",
        "borderWidth",
        "edgeSmoothingValue",
        "scaleFactor",
        "borderMinValue",
        "hoverColor",
        "hoverPosition",
        "hoverRadius",
        "textureMatrix"
      ];
      const samplers = ["albedoSampler"];
      const uniformBuffers = [];
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 4
      });
      const join = defines.toString();
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks: null,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 4 }
      }, engine), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    if (this._mustRebind(scene, effect, subMesh)) {
      this._activeEffect.setColor4("albedoColor", this.albedoColor, this.alpha);
      if (defines.INNERGLOW) {
        this._activeEffect.setColor4("innerGlowColor", this.innerGlowColor, this.innerGlowColorIntensity);
      }
      if (defines.BORDER) {
        this._activeEffect.setFloat("borderWidth", this.borderWidth);
        this._activeEffect.setFloat("edgeSmoothingValue", this.edgeSmoothingValue);
        this._activeEffect.setFloat("borderMinValue", this.borderMinValue);
        mesh.getBoundingInfo().boundingBox.extendSize.multiplyToRef(mesh.scaling, TmpVectors.Vector3[0]);
        this._activeEffect.setVector3("scaleFactor", TmpVectors.Vector3[0]);
      }
      if (defines.HOVERLIGHT) {
        this._activeEffect.setDirectColor4("hoverColor", this.hoverColor);
        this._activeEffect.setFloat("hoverRadius", this.hoverRadius);
        this._activeEffect.setVector3("hoverPosition", this.hoverPosition);
      }
      if (defines.TEXTURE && this._albedoTexture) {
        this._activeEffect.setTexture("albedoSampler", this._albedoTexture);
        const matrix = this._albedoTexture.getTextureMatrix();
        this._activeEffect.setMatrix("textureMatrix", matrix);
      }
    }
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    return activeTextures;
  }
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    return false;
  }
  dispose(forceDisposeEffect) {
    super.dispose(forceDisposeEffect);
  }
  clone(name22) {
    return SerializationHelper.Clone(() => new _FluentMaterial(name22, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.GUI.FluentMaterial";
    return serializationObject;
  }
  getClassName() {
    return "FluentMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _FluentMaterial(source.name, scene), source, scene, rootUrl);
  }
};
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], FluentMaterial.prototype, "innerGlowColorIntensity", void 0);
__decorate([
  serializeAsColor3()
], FluentMaterial.prototype, "innerGlowColor", void 0);
__decorate([
  serializeAsColor3()
], FluentMaterial.prototype, "albedoColor", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], FluentMaterial.prototype, "renderBorders", void 0);
__decorate([
  serialize()
], FluentMaterial.prototype, "borderWidth", void 0);
__decorate([
  serialize()
], FluentMaterial.prototype, "edgeSmoothingValue", void 0);
__decorate([
  serialize()
], FluentMaterial.prototype, "borderMinValue", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], FluentMaterial.prototype, "renderHoverLight", void 0);
__decorate([
  serialize()
], FluentMaterial.prototype, "hoverRadius", void 0);
__decorate([
  serializeAsColor4()
], FluentMaterial.prototype, "hoverColor", void 0);
__decorate([
  serializeAsVector3()
], FluentMaterial.prototype, "hoverPosition", void 0);
__decorate([
  serializeAsTexture("albedoTexture")
], FluentMaterial.prototype, "_albedoTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
], FluentMaterial.prototype, "albedoTexture", void 0);
RegisterClass("BABYLON.GUI.FluentMaterial", FluentMaterial);

// node_modules/@babylonjs/gui/3D/controls/touchHolographicMenu.js
var TouchHolographicMenu = class _TouchHolographicMenu extends VolumeBasedPanel {
  /**
   * Gets or sets the margin size of the backplate in button size units.
   * Setting this to 1, will make the backPlate margin the size of 1 button
   */
  get backPlateMargin() {
    return this._backPlateMargin;
  }
  set backPlateMargin(value) {
    this._backPlateMargin = value;
    if (this._children.length >= 1) {
      this.children.forEach((control) => {
        this._updateCurrentMinMax(control.position);
      });
      this._updateMargins();
    }
  }
  _createNode(scene) {
    const node = new Mesh(`menu_${this.name}`, scene);
    this._backPlate = CreateBox("backPlate" + this.name, { size: 1 }, scene);
    this._backPlate.parent = node;
    return node;
  }
  _affectMaterial(mesh) {
    this._backPlateMaterial = new FluentMaterial(this.name + "backPlateMaterial", mesh.getScene());
    this._backPlateMaterial.albedoColor = new Color3(0.08, 0.15, 0.55);
    this._backPlateMaterial.renderBorders = true;
    this._backPlateMaterial.renderHoverLight = true;
    this._pickedPointObserver = this._host.onPickedPointChangedObservable.add((pickedPoint) => {
      if (pickedPoint) {
        this._backPlateMaterial.hoverPosition = pickedPoint;
        this._backPlateMaterial.hoverColor.a = 1;
      } else {
        this._backPlateMaterial.hoverColor.a = 0;
      }
    });
    this._backPlate.material = this._backPlateMaterial;
  }
  _mapGridNode(control, nodePosition) {
    const mesh = control.mesh;
    if (!mesh) {
      return;
    }
    control.position = nodePosition.clone();
    this._updateCurrentMinMax(nodePosition);
  }
  _finalProcessing() {
    this._updateMargins();
  }
  _updateCurrentMinMax(nodePosition) {
    if (!this._currentMin) {
      this._currentMin = nodePosition.clone();
      this._currentMax = nodePosition.clone();
    }
    this._currentMin.minimizeInPlace(nodePosition);
    this._currentMax.maximizeInPlace(nodePosition);
  }
  _updateMargins() {
    if (this._children.length > 0) {
      this._currentMin.addInPlaceFromFloats(-this._cellWidth / 2, -this._cellHeight / 2, 0);
      this._currentMax.addInPlaceFromFloats(this._cellWidth / 2, this._cellHeight / 2, 0);
      const extendSize = this._currentMax.subtract(this._currentMin);
      this._backPlate.scaling.x = extendSize.x + this._cellWidth * this.backPlateMargin;
      this._backPlate.scaling.y = extendSize.y + this._cellHeight * this.backPlateMargin;
      this._backPlate.scaling.z = 1e-3;
      for (let i = 0; i < this._children.length; i++) {
        this._children[i].position.subtractInPlace(this._currentMin).subtractInPlace(extendSize.scale(0.5));
        this._children[i].position.z -= 0.01;
      }
    }
    this._currentMin = null;
    this._currentMax = null;
  }
  /**
   * Creates a holographic menu GUI 3D control
   * @param name name of the menu
   */
  constructor(name22) {
    super(name22);
    this._backPlateMargin = 1.25;
  }
  /**
   * Adds a button to the menu.
   * Please note that the back material of the button will be set to transparent as it is attached to the menu.
   *
   * @param button Button to add
   * @returns This menu
   */
  addButton(button) {
    const wasLayoutBlocked = this.blockLayout;
    if (!wasLayoutBlocked) {
      this.blockLayout = true;
    }
    super.addControl(button);
    button.isBackplateVisible = false;
    button.scaling.scaleInPlace(_TouchHolographicMenu.MENU_BUTTON_SCALE);
    if (!wasLayoutBlocked) {
      this.blockLayout = false;
    }
    return this;
  }
  /**
   * This method should not be used directly. It is inherited from `Container3D`.
   * Please use `addButton` instead.
   * @param _control the control to add
   * @returns the current container
   */
  addControl(_control) {
    Logger.Warn("TouchHolographicMenu can only contain buttons. Please use the method `addButton` instead.");
    return this;
  }
  /**
   * Disposes the menu
   */
  dispose() {
    super.dispose();
    this._host.onPickedPointChangedObservable.remove(this._pickedPointObserver);
  }
};
TouchHolographicMenu.MENU_BUTTON_SCALE = 1;

// node_modules/@babylonjs/gui/3D/controls/handMenu.js
var HandMenu = class extends TouchHolographicMenu {
  /**
   * The hand constraint behavior setting the transformation of this node
   */
  get handConstraintBehavior() {
    return this._handConstraintBehavior;
  }
  _createNode(scene) {
    const node = super._createNode(scene);
    this._handConstraintBehavior.attach(node);
    return node;
  }
  /**
   * Creates a hand menu GUI 3D control
   * @param xr the WebXRExperienceHelper used to link this control to the enabled WebXRHandTracking feature
   * @param name name of the hand menu
   */
  constructor(xr, name22) {
    super(name22);
    this._handConstraintBehavior = new HandConstraintBehavior();
    this._handConstraintBehavior.linkToXRExperience(xr);
    this.backPlateMargin = 0.15;
    this.rows = 3;
  }
  /**
   * Disposes the hand menu
   */
  dispose() {
    super.dispose();
    this._handConstraintBehavior.detach();
  }
};

// node_modules/@babylonjs/gui/3D/materials/fluentBackplate/shaders/fluentBackplate.fragment.js
var name4 = "fluentBackplatePixelShader";
var shader3 = `uniform vec3 cameraPosition;varying vec3 vPosition;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec3 vBinormal;varying vec4 vColor;varying vec4 vExtra1;varying vec4 vExtra2;varying vec4 vExtra3;uniform float _Radius_;uniform float _Line_Width_;uniform bool _Absolute_Sizes_;uniform float _Filter_Width_;uniform vec4 _Base_Color_;uniform vec4 _Line_Color_;uniform float _Radius_Top_Left_;uniform float _Radius_Top_Right_;uniform float _Radius_Bottom_Left_;uniform float _Radius_Bottom_Right_;uniform vec3 _Blob_Position_;uniform float _Blob_Intensity_;uniform float _Blob_Near_Size_;uniform float _Blob_Far_Size_;uniform float _Blob_Near_Distance_;uniform float _Blob_Far_Distance_;uniform float _Blob_Fade_Length_;uniform float _Blob_Pulse_;uniform float _Blob_Fade_;uniform sampler2D _Blob_Texture_;uniform vec3 _Blob_Position_2_;uniform float _Blob_Near_Size_2_;uniform float _Blob_Pulse_2_;uniform float _Blob_Fade_2_;uniform float _Rate_;uniform vec4 _Highlight_Color_;uniform float _Highlight_Width_;uniform vec4 _Highlight_Transform_;uniform float _Highlight_;uniform float _Iridescence_Intensity_;uniform float _Iridescence_Edge_Intensity_;uniform float _Angle_;uniform float _Fade_Out_;uniform bool _Reflected_;uniform float _Frequency_;uniform float _Vertical_Offset_;uniform sampler2D _Iridescent_Map_;uniform bool _Use_Global_Left_Index_;uniform bool _Use_Global_Right_Index_;uniform vec4 Global_Left_Index_Tip_Position;uniform vec4 Global_Right_Index_Tip_Position;void Round_Rect_Fragment_B31(
float Radius,
float Line_Width,
vec4 Line_Color,
float Filter_Width,
vec2 UV,
float Line_Visibility,
vec4 Rect_Parms,
vec4 Fill_Color,
out vec4 Color)
{float d=length(max(abs(UV)-Rect_Parms.xy,0.0));float dx=max(fwidth(d)*Filter_Width,0.00001);float g=min(Rect_Parms.z,Rect_Parms.w);float dgrad=max(fwidth(g)*Filter_Width,0.00001);float Inside_Rect=clamp(g/dgrad,0.0,1.0);float inner=clamp((d+dx*0.5-max(Radius-Line_Width,d-dx*0.5))/dx,0.0,1.0);Color=clamp(mix(Fill_Color,Line_Color,inner),0.0,1.0)*Inside_Rect;}
void Blob_Fragment_B71(
sampler2D Blob_Texture,
vec4 Blob_Info1,
vec4 Blob_Info2,
out vec4 Blob_Color)
{float k1=dot(Blob_Info1.xy,Blob_Info1.xy);float k2=dot(Blob_Info2.xy,Blob_Info2.xy);vec3 closer=k1<k2 ? vec3(k1,Blob_Info1.z,Blob_Info1.w) : vec3(k2,Blob_Info2.z,Blob_Info2.w);Blob_Color=closer.z*texture(Blob_Texture,vec2(vec2(sqrt(closer.x),closer.y).x,1.0-vec2(sqrt(closer.x),closer.y).y))*clamp(1.0-closer.x,0.0,1.0);}
void Line_Fragment_B48(
vec4 Base_Color,
vec4 Highlight_Color,
float Highlight_Width,
vec3 Line_Vertex,
float Highlight,
out vec4 Line_Color)
{float k2=1.0-clamp(abs(Line_Vertex.y/Highlight_Width),0.0,1.0);Line_Color=mix(Base_Color,Highlight_Color,Highlight*k2);}
void Scale_RGB_B54(
vec4 Color,
float Scalar,
out vec4 Result)
{Result=vec4(Scalar,Scalar,Scalar,1)*Color;}
void Conditional_Float_B38(
bool Which,
float If_True,
float If_False,
out float Result)
{Result=Which ? If_True : If_False;}
void main()
{float R_Q72;float G_Q72;float B_Q72;float A_Q72;R_Q72=vColor.r; G_Q72=vColor.g; B_Q72=vColor.b; A_Q72=vColor.a;vec4 Blob_Color_Q71;
#if BLOB_ENABLE
float k1=dot(vExtra2.xy,vExtra2.xy);float k2=dot(vExtra3.xy,vExtra3.xy);vec3 closer=k1<k2 ? vec3(k1,vExtra2.z,vExtra2.w) : vec3(k2,vExtra3.z,vExtra3.w);Blob_Color_Q71=closer.z*texture(_Blob_Texture_,vec2(vec2(sqrt(closer.x),closer.y).x,1.0-vec2(sqrt(closer.x),closer.y).y))*clamp(1.0-closer.x,0.0,1.0);
#else
Blob_Color_Q71=vec4(0,0,0,0);
#endif
vec4 Line_Color_Q48;Line_Fragment_B48(_Line_Color_,_Highlight_Color_,_Highlight_Width_,vTangent,_Highlight_,Line_Color_Q48);float X_Q67;float Y_Q67;X_Q67=vUV.x;Y_Q67=vUV.y;vec3 Incident_Q66=normalize(vPosition-cameraPosition);vec3 Reflected_Q60=reflect(Incident_Q66,vBinormal);float Product_Q63=Y_Q67*_Vertical_Offset_;float Dot_Q68=dot(Incident_Q66, Reflected_Q60);float Dot_Q57=dot(vNormal, Incident_Q66);float Result_Q38;Conditional_Float_B38(_Reflected_,Dot_Q68,Dot_Q57,Result_Q38);float Product_Q64=Result_Q38*_Frequency_;float Sum_Q69=Product_Q64+1.0;float Product_Q70=Sum_Q69*0.5;float Sum_Q62=Product_Q63+Product_Q70;float FractF_Q59=fract(Sum_Q62);vec2 Vec2_Q65=vec2(FractF_Q59,0.5);vec4 Color_Q58;
#if IRIDESCENT_MAP_ENABLE
Color_Q58=texture(_Iridescent_Map_,Vec2_Q65);
#else
Color_Q58=vec4(0,0,0,0);
#endif
vec4 Result_Q54;Scale_RGB_B54(Color_Q58,_Iridescence_Edge_Intensity_,Result_Q54);vec4 Result_Q55;Scale_RGB_B54(Color_Q58,_Iridescence_Intensity_,Result_Q55);vec4 Base_And_Iridescent_Q53;Base_And_Iridescent_Q53=Line_Color_Q48+vec4(Result_Q54.rgb,0.0);vec4 Base_And_Iridescent_Q56;Base_And_Iridescent_Q56=_Base_Color_+vec4(Result_Q55.rgb,0.0);vec4 Result_Q52=Base_And_Iridescent_Q53; Result_Q52.a=1.0;vec4 Result_Q35=Blob_Color_Q71+(1.0-Blob_Color_Q71.a)*Base_And_Iridescent_Q56;vec4 Color_Q31;Round_Rect_Fragment_B31(R_Q72,G_Q72,Result_Q52,_Filter_Width_,vUV,1.0,vExtra1,Result_Q35,Color_Q31);vec4 Result_Q47=_Fade_Out_*Color_Q31;vec4 Out_Color=Result_Q47;float Clip_Threshold=0.001;bool To_sRGB=false;gl_FragColor=Out_Color;}`;
if (!ShaderStore.ShadersStore[name4]) {
  ShaderStore.ShadersStore[name4] = shader3;
}

// node_modules/@babylonjs/gui/3D/materials/fluentBackplate/shaders/fluentBackplate.vertex.js
var name5 = "fluentBackplateVertexShader";
var shader4 = `uniform mat4 world;uniform mat4 viewProjection;uniform vec3 cameraPosition;attribute vec3 position;attribute vec3 normal;
#ifdef TANGENT
attribute vec3 tangent;
#else
const vec3 tangent=vec3(0.);
#endif
uniform float _Radius_;uniform float _Line_Width_;uniform bool _Absolute_Sizes_;uniform float _Filter_Width_;uniform vec4 _Base_Color_;uniform vec4 _Line_Color_;uniform float _Radius_Top_Left_;uniform float _Radius_Top_Right_;uniform float _Radius_Bottom_Left_;uniform float _Radius_Bottom_Right_;uniform vec3 _Blob_Position_;uniform float _Blob_Intensity_;uniform float _Blob_Near_Size_;uniform float _Blob_Far_Size_;uniform float _Blob_Near_Distance_;uniform float _Blob_Far_Distance_;uniform float _Blob_Fade_Length_;uniform float _Blob_Pulse_;uniform float _Blob_Fade_;uniform sampler2D _Blob_Texture_;uniform vec3 _Blob_Position_2_;uniform float _Blob_Near_Size_2_;uniform float _Blob_Pulse_2_;uniform float _Blob_Fade_2_;uniform float _Rate_;uniform vec4 _Highlight_Color_;uniform float _Highlight_Width_;uniform vec4 _Highlight_Transform_;uniform float _Highlight_;uniform float _Iridescence_Intensity_;uniform float _Iridescence_Edge_Intensity_;uniform float _Angle_;uniform float _Fade_Out_;uniform bool _Reflected_;uniform float _Frequency_;uniform float _Vertical_Offset_;uniform sampler2D _Iridescent_Map_;uniform bool _Use_Global_Left_Index_;uniform bool _Use_Global_Right_Index_;uniform vec4 Global_Left_Index_Tip_Position;uniform vec4 Global_Right_Index_Tip_Position;varying vec3 vPosition;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec3 vBinormal;varying vec4 vColor;varying vec4 vExtra1;varying vec4 vExtra2;varying vec4 vExtra3;void Object_To_World_Pos_B115(
vec3 Pos_Object,
out vec3 Pos_World)
{Pos_World=(world*vec4(Pos_Object,1.0)).xyz;}
void PickDir_B140(
float Degrees,
vec3 DirX,
vec3 DirY,
out vec3 Dir)
{float a=Degrees*3.14159/180.0;Dir=cos(a)*DirX+sin(a)*DirY;}
void Round_Rect_Vertex_B139(
vec2 UV,
float Radius,
float Margin,
float Anisotropy,
float Gradient1,
float Gradient2,
out vec2 Rect_UV,
out vec4 Rect_Parms,
out vec2 Scale_XY,
out vec2 Line_UV)
{Scale_XY=vec2(Anisotropy,1.0);Line_UV=(UV-vec2(0.5,0.5));Rect_UV=Line_UV*Scale_XY;Rect_Parms.xy=Scale_XY*0.5-vec2(Radius,Radius)-vec2(Margin,Margin);Rect_Parms.z=Gradient1; 
Rect_Parms.w=Gradient2;}
void Line_Vertex_B135(
vec2 Scale_XY,
vec2 UV,
float Time,
float Rate,
vec4 Highlight_Transform,
out vec3 Line_Vertex)
{float angle2=(Rate*Time)*2.0*3.1416;float sinAngle2=sin(angle2);float cosAngle2=cos(angle2);vec2 xformUV=UV*Highlight_Transform.xy+Highlight_Transform.zw;Line_Vertex.x=0.0;Line_Vertex.y=cosAngle2*xformUV.x-sinAngle2*xformUV.y;Line_Vertex.z=0.0; }
void Blob_Vertex_B180(
vec3 Position,
vec3 Normal,
vec3 Tangent,
vec3 Bitangent,
vec3 Blob_Position,
float Intensity,
float Blob_Near_Size,
float Blob_Far_Size,
float Blob_Near_Distance,
float Blob_Far_Distance,
float Blob_Fade_Length,
float Blob_Pulse,
float Blob_Fade,
out vec4 Blob_Info)
{vec3 blob=Blob_Position;vec3 delta=blob-Position;float dist=dot(Normal,delta);float lerpValue=clamp((abs(dist)-Blob_Near_Distance)/(Blob_Far_Distance-Blob_Near_Distance),0.0,1.0);float fadeValue=1.0-clamp((abs(dist)-Blob_Far_Distance)/Blob_Fade_Length,0.0,1.0);float size=Blob_Near_Size+(Blob_Far_Size-Blob_Near_Size)*lerpValue;vec2 blobXY=vec2(dot(delta,Tangent),dot(delta,Bitangent))/(0.0001+size);float Fade=fadeValue*Intensity*Blob_Fade;float Distance=(lerpValue*0.5+0.5)*(1.0-Blob_Pulse);Blob_Info=vec4(blobXY.x,blobXY.y,Distance,Fade);}
void Move_Verts_B129(
float Anisotropy,
vec3 P,
float Radius,
out vec3 New_P,
out vec2 New_UV,
out float Radial_Gradient,
out vec3 Radial_Dir)
{vec2 UV=P.xy*2.0+0.5;vec2 center=clamp(UV,0.0,1.0);vec2 delta=UV-center;vec2 r2=2.0*vec2(Radius/Anisotropy,Radius);New_UV=center+r2*(UV-2.0*center+0.5);New_P=vec3(New_UV-0.5,P.z);Radial_Gradient=1.0-length(delta)*2.0;Radial_Dir=vec3(delta*r2,0.0);}
void Object_To_World_Dir_B132(
vec3 Dir_Object,
out vec3 Binormal_World,
out vec3 Binormal_World_N,
out float Binormal_Length)
{Binormal_World=(world*vec4(Dir_Object,0.0)).xyz;Binormal_Length=length(Binormal_World);Binormal_World_N=Binormal_World/Binormal_Length;}
void RelativeOrAbsoluteDetail_B147(
float Nominal_Radius,
float Nominal_LineWidth,
bool Absolute_Measurements,
float Height,
out float Radius,
out float Line_Width)
{float scale=Absolute_Measurements ? 1.0/Height : 1.0;Radius=Nominal_Radius*scale;Line_Width=Nominal_LineWidth*scale;}
void Edge_AA_Vertex_B130(
vec3 Position_World,
vec3 Position_Object,
vec3 Normal_Object,
vec3 Eye,
float Radial_Gradient,
vec3 Radial_Dir,
vec3 Tangent,
out float Gradient1,
out float Gradient2)
{vec3 I=(Eye-Position_World);vec3 T=(world* vec4(Tangent,0.0)).xyz;float g=(dot(T,I)<0.0) ? 0.0 : 1.0;if (Normal_Object.z==0.0) { 
Gradient1=Position_Object.z>0.0 ? g : 1.0;Gradient2=Position_Object.z>0.0 ? 1.0 : g;} else {Gradient1=g+(1.0-g)*(Radial_Gradient);Gradient2=1.0;}}
void Pick_Radius_B144(
float Radius,
float Radius_Top_Left,
float Radius_Top_Right,
float Radius_Bottom_Left,
float Radius_Bottom_Right,
vec3 Position,
out float Result)
{bool whichY=Position.y>0.0;Result=Position.x<0.0 ? (whichY ? Radius_Top_Left : Radius_Bottom_Left) : (whichY ? Radius_Top_Right : Radius_Bottom_Right);Result*=Radius;}
void main()
{vec3 Nrm_World_Q128;Nrm_World_Q128=normalize((world*vec4(normal,0.0)).xyz);vec3 Tangent_World_Q131;vec3 Tangent_World_N_Q131;float Tangent_Length_Q131;Tangent_World_Q131=(world*vec4(vec3(1,0,0),0.0)).xyz;Tangent_Length_Q131=length(Tangent_World_Q131);Tangent_World_N_Q131=Tangent_World_Q131/Tangent_Length_Q131;vec3 Binormal_World_Q132;vec3 Binormal_World_N_Q132;float Binormal_Length_Q132;Object_To_World_Dir_B132(vec3(0,1,0),Binormal_World_Q132,Binormal_World_N_Q132,Binormal_Length_Q132);float Anisotropy_Q133=Tangent_Length_Q131/Binormal_Length_Q132;vec3 Result_Q177;Result_Q177=mix(_Blob_Position_,Global_Left_Index_Tip_Position.xyz,float(_Use_Global_Left_Index_));vec3 Result_Q178;Result_Q178=mix(_Blob_Position_2_,Global_Right_Index_Tip_Position.xyz,float(_Use_Global_Right_Index_));float Result_Q144;Pick_Radius_B144(_Radius_,_Radius_Top_Left_,_Radius_Top_Right_,_Radius_Bottom_Left_,_Radius_Bottom_Right_,position,Result_Q144);vec3 Dir_Q140;PickDir_B140(_Angle_,Tangent_World_N_Q131,Binormal_World_N_Q132,Dir_Q140);float Radius_Q147;float Line_Width_Q147;RelativeOrAbsoluteDetail_B147(Result_Q144,_Line_Width_,_Absolute_Sizes_,Binormal_Length_Q132,Radius_Q147,Line_Width_Q147);vec4 Out_Color_Q145=vec4(Radius_Q147,Line_Width_Q147,0,1);vec3 New_P_Q129;vec2 New_UV_Q129;float Radial_Gradient_Q129;vec3 Radial_Dir_Q129;Move_Verts_B129(Anisotropy_Q133,position,Radius_Q147,New_P_Q129,New_UV_Q129,Radial_Gradient_Q129,Radial_Dir_Q129);vec3 Pos_World_Q115;Object_To_World_Pos_B115(New_P_Q129,Pos_World_Q115);vec4 Blob_Info_Q180;
#if BLOB_ENABLE
Blob_Vertex_B180(Pos_World_Q115,Nrm_World_Q128,Tangent_World_N_Q131,Binormal_World_N_Q132,Result_Q177,_Blob_Intensity_,_Blob_Near_Size_,_Blob_Far_Size_,_Blob_Near_Distance_,_Blob_Far_Distance_,_Blob_Fade_Length_,_Blob_Pulse_,_Blob_Fade_,Blob_Info_Q180);
#else
Blob_Info_Q180=vec4(0,0,0,0);
#endif
vec4 Blob_Info_Q181;
#if BLOB_ENABLE_2
Blob_Vertex_B180(Pos_World_Q115,Nrm_World_Q128,Tangent_World_N_Q131,Binormal_World_N_Q132,Result_Q178,_Blob_Intensity_,_Blob_Near_Size_2_,_Blob_Far_Size_,_Blob_Near_Distance_,_Blob_Far_Distance_,_Blob_Fade_Length_,_Blob_Pulse_2_,_Blob_Fade_2_,Blob_Info_Q181);
#else
Blob_Info_Q181=vec4(0,0,0,0);
#endif
float Gradient1_Q130;float Gradient2_Q130;
#if SMOOTH_EDGES
Edge_AA_Vertex_B130(Pos_World_Q115,position,normal,cameraPosition,Radial_Gradient_Q129,Radial_Dir_Q129,tangent,Gradient1_Q130,Gradient2_Q130);
#else
Gradient1_Q130=1.0;Gradient2_Q130=1.0;
#endif
vec2 Rect_UV_Q139;vec4 Rect_Parms_Q139;vec2 Scale_XY_Q139;vec2 Line_UV_Q139;Round_Rect_Vertex_B139(New_UV_Q129,Radius_Q147,0.0,Anisotropy_Q133,Gradient1_Q130,Gradient2_Q130,Rect_UV_Q139,Rect_Parms_Q139,Scale_XY_Q139,Line_UV_Q139);vec3 Line_Vertex_Q135;Line_Vertex_B135(Scale_XY_Q139,Line_UV_Q139,0.0,_Rate_,_Highlight_Transform_,Line_Vertex_Q135);vec3 Position=Pos_World_Q115;vec3 Normal=Dir_Q140;vec2 UV=Rect_UV_Q139;vec3 Tangent=Line_Vertex_Q135;vec3 Binormal=Nrm_World_Q128;vec4 Color=Out_Color_Q145;vec4 Extra1=Rect_Parms_Q139;vec4 Extra2=Blob_Info_Q180;vec4 Extra3=Blob_Info_Q181;gl_Position=viewProjection*vec4(Position,1);vPosition=Position;vNormal=Normal;vUV=UV;vTangent=Tangent;vBinormal=Binormal;vColor=Color;vExtra1=Extra1;vExtra2=Extra2;vExtra3=Extra3;}`;
if (!ShaderStore.ShadersStore[name5]) {
  ShaderStore.ShadersStore[name5] = shader4;
}

// node_modules/@babylonjs/gui/3D/materials/fluentBackplate/fluentBackplateMaterial.js
var FluentBackplateMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.BLOB_ENABLE = true;
    this.BLOB_ENABLE_2 = true;
    this.SMOOTH_EDGES = true;
    this.IRIDESCENT_MAP_ENABLE = true;
    this._needNormals = true;
    this.rebuild();
  }
};
var FluentBackplateMaterial = class _FluentBackplateMaterial extends PushMaterial {
  constructor(name22, scene) {
    super(name22, scene);
    this.radius = 0.03;
    this.lineWidth = 0.01;
    this.absoluteSizes = false;
    this._filterWidth = 1;
    this.baseColor = new Color4(0.0392157, 0.0666667, 0.207843, 1);
    this.lineColor = new Color4(0.14902, 0.133333, 0.384314, 1);
    this.blobIntensity = 0.98;
    this.blobFarSize = 0.04;
    this.blobNearDistance = 0;
    this.blobFarDistance = 0.08;
    this.blobFadeLength = 0.08;
    this.blobNearSize = 0.22;
    this.blobPulse = 0;
    this.blobFade = 0;
    this.blobNearSize2 = 0.22;
    this.blobPulse2 = 0;
    this.blobFade2 = 0;
    this._rate = 0.135;
    this.highlightColor = new Color4(0.98, 0.98, 0.98, 1);
    this.highlightWidth = 0.25;
    this._highlightTransform = new Vector4(1, 1, 0, 0);
    this._highlight = 1;
    this.iridescenceIntensity = 0;
    this.iridescenceEdgeIntensity = 1;
    this._angle = -45;
    this.fadeOut = 1;
    this._reflected = true;
    this._frequency = 1;
    this._verticalOffset = 0;
    this.globalLeftIndexTipPosition = Vector3.Zero();
    this._globalLeftIndexTipPosition4 = Vector4.Zero();
    this.globalRightIndexTipPosition = Vector3.Zero();
    this._globalRightIndexTipPosition4 = Vector4.Zero();
    this.alphaMode = Constants.ALPHA_DISABLE;
    this.backFaceCulling = false;
    const blobTextureUrl = Tools.GetAssetUrl(_FluentBackplateMaterial.BLOB_TEXTURE_URL);
    const iridescentMapUrl = Tools.GetAssetUrl(_FluentBackplateMaterial.IM_TEXTURE_URL);
    this._blobTexture = new Texture(blobTextureUrl, this.getScene(), true, false, Texture.NEAREST_SAMPLINGMODE);
    this._iridescentMap = new Texture(iridescentMapUrl, this.getScene(), true, false, Texture.NEAREST_SAMPLINGMODE);
  }
  needAlphaBlending() {
    return false;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  isReadyForSubMesh(mesh, subMesh) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new FluentBackplateMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    PrepareDefinesForAttributes(mesh, defines, false, false);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks);
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      if (defines.TANGENT) {
        attribs.push(VertexBuffer.TangentKind);
      }
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "fluentBackplate";
      const join = defines.toString();
      const uniforms = [
        "world",
        "viewProjection",
        "cameraPosition",
        "_Radius_",
        "_Line_Width_",
        "_Absolute_Sizes_",
        "_Filter_Width_",
        "_Base_Color_",
        "_Line_Color_",
        "_Radius_Top_Left_",
        "_Radius_Top_Right_",
        "_Radius_Bottom_Left_",
        "_Radius_Bottom_Right_",
        "_Blob_Position_",
        "_Blob_Intensity_",
        "_Blob_Near_Size_",
        "_Blob_Far_Size_",
        "_Blob_Near_Distance_",
        "_Blob_Far_Distance_",
        "_Blob_Fade_Length_",
        "_Blob_Pulse_",
        "_Blob_Fade_",
        "_Blob_Texture_",
        "_Blob_Position_2_",
        "_Blob_Near_Size_2_",
        "_Blob_Pulse_2_",
        "_Blob_Fade_2_",
        "_Rate_",
        "_Highlight_Color_",
        "_Highlight_Width_",
        "_Highlight_Transform_",
        "_Highlight_",
        "_Iridescence_Intensity_",
        "_Iridescence_Edge_Intensity_",
        "_Angle_",
        "_Fade_Out_",
        "_Reflected_",
        "_Frequency_",
        "_Vertical_Offset_",
        "_Iridescent_Map_",
        "_Use_Global_Left_Index_",
        "_Use_Global_Right_Index_",
        "Global_Left_Index_Tip_Position",
        "Global_Right_Index_Tip_Position"
      ];
      const samplers = ["_Blob_Texture_", "_Iridescent_Map_"];
      const uniformBuffers = [];
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 4
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 4 }
      }, engine), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    var _a;
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", this.getScene().getTransformMatrix());
    this._activeEffect.setVector3("cameraPosition", ((_a = this.getScene().activeCamera) == null ? void 0 : _a.position) ?? Vector3.ZeroReadOnly);
    this._activeEffect.setFloat("_Radius_", this.radius);
    this._activeEffect.setFloat("_Line_Width_", this.lineWidth);
    this._activeEffect.setFloat("_Absolute_Sizes_", this.absoluteSizes ? 1 : 0);
    this._activeEffect.setFloat("_Filter_Width_", this._filterWidth);
    this._activeEffect.setDirectColor4("_Base_Color_", this.baseColor);
    this._activeEffect.setDirectColor4("_Line_Color_", this.lineColor);
    this._activeEffect.setFloat("_Radius_Top_Left_", 1);
    this._activeEffect.setFloat("_Radius_Top_Right_", 1);
    this._activeEffect.setFloat("_Radius_Bottom_Left_", 1);
    this._activeEffect.setFloat("_Radius_Bottom_Right_", 1);
    this._activeEffect.setFloat("_Blob_Intensity_", this.blobIntensity);
    this._activeEffect.setFloat("_Blob_Near_Size_", this.blobNearSize);
    this._activeEffect.setFloat("_Blob_Far_Size_", this.blobFarSize);
    this._activeEffect.setFloat("_Blob_Near_Distance_", this.blobNearDistance);
    this._activeEffect.setFloat("_Blob_Far_Distance_", this.blobFarDistance);
    this._activeEffect.setFloat("_Blob_Fade_Length_", this.blobFadeLength);
    this._activeEffect.setFloat("_Blob_Pulse_", this.blobPulse);
    this._activeEffect.setFloat("_Blob_Fade_", this.blobFade);
    this._activeEffect.setTexture("_Blob_Texture_", this._blobTexture);
    this._activeEffect.setFloat("_Blob_Near_Size_2_", this.blobNearSize2);
    this._activeEffect.setFloat("_Blob_Pulse_2_", this.blobPulse2);
    this._activeEffect.setFloat("_Blob_Fade_2_", this.blobFade2);
    this._activeEffect.setFloat("_Rate_", this._rate);
    this._activeEffect.setDirectColor4("_Highlight_Color_", this.highlightColor);
    this._activeEffect.setFloat("_Highlight_Width_", this.highlightWidth);
    this._activeEffect.setVector4("_Highlight_Transform_", this._highlightTransform);
    this._activeEffect.setFloat("_Highlight_", this._highlight);
    this._activeEffect.setFloat("_Iridescence_Intensity_", this.iridescenceIntensity);
    this._activeEffect.setFloat("_Iridescence_Edge_Intensity_", this.iridescenceEdgeIntensity);
    this._activeEffect.setFloat("_Angle_", this._angle);
    this._activeEffect.setFloat("_Fade_Out_", this.fadeOut);
    this._activeEffect.setFloat("_Reflected_", this._reflected ? 1 : 0);
    this._activeEffect.setFloat("_Frequency_", this._frequency);
    this._activeEffect.setFloat("_Vertical_Offset_", this._verticalOffset);
    this._activeEffect.setTexture("_Iridescent_Map_", this._iridescentMap);
    this._activeEffect.setFloat("_Use_Global_Left_Index_", 1);
    this._activeEffect.setFloat("_Use_Global_Right_Index_", 1);
    this._globalLeftIndexTipPosition4.set(this.globalLeftIndexTipPosition.x, this.globalLeftIndexTipPosition.y, this.globalLeftIndexTipPosition.z, 1);
    this._activeEffect.setVector4("Global_Left_Index_Tip_Position", this._globalLeftIndexTipPosition4);
    this._globalRightIndexTipPosition4.set(this.globalRightIndexTipPosition.x, this.globalRightIndexTipPosition.y, this.globalRightIndexTipPosition.z, 1);
    this._activeEffect.setVector4("Global_Right_Index_Tip_Position", this._globalRightIndexTipPosition4);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  /**
   * Get the list of animatables in the material.
   * @returns the list of animatables object used in the material
   */
  getAnimatables() {
    return [];
  }
  dispose(forceDisposeEffect) {
    super.dispose(forceDisposeEffect);
    this._blobTexture.dispose();
    this._iridescentMap.dispose();
  }
  clone(name22) {
    return SerializationHelper.Clone(() => new _FluentBackplateMaterial(name22, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.FluentBackplateMaterial";
    return serializationObject;
  }
  getClassName() {
    return "FluentBackplateMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _FluentBackplateMaterial(source.name, scene), source, scene, rootUrl);
  }
};
FluentBackplateMaterial.BLOB_TEXTURE_URL = "https://assets.babylonjs.com/core/MRTK/mrtk-fluent-backplate-blob.png";
FluentBackplateMaterial.IM_TEXTURE_URL = "https://assets.babylonjs.com/core/MRTK/mrtk-fluent-backplate-iridescence.png";
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "radius", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "lineWidth", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "absoluteSizes", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "baseColor", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "lineColor", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "blobIntensity", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "blobFarSize", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "blobNearDistance", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "blobFarDistance", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "blobFadeLength", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "blobNearSize", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "blobPulse", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "blobFade", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "blobNearSize2", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "blobPulse2", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "blobFade2", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "highlightColor", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "highlightWidth", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "iridescenceIntensity", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "iridescenceEdgeIntensity", void 0);
__decorate([
  serialize()
], FluentBackplateMaterial.prototype, "fadeOut", void 0);
__decorate([
  serializeAsVector3()
], FluentBackplateMaterial.prototype, "globalLeftIndexTipPosition", void 0);
__decorate([
  serializeAsVector3()
], FluentBackplateMaterial.prototype, "globalRightIndexTipPosition", void 0);
RegisterClass("BABYLON.GUI.FluentBackplateMaterial", FluentBackplateMaterial);

// node_modules/@babylonjs/gui/3D/controls/holographicBackplate.js
var HolographicBackplate = class _HolographicBackplate extends Control3D {
  /**
   * Rendering ground id of the backplate mesh.
   */
  set renderingGroupId(id) {
    this._model.renderingGroupId = id;
  }
  get renderingGroupId() {
    return this._model.renderingGroupId;
  }
  /**
   * Gets the material used by the backplate
   */
  get material() {
    return this._material;
  }
  /**
   * Gets a boolean indicating if this backplate shares its material with other HolographicBackplates
   */
  get shareMaterials() {
    return this._shareMaterials;
  }
  /**
   * Creates a new holographic backplate
   * @param name defines the control name
   * @param _shareMaterials
   */
  constructor(name22, _shareMaterials = true) {
    super(name22);
    this._shareMaterials = _shareMaterials;
  }
  _getTypeName() {
    return "HolographicBackplate";
  }
  // Mesh association
  _createNode(scene) {
    const collisionMesh = CreateBox((this.name ?? "HolographicBackplate") + "_CollisionMesh", {
      width: 1,
      height: 1,
      depth: 1
    }, scene);
    collisionMesh.isPickable = true;
    collisionMesh.visibility = 0;
    const baseUrl = Tools.GetAssetUrl(_HolographicBackplate.MODEL_BASE_URL);
    SceneLoader.ImportMeshAsync(void 0, baseUrl, _HolographicBackplate.MODEL_FILENAME, scene).then((result) => {
      const importedModel = result.meshes[1];
      importedModel.name = `${this.name}_frontPlate`;
      importedModel.isPickable = false;
      importedModel.parent = collisionMesh;
      if (this._material) {
        importedModel.material = this._material;
      }
      this._model = importedModel;
    });
    return collisionMesh;
  }
  _createMaterial(mesh) {
    this._material = new FluentBackplateMaterial(this.name + " Material", mesh.getScene());
  }
  _affectMaterial(mesh) {
    if (this._shareMaterials) {
      if (!this._host._touchSharedMaterials["fluentBackplateMaterial"]) {
        this._createMaterial(mesh);
        this._host._touchSharedMaterials["fluentBackplateMaterial"] = this._material;
      } else {
        this._material = this._host._touchSharedMaterials["fluentBackplateMaterial"];
      }
    } else {
      this._createMaterial(mesh);
    }
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    super.dispose();
    if (!this.shareMaterials) {
      this._material.dispose();
    }
    this._model.dispose();
  }
};
HolographicBackplate.MODEL_BASE_URL = "https://assets.babylonjs.com/core/MRTK/";
HolographicBackplate.MODEL_FILENAME = "mrtk-fluent-backplate.glb";

// node_modules/@babylonjs/gui/3D/controls/holographicButton.js
var HolographicButton = class extends Button3D {
  _disposeTooltip() {
    this._tooltipFade = null;
    if (this._tooltipTextBlock) {
      this._tooltipTextBlock.dispose();
    }
    if (this._tooltipTexture) {
      this._tooltipTexture.dispose();
    }
    if (this._tooltipMesh) {
      this._tooltipMesh.dispose();
    }
    this.onPointerEnterObservable.remove(this._tooltipHoverObserver);
    this.onPointerOutObservable.remove(this._tooltipOutObserver);
  }
  /**
   * Rendering ground id of all the mesh in the button
   */
  set renderingGroupId(id) {
    this._backPlate.renderingGroupId = id;
    this._textPlate.renderingGroupId = id;
    this._frontPlate.renderingGroupId = id;
    if (this._tooltipMesh) {
      this._tooltipMesh.renderingGroupId = id;
    }
  }
  get renderingGroupId() {
    return this._backPlate.renderingGroupId;
  }
  /**
   * Text to be displayed on the tooltip shown when hovering on the button. When set to null tooltip is disabled. (Default: null)
   */
  set tooltipText(text) {
    if (!text) {
      this._disposeTooltip();
      return;
    }
    if (!this._tooltipFade) {
      const rightHandedScene = this._backPlate._scene.useRightHandedSystem;
      this._tooltipMesh = CreatePlane("", { size: 1 }, this._backPlate._scene);
      const tooltipBackground = CreatePlane("", { size: 1, sideOrientation: Mesh.DOUBLESIDE }, this._backPlate._scene);
      const mat = new StandardMaterial("", this._backPlate._scene);
      mat.diffuseColor = Color3.FromHexString("#212121");
      tooltipBackground.material = mat;
      tooltipBackground.isPickable = false;
      this._tooltipMesh.addChild(tooltipBackground);
      tooltipBackground.position = Vector3.Forward(rightHandedScene).scale(0.05);
      this._tooltipMesh.scaling.y = 1 / 3;
      this._tooltipMesh.position = Vector3.Up().scale(0.7).add(Vector3.Forward(rightHandedScene).scale(-0.15));
      this._tooltipMesh.isPickable = false;
      this._tooltipMesh.parent = this._backPlate;
      this._tooltipTexture = AdvancedDynamicTexture.CreateForMesh(this._tooltipMesh);
      this._tooltipTextBlock = new TextBlock();
      this._tooltipTextBlock.scaleY = 3;
      this._tooltipTextBlock.color = "white";
      this._tooltipTextBlock.fontSize = 130;
      this._tooltipTexture.addControl(this._tooltipTextBlock);
      this._tooltipFade = new FadeInOutBehavior();
      this._tooltipFade.delay = 500;
      this._tooltipMesh.addBehavior(this._tooltipFade);
      this._tooltipHoverObserver = this.onPointerEnterObservable.add(() => {
        if (this._tooltipFade) {
          this._tooltipFade.fadeIn(true);
        }
      });
      this._tooltipOutObserver = this.onPointerOutObservable.add(() => {
        if (this._tooltipFade) {
          this._tooltipFade.fadeIn(false);
        }
      });
    }
    if (this._tooltipTextBlock) {
      this._tooltipTextBlock.text = text;
    }
  }
  get tooltipText() {
    if (this._tooltipTextBlock) {
      return this._tooltipTextBlock.text;
    }
    return null;
  }
  /**
   * Gets or sets text for the button
   */
  get text() {
    return this._text;
  }
  set text(value) {
    if (this._text === value) {
      return;
    }
    this._text = value;
    this._rebuildContent();
  }
  /**
   * Gets or sets the image url for the button
   */
  get imageUrl() {
    return this._imageUrl;
  }
  set imageUrl(value) {
    if (this._imageUrl === value) {
      return;
    }
    this._imageUrl = value;
    this._rebuildContent();
  }
  /**
   * Gets the back material used by this button
   */
  get backMaterial() {
    return this._backMaterial;
  }
  /**
   * Gets the front material used by this button
   */
  get frontMaterial() {
    return this._frontMaterial;
  }
  /**
   * Gets the plate material used by this button
   */
  get plateMaterial() {
    return this._plateMaterial;
  }
  /**
   * Gets a boolean indicating if this button shares its material with other HolographicButtons
   */
  get shareMaterials() {
    return this._shareMaterials;
  }
  /**
   * Creates a new button
   * @param name defines the control name
   * @param shareMaterials
   */
  constructor(name22, shareMaterials = true) {
    super(name22);
    this._shareMaterials = true;
    this._shareMaterials = shareMaterials;
    this.pointerEnterAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this._frontPlate.setEnabled(true);
    };
    this.pointerOutAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this._frontPlate.setEnabled(false);
    };
  }
  _getTypeName() {
    return "HolographicButton";
  }
  _rebuildContent() {
    this._disposeFacadeTexture();
    const panel = new StackPanel();
    panel.isVertical = true;
    if (IsDocumentAvailable() && !!document.createElement) {
      if (this._imageUrl) {
        const image = new Image();
        image.source = this._imageUrl;
        image.paddingTop = "40px";
        image.height = "180px";
        image.width = "100px";
        image.paddingBottom = "40px";
        panel.addControl(image);
      }
    }
    if (this._text) {
      const text = new TextBlock();
      text.text = this._text;
      text.color = "white";
      text.height = "30px";
      text.fontSize = 24;
      panel.addControl(text);
    }
    if (this._frontPlate) {
      this.content = panel;
    }
  }
  // Mesh association
  _createNode(scene) {
    this._backPlate = CreateBox(this.name + "BackMesh", {
      width: 1,
      height: 1,
      depth: 0.08
    }, scene);
    this._frontPlate = CreateBox(this.name + "FrontMesh", {
      width: 1,
      height: 1,
      depth: 0.08
    }, scene);
    this._frontPlate.parent = this._backPlate;
    this._frontPlate.position = Vector3.Forward(scene.useRightHandedSystem).scale(-0.08);
    this._frontPlate.isPickable = false;
    this._frontPlate.setEnabled(false);
    this._textPlate = super._createNode(scene);
    this._textPlate.parent = this._backPlate;
    this._textPlate.position = Vector3.Forward(scene.useRightHandedSystem).scale(-0.08);
    this._textPlate.isPickable = false;
    return this._backPlate;
  }
  _applyFacade(facadeTexture) {
    this._plateMaterial.emissiveTexture = facadeTexture;
    this._plateMaterial.opacityTexture = facadeTexture;
  }
  _createBackMaterial(mesh) {
    this._backMaterial = new FluentMaterial(this.name + "Back Material", mesh.getScene());
    this._backMaterial.renderHoverLight = true;
    this._pickedPointObserver = this._host.onPickedPointChangedObservable.add((pickedPoint) => {
      if (pickedPoint) {
        this._backMaterial.hoverPosition = pickedPoint;
        this._backMaterial.hoverColor.a = 1;
      } else {
        this._backMaterial.hoverColor.a = 0;
      }
    });
  }
  _createFrontMaterial(mesh) {
    this._frontMaterial = new FluentMaterial(this.name + "Front Material", mesh.getScene());
    this._frontMaterial.innerGlowColorIntensity = 0;
    this._frontMaterial.alpha = 0.5;
    this._frontMaterial.renderBorders = true;
  }
  _createPlateMaterial(mesh) {
    this._plateMaterial = new StandardMaterial(this.name + "Plate Material", mesh.getScene());
    this._plateMaterial.specularColor = Color3.Black();
  }
  _affectMaterial(mesh) {
    if (this._shareMaterials) {
      if (!this._host._sharedMaterials["backFluentMaterial"]) {
        this._createBackMaterial(mesh);
        this._host._sharedMaterials["backFluentMaterial"] = this._backMaterial;
      } else {
        this._backMaterial = this._host._sharedMaterials["backFluentMaterial"];
      }
      if (!this._host._sharedMaterials["frontFluentMaterial"]) {
        this._createFrontMaterial(mesh);
        this._host._sharedMaterials["frontFluentMaterial"] = this._frontMaterial;
      } else {
        this._frontMaterial = this._host._sharedMaterials["frontFluentMaterial"];
      }
    } else {
      this._createBackMaterial(mesh);
      this._createFrontMaterial(mesh);
    }
    this._createPlateMaterial(mesh);
    this._backPlate.material = this._backMaterial;
    this._frontPlate.material = this._frontMaterial;
    this._textPlate.material = this._plateMaterial;
    this._rebuildContent();
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    super.dispose();
    this._disposeTooltip();
    if (!this.shareMaterials) {
      this._backMaterial.dispose();
      this._frontMaterial.dispose();
      this._plateMaterial.dispose();
      if (this._pickedPointObserver) {
        this._host.onPickedPointChangedObservable.remove(this._pickedPointObserver);
        this._pickedPointObserver = null;
      }
    }
  }
};

// node_modules/@babylonjs/gui/3D/materials/fluentButton/shaders/fluentButton.fragment.js
var name6 = "fluentButtonPixelShader";
var shader5 = `uniform vec3 cameraPosition;varying vec3 vPosition;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec3 vBinormal;varying vec4 vColor;varying vec4 vExtra1;uniform float _Edge_Width_;uniform vec4 _Edge_Color_;uniform bool _Relative_Width_;uniform float _Proximity_Max_Intensity_;uniform float _Proximity_Far_Distance_;uniform float _Proximity_Near_Radius_;uniform float _Proximity_Anisotropy_;uniform float _Selection_Fuzz_;uniform float _Selected_;uniform float _Selection_Fade_;uniform float _Selection_Fade_Size_;uniform float _Selected_Distance_;uniform float _Selected_Fade_Length_;uniform bool _Blob_Enable_;uniform vec3 _Blob_Position_;uniform float _Blob_Intensity_;uniform float _Blob_Near_Size_;uniform float _Blob_Far_Size_;uniform float _Blob_Near_Distance_;uniform float _Blob_Far_Distance_;uniform float _Blob_Fade_Length_;uniform float _Blob_Inner_Fade_;uniform float _Blob_Pulse_;uniform float _Blob_Fade_;uniform sampler2D _Blob_Texture_;uniform bool _Blob_Enable_2_;uniform vec3 _Blob_Position_2_;uniform float _Blob_Near_Size_2_;uniform float _Blob_Inner_Fade_2_;uniform float _Blob_Pulse_2_;uniform float _Blob_Fade_2_;uniform vec3 _Active_Face_Dir_;uniform vec3 _Active_Face_Up_;uniform bool Enable_Fade;uniform float _Fade_Width_;uniform bool _Smooth_Active_Face_;uniform bool _Show_Frame_;uniform bool _Use_Blob_Texture_;uniform bool Use_Global_Left_Index;uniform bool Use_Global_Right_Index;uniform vec4 Global_Left_Index_Tip_Position;uniform vec4 Global_Right_Index_Tip_Position;uniform vec4 Global_Left_Thumb_Tip_Position;uniform vec4 Global_Right_Thumb_Tip_Position;uniform float Global_Left_Index_Tip_Proximity;uniform float Global_Right_Index_Tip_Proximity;void Holo_Edge_Fragment_B35(
vec4 Edges,
float Edge_Width,
out float NotEdge)
{vec2 c=vec2(min(Edges.r,Edges.g),min(Edges.b,Edges.a));vec2 df=fwidth(c)*Edge_Width;vec2 g=clamp(c/df,0.0,1.0);NotEdge=g.x*g.y;}
void Blob_Fragment_B39(
vec2 UV,
vec3 Blob_Info,
sampler2D Blob_Texture,
out vec4 Blob_Color)
{float k=dot(UV,UV);Blob_Color=Blob_Info.y*texture(Blob_Texture,vec2(vec2(sqrt(k),Blob_Info.x).x,1.0-vec2(sqrt(k),Blob_Info.x).y))*(1.0-clamp(k,0.0,1.0));}
vec2 FilterStep(vec2 Edge,vec2 X)
{vec2 dX=max(fwidth(X),vec2(0.00001,0.00001));return clamp( (X+dX-max(Edge,X-dX))/(dX*2.0),0.0,1.0);}
void Wireframe_Fragment_B59(
vec3 Widths,
vec2 UV,
float Proximity,
vec4 Edge_Color,
out vec4 Wireframe)
{vec2 c=min(UV,vec2(1.0,1.0)-UV);vec2 g=FilterStep(Widths.xy*0.5,c); 
Wireframe=(1.0-min(g.x,g.y))*Proximity*Edge_Color;}
void Proximity_B53(
vec3 Proximity_Center,
vec3 Proximity_Center_2,
float Proximity_Max_Intensity,
float Proximity_Near_Radius,
vec3 Position,
vec3 Show_Selection,
vec4 Extra1,
float Dist_To_Face,
float Intensity,
out float Proximity)
{vec2 delta1=Extra1.xy;vec2 delta2=Extra1.zw;float d2=sqrt(min(dot(delta1,delta1),dot(delta2,delta2))+Dist_To_Face*Dist_To_Face);Proximity=Intensity*Proximity_Max_Intensity*(1.0-clamp(d2/Proximity_Near_Radius,0.0,1.0))*(1.0-Show_Selection.x)+Show_Selection.x;}
void To_XYZ_B46(
vec3 Vec3,
out float X,
out float Y,
out float Z)
{X=Vec3.x;Y=Vec3.y;Z=Vec3.z;}
void main()
{float NotEdge_Q35;
#if ENABLE_FADE
Holo_Edge_Fragment_B35(vColor,_Fade_Width_,NotEdge_Q35);
#else
NotEdge_Q35=1.0;
#endif
vec4 Blob_Color_Q39;float k=dot(vUV,vUV);vec2 blobTextureCoord=vec2(vec2(sqrt(k),vTangent.x).x,1.0-vec2(sqrt(k),vTangent.x).y);vec4 blobColor=mix(vec4(1.0,1.0,1.0,1.0)*step(1.0-vTangent.x,clamp(sqrt(k)+0.1,0.0,1.0)),texture(_Blob_Texture_,blobTextureCoord),float(_Use_Blob_Texture_));Blob_Color_Q39=vTangent.y*blobColor*(1.0-clamp(k,0.0,1.0));float Is_Quad_Q24;Is_Quad_Q24=vNormal.z;vec3 Blob_Position_Q41= mix(_Blob_Position_,Global_Left_Index_Tip_Position.xyz,float(Use_Global_Left_Index));vec3 Blob_Position_Q42= mix(_Blob_Position_2_,Global_Right_Index_Tip_Position.xyz,float(Use_Global_Right_Index));float X_Q46;float Y_Q46;float Z_Q46;To_XYZ_B46(vBinormal,X_Q46,Y_Q46,Z_Q46);float Proximity_Q53;Proximity_B53(Blob_Position_Q41,Blob_Position_Q42,_Proximity_Max_Intensity_,_Proximity_Near_Radius_,vPosition,vBinormal,vExtra1,Y_Q46,Z_Q46,Proximity_Q53);vec4 Wireframe_Q59;Wireframe_Fragment_B59(vNormal,vUV,Proximity_Q53,_Edge_Color_,Wireframe_Q59);vec4 Wire_Or_Blob_Q23=mix(Wireframe_Q59,Blob_Color_Q39,Is_Quad_Q24);vec4 Result_Q22;Result_Q22=mix(Wire_Or_Blob_Q23,vec4(0.3,0.3,0.3,0.3),float(_Show_Frame_));vec4 Final_Color_Q37=NotEdge_Q35*Result_Q22;vec4 Out_Color=Final_Color_Q37;float Clip_Threshold=0.0;bool To_sRGB=false;gl_FragColor=Out_Color;}`;
if (!ShaderStore.ShadersStore[name6]) {
  ShaderStore.ShadersStore[name6] = shader5;
}

// node_modules/@babylonjs/gui/3D/materials/fluentButton/shaders/fluentButton.vertex.js
var name7 = "fluentButtonVertexShader";
var shader6 = `uniform mat4 world;uniform mat4 viewProjection;uniform vec3 cameraPosition;attribute vec3 position;attribute vec3 normal;attribute vec2 uv;attribute vec3 tangent;attribute vec4 color;uniform float _Edge_Width_;uniform vec4 _Edge_Color_;uniform float _Proximity_Max_Intensity_;uniform float _Proximity_Far_Distance_;uniform float _Proximity_Near_Radius_;uniform float _Proximity_Anisotropy_;uniform float _Selection_Fuzz_;uniform float _Selected_;uniform float _Selection_Fade_;uniform float _Selection_Fade_Size_;uniform float _Selected_Distance_;uniform float _Selected_Fade_Length_;uniform bool _Blob_Enable_;uniform vec3 _Blob_Position_;uniform float _Blob_Intensity_;uniform float _Blob_Near_Size_;uniform float _Blob_Far_Size_;uniform float _Blob_Near_Distance_;uniform float _Blob_Far_Distance_;uniform float _Blob_Fade_Length_;uniform float _Blob_Inner_Fade_;uniform float _Blob_Pulse_;uniform float _Blob_Fade_;uniform sampler2D _Blob_Texture_;uniform bool _Blob_Enable_2_;uniform vec3 _Blob_Position_2_;uniform float _Blob_Near_Size_2_;uniform float _Blob_Inner_Fade_2_;uniform float _Blob_Pulse_2_;uniform float _Blob_Fade_2_;uniform vec3 _Active_Face_Dir_;uniform vec3 _Active_Face_Up_;uniform bool _Enable_Fade_;uniform float _Fade_Width_;uniform bool _Smooth_Active_Face_;uniform bool _Show_Frame_;uniform bool Use_Global_Left_Index;uniform bool Use_Global_Right_Index;uniform vec4 Global_Left_Index_Tip_Position;uniform vec4 Global_Right_Index_Tip_Position;uniform vec4 Global_Left_Thumb_Tip_Position;uniform vec4 Global_Right_Thumb_Tip_Position;uniform float Global_Left_Index_Tip_Proximity;uniform float Global_Right_Index_Tip_Proximity;varying vec3 vPosition;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec3 vBinormal;varying vec4 vColor;varying vec4 vExtra1;void Blob_Vertex_B47(
vec3 Position,
vec3 Normal,
vec3 Tangent,
vec3 Bitangent,
vec3 Blob_Position,
float Intensity,
float Blob_Near_Size,
float Blob_Far_Size,
float Blob_Near_Distance,
float Blob_Far_Distance,
vec4 Vx_Color,
vec2 UV,
vec3 Face_Center,
vec2 Face_Size,
vec2 In_UV,
float Blob_Fade_Length,
float Selection_Fade,
float Selection_Fade_Size,
float Inner_Fade,
vec3 Active_Face_Center,
float Blob_Pulse,
float Blob_Fade,
float Blob_Enabled,
out vec3 Out_Position,
out vec2 Out_UV,
out vec3 Blob_Info)
{float blobSize,fadeIn;vec3 Hit_Position;Blob_Info=vec3(0.0,0.0,0.0);float Hit_Distance=dot(Blob_Position-Face_Center,Normal);Hit_Position=Blob_Position-Hit_Distance*Normal;float absD=abs(Hit_Distance);float lerpVal=clamp((absD-Blob_Near_Distance)/(Blob_Far_Distance-Blob_Near_Distance),0.0,1.0);fadeIn=1.0-clamp((absD-Blob_Far_Distance)/Blob_Fade_Length,0.0,1.0);float innerFade=1.0-clamp(-Hit_Distance/Inner_Fade,0.0,1.0);float farClip=clamp(1.0-step(Blob_Far_Distance+Blob_Fade_Length,absD),0.0,1.0);float size=mix(Blob_Near_Size,Blob_Far_Size,lerpVal)*farClip;blobSize=mix(size,Selection_Fade_Size,Selection_Fade)*innerFade*Blob_Enabled;Blob_Info.x=lerpVal*0.5+0.5;Blob_Info.y=fadeIn*Intensity*(1.0-Selection_Fade)*Blob_Fade;Blob_Info.x*=(1.0-Blob_Pulse);vec3 delta=Hit_Position-Face_Center;vec2 blobCenterXY=vec2(dot(delta,Tangent),dot(delta,Bitangent));vec2 quadUVin=2.0*UV-1.0; 
vec2 blobXY=blobCenterXY+quadUVin*blobSize;vec2 blobClipped=clamp(blobXY,-Face_Size*0.5,Face_Size*0.5);vec2 blobUV=(blobClipped-blobCenterXY)/max(blobSize,0.0001)*2.0;vec3 blobCorner=Face_Center+blobClipped.x*Tangent+blobClipped.y*Bitangent;Out_Position=mix(Position,blobCorner,Vx_Color.rrr);Out_UV=mix(In_UV,blobUV,Vx_Color.rr);}
vec2 ProjectProximity(
vec3 blobPosition,
vec3 position,
vec3 center,
vec3 dir,
vec3 xdir,
vec3 ydir,
out float vdistance
)
{vec3 delta=blobPosition-position;vec2 xy=vec2(dot(delta,xdir),dot(delta,ydir));vdistance=abs(dot(delta,dir));return xy;}
void Proximity_Vertex_B66(
vec3 Blob_Position,
vec3 Blob_Position_2,
vec3 Active_Face_Center,
vec3 Active_Face_Dir,
vec3 Position,
float Proximity_Far_Distance,
float Relative_Scale,
float Proximity_Anisotropy,
vec3 Up,
out vec4 Extra1,
out float Distance_To_Face,
out float Intensity)
{vec3 Active_Face_Dir_X=normalize(cross(Active_Face_Dir,Up));vec3 Active_Face_Dir_Y=cross(Active_Face_Dir,Active_Face_Dir_X);float distz1,distz2;Extra1.xy=ProjectProximity(Blob_Position,Position,Active_Face_Center,Active_Face_Dir,Active_Face_Dir_X*Proximity_Anisotropy,Active_Face_Dir_Y,distz1)/Relative_Scale;Extra1.zw=ProjectProximity(Blob_Position_2,Position,Active_Face_Center,Active_Face_Dir,Active_Face_Dir_X*Proximity_Anisotropy,Active_Face_Dir_Y,distz2)/Relative_Scale;Distance_To_Face=dot(Active_Face_Dir,Position-Active_Face_Center);Intensity=1.0-clamp(min(distz1,distz2)/Proximity_Far_Distance,0.0,1.0);}
void Holo_Edge_Vertex_B44(
vec3 Incident,
vec3 Normal,
vec2 UV,
vec3 Tangent,
vec3 Bitangent,
bool Smooth_Active_Face,
float Active,
out vec4 Holo_Edges)
{float NdotI=dot(Incident,Normal);vec2 flip=(UV-vec2(0.5,0.5));float udot=dot(Incident,Tangent)*flip.x*NdotI;float uval=1.0-float(udot>0.0);float vdot=-dot(Incident,Bitangent)*flip.y*NdotI;float vval=1.0-float(vdot>0.0);float Smooth_And_Active=step(1.0,float(Smooth_Active_Face && Active>0.0));uval=mix(uval,max(1.0,uval),Smooth_And_Active); 
vval=mix(vval,max(1.0,vval),Smooth_And_Active);Holo_Edges=vec4(1.0,1.0,1.0,1.0)-vec4(uval*UV.x,uval*(1.0-UV.x),vval*UV.y,vval*(1.0-UV.y));}
void Object_To_World_Pos_B13(
vec3 Pos_Object,
out vec3 Pos_World)
{Pos_World=(world*vec4(Pos_Object,1.0)).xyz;}
void Choose_Blob_B38(
vec4 Vx_Color,
vec3 Position1,
vec3 Position2,
bool Blob_Enable_1,
bool Blob_Enable_2,
float Near_Size_1,
float Near_Size_2,
float Blob_Inner_Fade_1,
float Blob_Inner_Fade_2,
float Blob_Pulse_1,
float Blob_Pulse_2,
float Blob_Fade_1,
float Blob_Fade_2,
out vec3 Position,
out float Near_Size,
out float Inner_Fade,
out float Blob_Enable,
out float Fade,
out float Pulse)
{Position=Position1*(1.0-Vx_Color.g)+Vx_Color.g*Position2;float b1=float(Blob_Enable_1);float b2=float(Blob_Enable_2);Blob_Enable=b1+(b2-b1)*Vx_Color.g;Pulse=Blob_Pulse_1*(1.0-Vx_Color.g)+Vx_Color.g*Blob_Pulse_2;Fade=Blob_Fade_1*(1.0-Vx_Color.g)+Vx_Color.g*Blob_Fade_2;Near_Size=Near_Size_1*(1.0-Vx_Color.g)+Vx_Color.g*Near_Size_2;Inner_Fade=Blob_Inner_Fade_1*(1.0-Vx_Color.g)+Vx_Color.g*Blob_Inner_Fade_2;}
void Wireframe_Vertex_B51(
vec3 Position,
vec3 Normal,
vec3 Tangent,
vec3 Bitangent,
float Edge_Width,
vec2 Face_Size,
out vec3 Wire_Vx_Pos,
out vec2 UV,
out vec2 Widths)
{Widths.xy=Edge_Width/Face_Size;float x=dot(Position,Tangent);float y=dot(Position,Bitangent);float dx=0.5-abs(x);float newx=(0.5-dx*Widths.x*2.0)*sign(x);float dy=0.5-abs(y);float newy=(0.5-dy*Widths.y*2.0)*sign(y);Wire_Vx_Pos=Normal*0.5+newx*Tangent+newy*Bitangent;UV.x=dot(Wire_Vx_Pos,Tangent)+0.5;UV.y=dot(Wire_Vx_Pos,Bitangent)+0.5;}
vec2 ramp2(vec2 start,vec2 end,vec2 x)
{return clamp((x-start)/(end-start),vec2(0.0,0.0),vec2(1.0,1.0));}
float computeSelection(
vec3 blobPosition,
vec3 normal,
vec3 tangent,
vec3 bitangent,
vec3 faceCenter,
vec2 faceSize,
float selectionFuzz,
float farDistance,
float fadeLength
)
{vec3 delta=blobPosition-faceCenter;float absD=abs(dot(delta,normal));float fadeIn=1.0-clamp((absD-farDistance)/fadeLength,0.0,1.0);vec2 blobCenterXY=vec2(dot(delta,tangent),dot(delta,bitangent));vec2 innerFace=faceSize*(1.0-selectionFuzz)*0.5;vec2 selectPulse=ramp2(-faceSize*0.5,-innerFace,blobCenterXY)-ramp2(innerFace,faceSize*0.5,blobCenterXY);return selectPulse.x*selectPulse.y*fadeIn;}
void Selection_Vertex_B48(
vec3 Blob_Position,
vec3 Blob_Position_2,
vec3 Face_Center,
vec2 Face_Size,
vec3 Normal,
vec3 Tangent,
vec3 Bitangent,
float Selection_Fuzz,
float Selected,
float Far_Distance,
float Fade_Length,
vec3 Active_Face_Dir,
out float Show_Selection)
{float select1=computeSelection(Blob_Position,Normal,Tangent,Bitangent,Face_Center,Face_Size,Selection_Fuzz,Far_Distance,Fade_Length);float select2=computeSelection(Blob_Position_2,Normal,Tangent,Bitangent,Face_Center,Face_Size,Selection_Fuzz,Far_Distance,Fade_Length);float Active=max(0.0,dot(Active_Face_Dir,Normal));Show_Selection=mix(max(select1,select2),1.0,Selected)*Active;}
void Proximity_Visibility_B54(
float Selection,
vec3 Proximity_Center,
vec3 Proximity_Center_2,
float Input_Width,
float Proximity_Far_Distance,
float Proximity_Radius,
vec3 Active_Face_Center,
vec3 Active_Face_Dir,
out float Width)
{vec3 boxEdges=(world*vec4(vec3(0.5,0.5,0.5),0.0)).xyz;float boxMaxSize=length(boxEdges);float d1=dot(Proximity_Center-Active_Face_Center,Active_Face_Dir);vec3 blob1=Proximity_Center-d1*Active_Face_Dir;float d2=dot(Proximity_Center_2-Active_Face_Center,Active_Face_Dir);vec3 blob2=Proximity_Center_2-d2*Active_Face_Dir;vec3 delta1=blob1-Active_Face_Center;vec3 delta2=blob2-Active_Face_Center;float dist1=dot(delta1,delta1);float dist2=dot(delta2,delta2);float nearestProxDist=sqrt(min(dist1,dist2));Width=Input_Width*(1.0-step(boxMaxSize+Proximity_Radius,nearestProxDist))*(1.0-step(Proximity_Far_Distance,min(d1,d2))*(1.0-step(0.0001,Selection)));}
void Object_To_World_Dir_B67(
vec3 Dir_Object,
out vec3 Dir_World)
{Dir_World=(world*vec4(Dir_Object,0.0)).xyz;}
void main()
{vec3 Active_Face_Center_Q49;Active_Face_Center_Q49=(world*vec4(_Active_Face_Dir_*0.5,1.0)).xyz;vec3 Blob_Position_Q41= mix(_Blob_Position_,Global_Left_Index_Tip_Position.xyz,float(Use_Global_Left_Index));vec3 Blob_Position_Q42= mix(_Blob_Position_2_,Global_Right_Index_Tip_Position.xyz,float(Use_Global_Right_Index));vec3 Active_Face_Dir_Q64=normalize((world*vec4(_Active_Face_Dir_,0.0)).xyz);float Relative_Scale_Q57;
#if RELATIVE_WIDTH
Relative_Scale_Q57=length((world*vec4(vec3(0,1,0),0.0)).xyz);
#else
Relative_Scale_Q57=1.0;
#endif
vec3 Tangent_World_Q30;Tangent_World_Q30=(world*vec4(tangent,0.0)).xyz;vec3 Binormal_World_Q31;Binormal_World_Q31=(world*vec4((cross(normal,tangent)),0.0)).xyz;vec3 Normal_World_Q60;Normal_World_Q60=(world*vec4(normal,0.0)).xyz;vec3 Result_Q18=0.5*normal;vec3 Dir_World_Q67;Object_To_World_Dir_B67(_Active_Face_Up_,Dir_World_Q67);float Product_Q56=_Edge_Width_*Relative_Scale_Q57;vec3 Normal_World_N_Q29=normalize(Normal_World_Q60);vec3 Tangent_World_N_Q28=normalize(Tangent_World_Q30);vec3 Binormal_World_N_Q32=normalize(Binormal_World_Q31);vec3 Position_Q38;float Near_Size_Q38;float Inner_Fade_Q38;float Blob_Enable_Q38;float Fade_Q38;float Pulse_Q38;Choose_Blob_B38(color,Blob_Position_Q41,Blob_Position_Q42,_Blob_Enable_,_Blob_Enable_2_,_Blob_Near_Size_,_Blob_Near_Size_2_,_Blob_Inner_Fade_,_Blob_Inner_Fade_2_,_Blob_Pulse_,_Blob_Pulse_2_,_Blob_Fade_,_Blob_Fade_2_,Position_Q38,Near_Size_Q38,Inner_Fade_Q38,Blob_Enable_Q38,Fade_Q38,Pulse_Q38);vec3 Face_Center_Q33;Face_Center_Q33=(world*vec4(Result_Q18,1.0)).xyz;vec2 Face_Size_Q50=vec2(length(Tangent_World_Q30),length(Binormal_World_Q31));float Show_Selection_Q48;Selection_Vertex_B48(Blob_Position_Q41,Blob_Position_Q42,Face_Center_Q33,Face_Size_Q50,Normal_World_N_Q29,Tangent_World_N_Q28,Binormal_World_N_Q32,_Selection_Fuzz_,_Selected_,_Selected_Distance_,_Selected_Fade_Length_,Active_Face_Dir_Q64,Show_Selection_Q48);vec3 Normalized_Q72=normalize(Dir_World_Q67);float Active_Q34=max(0.0,dot(Active_Face_Dir_Q64,Normal_World_N_Q29));float Width_Q54;Proximity_Visibility_B54(Show_Selection_Q48,Blob_Position_Q41,Blob_Position_Q42,Product_Q56,_Proximity_Far_Distance_,_Proximity_Near_Radius_,Active_Face_Center_Q49,Active_Face_Dir_Q64,Width_Q54);vec3 Wire_Vx_Pos_Q51;vec2 UV_Q51;vec2 Widths_Q51;Wireframe_Vertex_B51(position,normal,tangent,(cross(normal,tangent)),Width_Q54,Face_Size_Q50,Wire_Vx_Pos_Q51,UV_Q51,Widths_Q51);vec3 Vec3_Q27=vec3(Widths_Q51.x,Widths_Q51.y,color.r);vec3 Pos_World_Q13;Object_To_World_Pos_B13(Wire_Vx_Pos_Q51,Pos_World_Q13);vec3 Incident_Q36=normalize(Pos_World_Q13-cameraPosition);vec3 Out_Position_Q47;vec2 Out_UV_Q47;vec3 Blob_Info_Q47;Blob_Vertex_B47(Pos_World_Q13,Normal_World_N_Q29,Tangent_World_N_Q28,Binormal_World_N_Q32,Position_Q38,_Blob_Intensity_,Near_Size_Q38,_Blob_Far_Size_,_Blob_Near_Distance_,_Blob_Far_Distance_,color,uv,Face_Center_Q33,Face_Size_Q50,UV_Q51,_Blob_Fade_Length_,_Selection_Fade_,_Selection_Fade_Size_,Inner_Fade_Q38,Active_Face_Center_Q49,Pulse_Q38,Fade_Q38,Blob_Enable_Q38,Out_Position_Q47,Out_UV_Q47,Blob_Info_Q47);vec4 Extra1_Q66;float Distance_To_Face_Q66;float Intensity_Q66;Proximity_Vertex_B66(Blob_Position_Q41,Blob_Position_Q42,Active_Face_Center_Q49,Active_Face_Dir_Q64,Pos_World_Q13,_Proximity_Far_Distance_,Relative_Scale_Q57,_Proximity_Anisotropy_,Normalized_Q72,Extra1_Q66,Distance_To_Face_Q66,Intensity_Q66);vec4 Holo_Edges_Q44;Holo_Edge_Vertex_B44(Incident_Q36,Normal_World_N_Q29,uv,Tangent_World_Q30,Binormal_World_Q31,_Smooth_Active_Face_,Active_Q34,Holo_Edges_Q44);vec3 Vec3_Q19=vec3(Show_Selection_Q48,Distance_To_Face_Q66,Intensity_Q66);vec3 Position=Out_Position_Q47;vec2 UV=Out_UV_Q47;vec3 Tangent=Blob_Info_Q47;vec3 Binormal=Vec3_Q19;vec3 Normal=Vec3_Q27;vec4 Extra1=Extra1_Q66;vec4 Color=Holo_Edges_Q44;gl_Position=viewProjection*vec4(Position,1);vPosition=Position;vNormal=Normal;vUV=UV;vTangent=Tangent;vBinormal=Binormal;vColor=Color;vExtra1=Extra1;}`;
if (!ShaderStore.ShadersStore[name7]) {
  ShaderStore.ShadersStore[name7] = shader6;
}

// node_modules/@babylonjs/gui/3D/materials/fluentButton/fluentButtonMaterial.js
var FluentButtonMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.RELATIVE_WIDTH = true;
    this.ENABLE_FADE = true;
    this._needNormals = true;
    this._needUVs = true;
    this.rebuild();
  }
};
var FluentButtonMaterial = class _FluentButtonMaterial extends PushMaterial {
  constructor(name22, scene) {
    super(name22, scene);
    this.edgeWidth = 0.04;
    this.edgeColor = new Color4(0.592157, 0.592157, 0.592157, 1);
    this.proximityMaxIntensity = 0.45;
    this.proximityFarDistance = 0.16;
    this.proximityNearRadius = 1.5;
    this.proximityAnisotropy = 1;
    this.selectionFuzz = 0.5;
    this.selected = 0;
    this.selectionFade = 0;
    this.selectionFadeSize = 0.3;
    this.selectedDistance = 0.08;
    this.selectedFadeLength = 0.08;
    this.blobIntensity = 0.5;
    this.blobFarSize = 0.05;
    this.blobNearDistance = 0;
    this.blobFarDistance = 0.08;
    this.blobFadeLength = 0.08;
    this.leftBlobEnable = true;
    this.leftBlobNearSize = 0.025;
    this.leftBlobPulse = 0;
    this.leftBlobFade = 1;
    this.leftBlobInnerFade = 0.01;
    this.rightBlobEnable = true;
    this.rightBlobNearSize = 0.025;
    this.rightBlobPulse = 0;
    this.rightBlobFade = 1;
    this.rightBlobInnerFade = 0.01;
    this.activeFaceDir = new Vector3(0, 0, -1);
    this.activeFaceUp = new Vector3(0, 1, 0);
    this.enableFade = true;
    this.fadeWidth = 1.5;
    this.smoothActiveFace = true;
    this.showFrame = false;
    this.useBlobTexture = true;
    this.globalLeftIndexTipPosition = Vector3.Zero();
    this.globalRightIndexTipPosition = Vector3.Zero();
    this.alphaMode = Constants.ALPHA_ADD;
    this.disableDepthWrite = true;
    this.backFaceCulling = false;
    const blobTextureUrl = Tools.GetAssetUrl(_FluentButtonMaterial.BLOB_TEXTURE_URL);
    this._blobTexture = new Texture(blobTextureUrl, this.getScene(), true, false, Texture.NEAREST_SAMPLINGMODE);
  }
  needAlphaBlending() {
    return true;
  }
  needAlphaTesting() {
    return true;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new FluentButtonMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    PrepareDefinesForAttributes(mesh, defines, true, false);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks);
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      if (defines.TANGENT) {
        attribs.push(VertexBuffer.TangentKind);
      }
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "fluentButton";
      const join = defines.toString();
      const uniforms = [
        "world",
        "viewProjection",
        "cameraPosition",
        "_Edge_Width_",
        "_Edge_Color_",
        "_Relative_Width_",
        "_Proximity_Max_Intensity_",
        "_Proximity_Far_Distance_",
        "_Proximity_Near_Radius_",
        "_Proximity_Anisotropy_",
        "_Selection_Fuzz_",
        "_Selected_",
        "_Selection_Fade_",
        "_Selection_Fade_Size_",
        "_Selected_Distance_",
        "_Selected_Fade_Length_",
        "_Blob_Enable_",
        "_Blob_Position_",
        "_Blob_Intensity_",
        "_Blob_Near_Size_",
        "_Blob_Far_Size_",
        "_Blob_Near_Distance_",
        "_Blob_Far_Distance_",
        "_Blob_Fade_Length_",
        "_Blob_Inner_Fade_",
        "_Blob_Pulse_",
        "_Blob_Fade_",
        "_Blob_Texture_",
        "_Blob_Enable_2_",
        "_Blob_Position_2_",
        "_Blob_Near_Size_2_",
        "_Blob_Inner_Fade_2_",
        "_Blob_Pulse_2_",
        "_Blob_Fade_2_",
        "_Active_Face_Dir_",
        "_Active_Face_Up_",
        "_Enable_Fade_",
        "_Fade_Width_",
        "_Smooth_Active_Face_",
        "_Show_Frame_",
        "_Use_Blob_Texture_",
        "Use_Global_Left_Index",
        "Use_Global_Right_Index",
        "Global_Left_Index_Tip_Position",
        "Global_Right_Index_Tip_Position",
        "Global_Left_Thumb_Tip_Position",
        "Global_Right_Thumb_Tip_Position",
        "Global_Left_Index_Tip_Proximity",
        "Global_Right_Index_Tip_Proximity"
      ];
      const samplers = ["_Blob_Texture_"];
      const uniformBuffers = [];
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 4
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 4 }
      }, engine), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    this._activeEffect.setVector3("cameraPosition", scene.activeCamera.position);
    this._activeEffect.setTexture("_Blob_Texture_", this._blobTexture);
    this._activeEffect.setFloat("_Edge_Width_", this.edgeWidth);
    this._activeEffect.setColor4("_Edge_Color_", new Color3(this.edgeColor.r, this.edgeColor.g, this.edgeColor.b), this.edgeColor.a);
    this._activeEffect.setFloat("_Proximity_Max_Intensity_", this.proximityMaxIntensity);
    this._activeEffect.setFloat("_Proximity_Far_Distance_", this.proximityFarDistance);
    this._activeEffect.setFloat("_Proximity_Near_Radius_", this.proximityNearRadius);
    this._activeEffect.setFloat("_Proximity_Anisotropy_", this.proximityAnisotropy);
    this._activeEffect.setFloat("_Selection_Fuzz_", this.selectionFuzz);
    this._activeEffect.setFloat("_Selected_", this.selected);
    this._activeEffect.setFloat("_Selection_Fade_", this.selectionFade);
    this._activeEffect.setFloat("_Selection_Fade_Size_", this.selectionFadeSize);
    this._activeEffect.setFloat("_Selected_Distance_", this.selectedDistance);
    this._activeEffect.setFloat("_Selected_Fade_Length_", this.selectedFadeLength);
    this._activeEffect.setFloat("_Blob_Enable_", this.leftBlobEnable ? 1 : 0);
    this._activeEffect.setFloat("_Blob_Intensity_", this.blobIntensity);
    this._activeEffect.setFloat("_Blob_Near_Size_", this.leftBlobNearSize);
    this._activeEffect.setFloat("_Blob_Far_Size_", this.blobFarSize);
    this._activeEffect.setFloat("_Blob_Near_Distance_", this.blobNearDistance);
    this._activeEffect.setFloat("_Blob_Far_Distance_", this.blobFarDistance);
    this._activeEffect.setFloat("_Blob_Fade_Length_", this.blobFadeLength);
    this._activeEffect.setFloat("_Blob_Inner_Fade_", this.leftBlobInnerFade);
    this._activeEffect.setFloat("_Blob_Pulse_", this.leftBlobPulse);
    this._activeEffect.setFloat("_Blob_Fade_", this.leftBlobFade);
    this._activeEffect.setFloat("_Blob_Enable_2_", this.rightBlobEnable ? 1 : 0);
    this._activeEffect.setFloat("_Blob_Near_Size_2_", this.rightBlobNearSize);
    this._activeEffect.setFloat("_Blob_Inner_Fade_2_", this.rightBlobInnerFade);
    this._activeEffect.setFloat("_Blob_Pulse_2_", this.rightBlobPulse);
    this._activeEffect.setFloat("_Blob_Fade_2_", this.rightBlobFade);
    this._activeEffect.setVector3("_Active_Face_Dir_", this.activeFaceDir);
    this._activeEffect.setVector3("_Active_Face_Up_", this.activeFaceUp);
    this._activeEffect.setFloat("_Fade_Width_", this.fadeWidth);
    this._activeEffect.setFloat("_Smooth_Active_Face_", this.smoothActiveFace ? 1 : 0);
    this._activeEffect.setFloat("_Show_Frame_", this.showFrame ? 1 : 0);
    this._activeEffect.setFloat("_Use_Blob_Texture_", this.useBlobTexture ? 1 : 0);
    this._activeEffect.setFloat("Use_Global_Left_Index", 1);
    this._activeEffect.setFloat("Use_Global_Right_Index", 1);
    this._activeEffect.setVector4("Global_Left_Index_Tip_Position", new Vector4(this.globalLeftIndexTipPosition.x, this.globalLeftIndexTipPosition.y, this.globalLeftIndexTipPosition.z, 1));
    this._activeEffect.setVector4("Global_Right_Index_Tip_Position", new Vector4(this.globalRightIndexTipPosition.x, this.globalRightIndexTipPosition.y, this.globalRightIndexTipPosition.z, 1));
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  /**
   * Get the list of animatables in the material.
   * @returns the list of animatables object used in the material
   */
  getAnimatables() {
    return [];
  }
  dispose(forceDisposeEffect) {
    super.dispose(forceDisposeEffect);
  }
  clone(name22) {
    return SerializationHelper.Clone(() => new _FluentButtonMaterial(name22, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.FluentButtonMaterial";
    return serializationObject;
  }
  getClassName() {
    return "FluentButtonMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _FluentButtonMaterial(source.name, scene), source, scene, rootUrl);
  }
};
FluentButtonMaterial.BLOB_TEXTURE_URL = "https://assets.babylonjs.com/core/MRTK/mrtk-fluent-button-blob.png";
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "edgeWidth", void 0);
__decorate([
  serializeAsColor4()
], FluentButtonMaterial.prototype, "edgeColor", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "proximityMaxIntensity", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "proximityFarDistance", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "proximityNearRadius", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "proximityAnisotropy", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "selectionFuzz", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "selected", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "selectionFade", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "selectionFadeSize", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "selectedDistance", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "selectedFadeLength", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "blobIntensity", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "blobFarSize", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "blobNearDistance", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "blobFarDistance", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "blobFadeLength", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "leftBlobEnable", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "leftBlobNearSize", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "leftBlobPulse", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "leftBlobFade", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "leftBlobInnerFade", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "rightBlobEnable", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "rightBlobNearSize", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "rightBlobPulse", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "rightBlobFade", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "rightBlobInnerFade", void 0);
__decorate([
  serializeAsVector3()
], FluentButtonMaterial.prototype, "activeFaceDir", void 0);
__decorate([
  serializeAsVector3()
], FluentButtonMaterial.prototype, "activeFaceUp", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "enableFade", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "fadeWidth", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "smoothActiveFace", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "showFrame", void 0);
__decorate([
  serialize()
], FluentButtonMaterial.prototype, "useBlobTexture", void 0);
__decorate([
  serializeAsVector3()
], FluentButtonMaterial.prototype, "globalLeftIndexTipPosition", void 0);
__decorate([
  serializeAsVector3()
], FluentButtonMaterial.prototype, "globalRightIndexTipPosition", void 0);
RegisterClass("BABYLON.GUI.FluentButtonMaterial", FluentButtonMaterial);

// node_modules/@babylonjs/gui/3D/controls/touchButton3D.js
var TouchButton3D = class extends Button3D {
  /**
   * Creates a new touchable button
   * @param name defines the control name
   * @param collisionMesh mesh to track collisions with
   */
  constructor(name22, collisionMesh) {
    super(name22);
    this._isNearPressed = false;
    this._interactionSurfaceHeight = 0;
    this._isToggleButton = false;
    this._toggleState = false;
    this._toggleButtonCallback = () => {
      this._onToggle(!this._toggleState);
    };
    this.onToggleObservable = new Observable();
    this.collidableFrontDirection = Vector3.Zero();
    if (collisionMesh) {
      this.collisionMesh = collisionMesh;
    }
  }
  /**
   * Whether the current interaction is caused by near interaction or not
   */
  get isActiveNearInteraction() {
    return this._isNearPressed;
  }
  /**
   * Sets the front-facing direction of the button. Pass in Vector3.Zero to allow interactions from any direction
   * @param frontWorldDir the forward direction of the button
   */
  set collidableFrontDirection(frontWorldDir) {
    this._collidableFrontDirection = frontWorldDir.normalize();
    if (this._collisionMesh) {
      const invert = TmpVectors.Matrix[0];
      invert.copyFrom(this._collisionMesh.getWorldMatrix());
      invert.invert();
      Vector3.TransformNormalToRef(this._collidableFrontDirection, invert, this._collidableFrontDirection);
      this._collidableFrontDirection.normalize();
    }
  }
  /**
   * Returns the front-facing direction of the button, or Vector3.Zero if there is no 'front'
   */
  get collidableFrontDirection() {
    if (this._collisionMesh) {
      const transformedDirection = TmpVectors.Vector3[0];
      Vector3.TransformNormalToRef(this._collidableFrontDirection, this._collisionMesh.getWorldMatrix(), transformedDirection);
      return transformedDirection.normalize();
    }
    return this._collidableFrontDirection;
  }
  /**
   * Sets the mesh used for testing input collision
   * @param collisionMesh the new collision mesh for the button
   */
  set collisionMesh(collisionMesh) {
    var _a;
    if (this._collisionMesh) {
      this._collisionMesh.isNearPickable = false;
      if ((_a = this._collisionMesh.reservedDataStore) == null ? void 0 : _a.GUI3D) {
        this._collisionMesh.reservedDataStore.GUI3D = {};
      }
      this._collisionMesh.getChildMeshes().forEach((mesh) => {
        var _a2;
        mesh.isNearPickable = false;
        if ((_a2 = mesh.reservedDataStore) == null ? void 0 : _a2.GUI3D) {
          mesh.reservedDataStore.GUI3D = {};
        }
      });
    }
    this._collisionMesh = collisionMesh;
    this._injectGUI3DReservedDataStore(this._collisionMesh).control = this;
    this._collisionMesh.isNearPickable = true;
    this._collisionMesh.getChildMeshes().forEach((mesh) => {
      this._injectGUI3DReservedDataStore(mesh).control = this;
      mesh.isNearPickable = true;
    });
    this.collidableFrontDirection = collisionMesh.forward;
  }
  /**
   * Setter for if this TouchButton3D should be treated as a toggle button
   * @param value If this TouchHolographicButton should act like a toggle button
   */
  set isToggleButton(value) {
    if (value === this._isToggleButton) {
      return;
    }
    this._isToggleButton = value;
    if (value) {
      this.onPointerUpObservable.add(this._toggleButtonCallback);
    } else {
      this.onPointerUpObservable.removeCallback(this._toggleButtonCallback);
      if (this._toggleState) {
        this._onToggle(false);
      }
    }
  }
  get isToggleButton() {
    return this._isToggleButton;
  }
  /**
   * A public entrypoint to set the toggle state of the TouchHolographicButton. Only works if 'isToggleButton' is true
   * @param newState The new state to set the TouchHolographicButton's toggle state to
   */
  set isToggled(newState) {
    if (this._isToggleButton && this._toggleState !== newState) {
      this._onToggle(newState);
    }
  }
  get isToggled() {
    return this._toggleState;
  }
  _onToggle(newState) {
    this._toggleState = newState;
    this.onToggleObservable.notifyObservers(newState);
  }
  // Returns true if the collidable is in front of the button, or if the button has no front direction
  _isInteractionInFrontOfButton(collidablePos) {
    return this._getInteractionHeight(collidablePos, this._collisionMesh.getAbsolutePosition()) > 0;
  }
  /**
   * Get the height of the touchPoint from the collidable part of the button
   * @param touchPoint the point to compare to the button, in absolute position
   * @returns the depth of the touch point into the front of the button
   */
  getPressDepth(touchPoint) {
    if (!this._isNearPressed) {
      return 0;
    }
    const interactionHeight = this._getInteractionHeight(touchPoint, this._collisionMesh.getAbsolutePosition());
    return this._interactionSurfaceHeight - interactionHeight;
  }
  // Returns true if the collidable is in front of the button, or if the button has no front direction
  _getInteractionHeight(interactionPos, basePos) {
    const frontDir = this.collidableFrontDirection;
    if (frontDir.length() === 0) {
      return Vector3.Distance(interactionPos, basePos);
    }
    const d = Vector3.Dot(basePos, frontDir);
    const abc = Vector3.Dot(interactionPos, frontDir);
    return abc - d;
  }
  /**
   * @internal
   */
  _generatePointerEventType(providedType, nearMeshPosition, activeInteractionCount) {
    if (providedType === PointerEventTypes.POINTERDOWN || providedType === PointerEventTypes.POINTERMOVE) {
      if (!this._isInteractionInFrontOfButton(nearMeshPosition)) {
        return PointerEventTypes.POINTERMOVE;
      } else {
        this._isNearPressed = true;
        this._interactionSurfaceHeight = this._getInteractionHeight(nearMeshPosition, this._collisionMesh.getAbsolutePosition());
      }
    }
    if (providedType === PointerEventTypes.POINTERUP) {
      if (activeInteractionCount == 0) {
        return PointerEventTypes.POINTERMOVE;
      } else {
        this._isNearPressed = false;
      }
    }
    return providedType;
  }
  _getTypeName() {
    return "TouchButton3D";
  }
  // Mesh association
  _createNode(scene) {
    return super._createNode(scene);
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    super.dispose();
    this.onPointerUpObservable.removeCallback(this._toggleButtonCallback);
    this.onToggleObservable.clear();
    if (this._collisionMesh) {
      this._collisionMesh.dispose();
    }
  }
};

// node_modules/@babylonjs/gui/3D/controls/touchHolographicButton.js
var TouchHolographicButton = class _TouchHolographicButton extends TouchButton3D {
  _disposeTooltip() {
    this._tooltipFade = null;
    if (this._tooltipTextBlock) {
      this._tooltipTextBlock.dispose();
    }
    if (this._tooltipTexture) {
      this._tooltipTexture.dispose();
    }
    if (this._tooltipMesh) {
      this._tooltipMesh.dispose();
    }
    this.onPointerEnterObservable.remove(this._tooltipHoverObserver);
    this.onPointerOutObservable.remove(this._tooltipOutObserver);
  }
  /**
   * Rendering ground id of all the mesh in the button
   */
  set renderingGroupId(id) {
    this._backPlate.renderingGroupId = id;
    this._textPlate.renderingGroupId = id;
    this._frontPlate.renderingGroupId = id;
    if (this._tooltipMesh) {
      this._tooltipMesh.renderingGroupId = id;
    }
  }
  get renderingGroupId() {
    return this._backPlate.renderingGroupId;
  }
  /**
   * Gets the mesh used to render this control
   */
  get mesh() {
    return this._backPlate;
  }
  /**
   * Text to be displayed on the tooltip shown when hovering on the button. When set to null tooltip is disabled. (Default: null)
   */
  set tooltipText(text) {
    if (!text) {
      this._disposeTooltip();
      return;
    }
    if (!this._tooltipFade) {
      const rightHandedScene = this._backPlate._scene.useRightHandedSystem;
      this._tooltipMesh = CreatePlane("", { size: 1 }, this._backPlate._scene);
      const tooltipBackground = CreatePlane("", { size: 1, sideOrientation: Mesh.DOUBLESIDE }, this._backPlate._scene);
      const mat = new StandardMaterial("", this._backPlate._scene);
      mat.diffuseColor = Color3.FromHexString("#212121");
      tooltipBackground.material = mat;
      tooltipBackground.isPickable = false;
      this._tooltipMesh.addChild(tooltipBackground);
      tooltipBackground.position = Vector3.Forward(rightHandedScene).scale(0.05);
      this._tooltipMesh.scaling.y = 1 / 3;
      this._tooltipMesh.position = Vector3.Up().scale(0.7).add(Vector3.Forward(rightHandedScene).scale(-0.15));
      this._tooltipMesh.isPickable = false;
      this._tooltipMesh.parent = this._backPlate;
      this._tooltipTexture = AdvancedDynamicTexture.CreateForMesh(this._tooltipMesh);
      this._tooltipTextBlock = new TextBlock();
      this._tooltipTextBlock.scaleY = 3;
      this._tooltipTextBlock.color = "white";
      this._tooltipTextBlock.fontSize = 130;
      this._tooltipTexture.addControl(this._tooltipTextBlock);
      this._tooltipFade = new FadeInOutBehavior();
      this._tooltipFade.delay = 500;
      this._tooltipMesh.addBehavior(this._tooltipFade);
      this._tooltipHoverObserver = this.onPointerEnterObservable.add(() => {
        if (this._tooltipFade) {
          this._tooltipFade.fadeIn(true);
        }
      });
      this._tooltipOutObserver = this.onPointerOutObservable.add(() => {
        if (this._tooltipFade) {
          this._tooltipFade.fadeIn(false);
        }
      });
    }
    if (this._tooltipTextBlock) {
      this._tooltipTextBlock.text = text;
    }
  }
  get tooltipText() {
    if (this._tooltipTextBlock) {
      return this._tooltipTextBlock.text;
    }
    return null;
  }
  /**
   * Gets or sets text for the button
   */
  get text() {
    return this._text;
  }
  set text(value) {
    if (this._text === value) {
      return;
    }
    this._text = value;
    this._rebuildContent();
  }
  /**
   * Gets or sets the image url for the button
   */
  get imageUrl() {
    return this._imageUrl;
  }
  set imageUrl(value) {
    if (this._imageUrl === value) {
      return;
    }
    this._imageUrl = value;
    this._rebuildContent();
  }
  /**
   * Gets the back material used by this button
   */
  get backMaterial() {
    return this._backMaterial;
  }
  /**
   * Gets the front material used by this button
   */
  get frontMaterial() {
    return this._frontMaterial;
  }
  /**
   * Gets the plate material used by this button
   */
  get plateMaterial() {
    return this._plateMaterial;
  }
  /**
   * Gets a boolean indicating if this button shares its material with other HolographicButtons
   */
  get shareMaterials() {
    return this._shareMaterials;
  }
  /**
   * Sets whether the backplate is visible or hidden. Hiding the backplate is not recommended without some sort of replacement
   */
  set isBackplateVisible(isVisible) {
    if (this.mesh && !!this._backMaterial) {
      if (isVisible && !this._isBackplateVisible) {
        this._backPlate.visibility = 1;
      } else if (!isVisible && this._isBackplateVisible) {
        this._backPlate.visibility = 0;
      }
    }
    this._isBackplateVisible = isVisible;
  }
  /**
   * Creates a new button
   * @param name defines the control name
   * @param shareMaterials
   */
  constructor(name22, shareMaterials = true) {
    super(name22);
    this._shareMaterials = true;
    this._isBackplateVisible = true;
    this._frontPlateDepth = 0.5;
    this._backPlateDepth = 0.04;
    this._backplateColor = new Color3(0.08, 0.15, 0.55);
    this._backplateToggledColor = new Color3(0.25, 0.4, 0.95);
    this._shareMaterials = shareMaterials;
    this.pointerEnterAnimation = () => {
      this._frontMaterial.leftBlobEnable = true;
      this._frontMaterial.rightBlobEnable = true;
    };
    this.pointerOutAnimation = () => {
      this._frontMaterial.leftBlobEnable = false;
      this._frontMaterial.rightBlobEnable = false;
    };
    this.pointerDownAnimation = () => {
      if (this._frontPlate && !this.isActiveNearInteraction) {
        this._frontPlate.scaling.z = this._frontPlateDepth * 0.2;
        this._frontPlate.position = Vector3.Forward(this._frontPlate._scene.useRightHandedSystem).scale((this._frontPlateDepth - 0.2 * this._frontPlateDepth) / 2);
        this._textPlate.position = Vector3.Forward(this._textPlate._scene.useRightHandedSystem).scale(-(this._backPlateDepth + 0.2 * this._frontPlateDepth) / 2);
      }
    };
    this.pointerUpAnimation = () => {
      if (this._frontPlate) {
        this._frontPlate.scaling.z = this._frontPlateDepth;
        this._frontPlate.position = Vector3.Forward(this._frontPlate._scene.useRightHandedSystem).scale((this._frontPlateDepth - this._frontPlateDepth) / 2);
        this._textPlate.position = Vector3.Forward(this._textPlate._scene.useRightHandedSystem).scale(-(this._backPlateDepth + this._frontPlateDepth) / 2);
      }
    };
    this.onPointerMoveObservable.add((position) => {
      if (this._frontPlate && this.isActiveNearInteraction) {
        const scale = Vector3.Zero();
        if (this._backPlate.getWorldMatrix().decompose(scale, void 0, void 0)) {
          let interactionHeight = this._getInteractionHeight(position, this._backPlate.getAbsolutePosition()) / scale.z;
          interactionHeight = Scalar.Clamp(interactionHeight - this._backPlateDepth / 2, 0.2 * this._frontPlateDepth, this._frontPlateDepth);
          this._frontPlate.scaling.z = interactionHeight;
          this._frontPlate.position = Vector3.Forward(this._frontPlate._scene.useRightHandedSystem).scale((this._frontPlateDepth - interactionHeight) / 2);
          this._textPlate.position = Vector3.Forward(this._textPlate._scene.useRightHandedSystem).scale(-(this._backPlateDepth + interactionHeight) / 2);
        }
      }
    });
    this._pointerHoverObserver = this.onPointerMoveObservable.add((hoverPosition) => {
      this._frontMaterial.globalLeftIndexTipPosition = hoverPosition;
    });
  }
  _getTypeName() {
    return "TouchHolographicButton";
  }
  _rebuildContent() {
    this._disposeFacadeTexture();
    const panel = new StackPanel();
    panel.isVertical = true;
    if (IsDocumentAvailable() && !!document.createElement) {
      if (this._imageUrl) {
        const image = new Image();
        image.source = this._imageUrl;
        image.paddingTop = "40px";
        image.height = "180px";
        image.width = "100px";
        image.paddingBottom = "40px";
        panel.addControl(image);
      }
    }
    if (this._text) {
      const text = new TextBlock();
      text.text = this._text;
      text.color = "white";
      text.height = "30px";
      text.fontSize = 24;
      panel.addControl(text);
    }
    this.content = panel;
  }
  // Mesh association
  _createNode(scene) {
    this.name = this.name ?? "TouchHolographicButton";
    const collisionMesh = CreateBox(`${this.name}_collisionMesh`, {
      width: 1,
      height: 1,
      depth: this._frontPlateDepth
    }, scene);
    collisionMesh.isPickable = true;
    collisionMesh.isNearPickable = true;
    collisionMesh.visibility = 0;
    collisionMesh.position = Vector3.Forward(scene.useRightHandedSystem).scale(-this._frontPlateDepth / 2);
    const baseUrl = Tools.GetAssetUrl(_TouchHolographicButton.MODEL_BASE_URL);
    SceneLoader.ImportMeshAsync(void 0, baseUrl, _TouchHolographicButton.MODEL_FILENAME, scene).then((result) => {
      const alphaMesh = CreateBox("${this.name}_alphaMesh", {
        width: 1,
        height: 1,
        depth: 1
      }, scene);
      alphaMesh.isPickable = false;
      alphaMesh.material = new StandardMaterial("${this.name}_alphaMesh_material", scene);
      alphaMesh.material.alpha = 0.15;
      const importedFrontPlate = result.meshes[1];
      importedFrontPlate.name = `${this.name}_frontPlate`;
      importedFrontPlate.isPickable = false;
      importedFrontPlate.scaling.z = this._frontPlateDepth;
      alphaMesh.parent = importedFrontPlate;
      importedFrontPlate.parent = collisionMesh;
      if (this._frontMaterial) {
        importedFrontPlate.material = this._frontMaterial;
      }
      this._frontPlate = importedFrontPlate;
    });
    this._backPlate = CreateBox(`${this.name}_backPlate`, {
      width: 1,
      height: 1,
      depth: this._backPlateDepth
    }, scene);
    this._backPlate.position = Vector3.Forward(scene.useRightHandedSystem).scale(this._backPlateDepth / 2);
    this._backPlate.isPickable = false;
    this._textPlate = super._createNode(scene);
    this._textPlate.name = `${this.name}_textPlate`;
    this._textPlate.isPickable = false;
    this._textPlate.position = Vector3.Forward(scene.useRightHandedSystem).scale(-this._frontPlateDepth / 2);
    this._backPlate.addChild(collisionMesh);
    this._backPlate.addChild(this._textPlate);
    const tn = new TransformNode(`{this.name}_root`, scene);
    this._backPlate.setParent(tn);
    this.collisionMesh = collisionMesh;
    this.collidableFrontDirection = this._backPlate.forward.negate();
    return tn;
  }
  _applyFacade(facadeTexture) {
    this._plateMaterial.emissiveTexture = facadeTexture;
    this._plateMaterial.opacityTexture = facadeTexture;
    this._plateMaterial.diffuseColor = new Color3(0.4, 0.4, 0.4);
  }
  _createBackMaterial(mesh) {
    this._backMaterial = new FluentMaterial(this.name + "backPlateMaterial", mesh.getScene());
    this._backMaterial.albedoColor = this._backplateColor;
    this._backMaterial.renderBorders = true;
    this._backMaterial.renderHoverLight = false;
  }
  _createFrontMaterial(mesh) {
    this._frontMaterial = new FluentButtonMaterial(this.name + "Front Material", mesh.getScene());
  }
  _createPlateMaterial(mesh) {
    this._plateMaterial = new StandardMaterial(this.name + "Plate Material", mesh.getScene());
    this._plateMaterial.specularColor = Color3.Black();
  }
  _onToggle(newState) {
    if (this._backMaterial) {
      if (newState) {
        this._backMaterial.albedoColor = this._backplateToggledColor;
      } else {
        this._backMaterial.albedoColor = this._backplateColor;
      }
    }
    super._onToggle(newState);
  }
  _affectMaterial(mesh) {
    if (this._shareMaterials) {
      if (!this._host._touchSharedMaterials["backFluentMaterial"]) {
        this._createBackMaterial(mesh);
        this._host._touchSharedMaterials["backFluentMaterial"] = this._backMaterial;
      } else {
        this._backMaterial = this._host._touchSharedMaterials["backFluentMaterial"];
      }
      if (!this._host._touchSharedMaterials["frontFluentMaterial"]) {
        this._createFrontMaterial(mesh);
        this._host._touchSharedMaterials["frontFluentMaterial"] = this._frontMaterial;
      } else {
        this._frontMaterial = this._host._touchSharedMaterials["frontFluentMaterial"];
      }
    } else {
      this._createBackMaterial(mesh);
      this._createFrontMaterial(mesh);
    }
    this._createPlateMaterial(mesh);
    this._backPlate.material = this._backMaterial;
    this._textPlate.material = this._plateMaterial;
    if (!this._isBackplateVisible) {
      this._backPlate.visibility = 0;
    }
    if (this._frontPlate) {
      this._frontPlate.material = this._frontMaterial;
    }
    this._rebuildContent();
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    super.dispose();
    this._disposeTooltip();
    this.onPointerMoveObservable.remove(this._pointerHoverObserver);
    if (!this.shareMaterials) {
      this._backMaterial.dispose();
      this._frontMaterial.dispose();
      this._plateMaterial.dispose();
      if (this._pickedPointObserver) {
        this._host.onPickedPointChangedObservable.remove(this._pickedPointObserver);
        this._pickedPointObserver = null;
      }
    }
  }
};
TouchHolographicButton.MODEL_BASE_URL = "https://assets.babylonjs.com/core/MRTK/";
TouchHolographicButton.MODEL_FILENAME = "mrtk-fluent-button.glb";

// node_modules/@babylonjs/gui/3D/behaviors/defaultBehavior.js
var DefaultBehavior = class {
  /**
   * Instantiates the default behavior
   */
  constructor() {
    this.followBehaviorEnabled = false;
    this.sixDofDragBehaviorEnabled = true;
    this.surfaceMagnetismBehaviorEnabled = true;
    this._followBehavior = new FollowBehavior();
    this._sixDofDragBehavior = new SixDofDragBehavior();
    this._surfaceMagnetismBehavior = new SurfaceMagnetismBehavior();
  }
  /**
   *  The name of the behavior
   */
  get name() {
    return "Default";
  }
  /**
   *  The follow behavior
   */
  get followBehavior() {
    return this._followBehavior;
  }
  /**
   *  The six DoF drag behavior
   */
  get sixDofDragBehavior() {
    return this._sixDofDragBehavior;
  }
  /**
   * The surface magnetism behavior
   */
  get surfaceMagnetismBehavior() {
    return this._surfaceMagnetismBehavior;
  }
  /**
   *  Initializes the behavior
   */
  init() {
  }
  /**
   * Attaches the default behavior
   * @param ownerMesh The top level mesh
   * @param draggablesMeshes Descendant meshes that can be used for dragging the owner mesh
   * @param sceneUnderstandingMeshes Meshes from the scene understanding that will be used for surface magnetism
   */
  attach(ownerMesh, draggablesMeshes, sceneUnderstandingMeshes) {
    this._scene = ownerMesh.getScene();
    this.attachedNode = ownerMesh;
    this._addObservables();
    this._followBehavior.attach(ownerMesh);
    this._sixDofDragBehavior.attach(ownerMesh);
    this._sixDofDragBehavior.draggableMeshes = draggablesMeshes || null;
    this._sixDofDragBehavior.faceCameraOnDragStart = true;
    this._surfaceMagnetismBehavior.attach(ownerMesh, this._scene);
    if (sceneUnderstandingMeshes) {
      this._surfaceMagnetismBehavior.meshes = sceneUnderstandingMeshes;
    }
    this._surfaceMagnetismBehavior.enabled = false;
  }
  /**
   *  Detaches the behavior from the mesh
   */
  detach() {
    this.attachedNode = null;
    this._removeObservables();
    this._followBehavior.detach();
    this._sixDofDragBehavior.detach();
    this._surfaceMagnetismBehavior.detach();
  }
  _addObservables() {
    this._onBeforeRenderObserver = this._scene.onBeforeRenderObservable.add(() => {
      this._followBehavior._enabled = !this._sixDofDragBehavior.isMoving && this.followBehaviorEnabled;
    });
    this._onDragObserver = this._sixDofDragBehavior.onDragObservable.add((event) => {
      this._sixDofDragBehavior.disableMovement = this._surfaceMagnetismBehavior.findAndUpdateTarget(event.pickInfo);
    });
  }
  _removeObservables() {
    this._scene.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
    this._sixDofDragBehavior.onDragObservable.remove(this._onDragObserver);
  }
};

// node_modules/@babylonjs/gui/3D/materials/handle/shaders/handle.vertex.js
var name8 = "handleVertexShader";
var shader7 = `precision highp float;attribute vec3 position;uniform vec3 positionOffset;uniform mat4 worldViewProjection;uniform float scale;void main(void) {vec4 vPos=vec4((vec3(position)+positionOffset)*scale,1.0);gl_Position=worldViewProjection*vPos;}`;
if (!ShaderStore.ShadersStore[name8]) {
  ShaderStore.ShadersStore[name8] = shader7;
}

// node_modules/@babylonjs/gui/3D/materials/handle/shaders/handle.fragment.js
var name9 = "handlePixelShader";
var shader8 = `uniform vec3 color;void main(void) {gl_FragColor=vec4(color,1.0);}`;
if (!ShaderStore.ShadersStore[name9]) {
  ShaderStore.ShadersStore[name9] = shader8;
}

// node_modules/@babylonjs/gui/3D/materials/handle/handleMaterial.js
var HandleMaterial = class extends ShaderMaterial {
  /**
   * Is the material indicating hovering state
   */
  get hover() {
    return this._hover;
  }
  set hover(b) {
    this._hover = b;
    this._updateInterpolationTarget();
  }
  /**
   * Is the material indicating drag state
   */
  get drag() {
    return this._drag;
  }
  set drag(b) {
    this._drag = b;
    this._updateInterpolationTarget();
  }
  /**
   * Creates a handle material
   * @param name Name of the material
   * @param scene Scene
   */
  constructor(name22, scene) {
    super(name22, scene, "handle", {
      attributes: ["position"],
      uniforms: ["worldViewProjection", "color", "scale", "positionOffset"],
      needAlphaBlending: false,
      needAlphaTesting: false
    });
    this._hover = false;
    this._drag = false;
    this._color = new Color3();
    this._scale = 1;
    this._lastTick = -1;
    this.animationLength = 100;
    this.hoverColor = new Color3(0, 0.467, 0.84);
    this.baseColor = new Color3(1, 1, 1);
    this.hoverScale = 0.75;
    this.baseScale = 0.35;
    this.dragScale = 0.55;
    this._positionOffset = Vector3.Zero();
    this._updateInterpolationTarget();
    this._lastTick = Date.now();
    this._onBeforeRender = this.getScene().onBeforeRenderObservable.add(() => {
      const tick = Date.now();
      const delta = tick - this._lastTick;
      const scaleDiff = this._targetScale - this._scale;
      const colorDiff = TmpColors.Color3[0].copyFrom(this._targetColor).subtractToRef(this._color, TmpColors.Color3[0]);
      this._scale = this._scale + scaleDiff * delta / this.animationLength;
      colorDiff.scaleToRef(delta / this.animationLength, colorDiff);
      this._color.addToRef(colorDiff, this._color);
      this.setColor3("color", this._color);
      this.setFloat("scale", this._scale);
      this.setVector3("positionOffset", this._positionOffset);
      this._lastTick = tick;
    });
  }
  _updateInterpolationTarget() {
    if (this.drag) {
      this._targetColor = this.hoverColor;
      this._targetScale = this.dragScale;
    } else if (this.hover) {
      this._targetColor = this.hoverColor;
      this._targetScale = this.hoverScale;
    } else {
      this._targetColor = this.baseColor;
      this._targetScale = this.baseScale;
    }
  }
  /**
   * Disposes the handle material
   */
  dispose() {
    super.dispose();
    this.getScene().onBeforeRenderObservable.remove(this._onBeforeRender);
  }
};

// node_modules/@babylonjs/gui/3D/gizmos/gizmoHandle.js
var HandleState;
(function(HandleState2) {
  HandleState2[HandleState2["IDLE"] = 0] = "IDLE";
  HandleState2[HandleState2["HOVER"] = 1] = "HOVER";
  HandleState2[HandleState2["DRAG"] = 2] = "DRAG";
})(HandleState || (HandleState = {}));
var GizmoHandle = class {
  /**
   * The current state of the handle
   */
  get state() {
    return this._state;
  }
  /**
   * Returns the gizmo carrying this handle
   */
  get gizmo() {
    return this._gizmo;
  }
  /**
   * Sets hover state
   */
  set hover(value) {
    if (value) {
      this._state |= 1;
    } else {
      this._state &= ~1;
    }
    this._updateMaterial();
  }
  /**
   * Sets drag state
   */
  set drag(value) {
    if (value) {
      this._state |= 2;
    } else {
      this._state &= ~2;
    }
    this._updateMaterial();
  }
  /**
   * Creates a handle for a SlateGizmo
   * @param gizmo associated SlateGizmo
   * @param scene scene
   */
  constructor(gizmo, scene) {
    this._state = 0;
    this._materials = [];
    this._scene = scene;
    this._gizmo = gizmo;
    this.node = this.createNode();
    this.node.reservedDataStore = {
      handle: this
    };
  }
  _createMaterial(positionOffset) {
    const mat = new HandleMaterial("handle", this._scene);
    if (positionOffset) {
      mat._positionOffset = positionOffset;
    }
    return mat;
  }
  _updateMaterial() {
    const state = this._state;
    for (const mat of this._materials) {
      mat.hover = false;
      mat.drag = false;
    }
    if (state & 2) {
      for (const mat of this._materials) {
        mat.drag = true;
      }
    } else if (state & 1) {
      for (const mat of this._materials) {
        mat.hover = true;
      }
    }
  }
  /**
   * Binds callbacks from dragging interaction
   * @param dragStartFn Function to call on drag start
   * @param dragFn Function to call on drag
   * @param dragEndFn Function to call on drag end
   */
  setDragBehavior(dragStartFn, dragFn, dragEndFn) {
    const dragBehavior = new BaseSixDofDragBehavior();
    this._dragBehavior = dragBehavior;
    this._dragStartObserver = dragBehavior.onDragStartObservable.add(dragStartFn);
    this._draggingObserver = dragBehavior.onDragObservable.add(dragFn);
    this._dragEndObserver = dragBehavior.onDragEndObservable.add(dragEndFn);
    this._dragBehavior.attach(this.node);
  }
  /**
   * Disposes the handle
   */
  dispose() {
    this._dragBehavior.onDragStartObservable.remove(this._dragStartObserver);
    this._dragBehavior.onDragObservable.remove(this._draggingObserver);
    this._dragBehavior.onDragEndObservable.remove(this._dragEndObserver);
    this._dragBehavior.detach();
    for (const material of this._materials) {
      material.dispose();
    }
    this.node.dispose();
  }
};
var SideHandle = class extends GizmoHandle {
  /**
   * Creates the meshes and parent node of the handle
   * @returns created node
   */
  createNode() {
    const verticalBox = CreateBox("sideVert", { width: 1, height: 10, depth: 0.1 }, this._scene);
    const sideNode = new TransformNode("side", this._scene);
    verticalBox.parent = sideNode;
    const mat = this._createMaterial();
    verticalBox.material = mat;
    verticalBox.isNearGrabbable = true;
    this._materials.push(mat);
    return sideNode;
  }
};
var CornerHandle = class extends GizmoHandle {
  /**
   * Creates the meshes and parent node of the handle
   * @returns created node
   */
  createNode() {
    const horizontalBox = CreateBox("angleHor", { width: 3, height: 1, depth: 0.1 }, this._scene);
    const verticalBox = CreateBox("angleVert", { width: 1, height: 3, depth: 0.1 }, this._scene);
    const angleNode = new TransformNode("angle", this._scene);
    horizontalBox.parent = angleNode;
    verticalBox.parent = angleNode;
    horizontalBox.material = this._createMaterial(new Vector3(1, 0, 0));
    verticalBox.material = this._createMaterial(new Vector3(0, 1, 0));
    verticalBox.isNearGrabbable = true;
    horizontalBox.isNearGrabbable = true;
    this._materials.push(horizontalBox.material);
    this._materials.push(verticalBox.material);
    return angleNode;
  }
};

// node_modules/@babylonjs/gui/3D/gizmos/slateGizmo.js
var SlateGizmo = class extends Gizmo {
  /**
   * The slate attached to this gizmo
   */
  set attachedSlate(control) {
    if (control) {
      this.attachedMesh = control.mesh;
      this.updateBoundingBox();
      this._pickedPointObserver = control._host.onPickingObservable.add((pickedMesh) => {
        if (this._handleHovered && (!pickedMesh || pickedMesh.parent !== this._handleHovered.node)) {
          this._handleHovered.hover = false;
          this._handleHovered = null;
        }
        if (pickedMesh && pickedMesh.parent && pickedMesh.parent.reservedDataStore && pickedMesh.parent.reservedDataStore.handle) {
          const handle = pickedMesh.parent.reservedDataStore.handle;
          if (handle.gizmo === this) {
            this._handleHovered = handle;
            this._handleHovered.hover = true;
          }
        }
      });
    } else if (this._attachedSlate) {
      this._attachedSlate._host.onPickingObservable.remove(this._pickedPointObserver);
    }
    this._attachedSlate = control;
  }
  get attachedSlate() {
    return this._attachedSlate;
  }
  constructor(utilityLayer) {
    super(utilityLayer);
    this._boundingDimensions = new Vector3(0, 0, 0);
    this._renderObserver = null;
    this._tmpQuaternion = new Quaternion();
    this._tmpVector = new Vector3(0, 0, 0);
    this._corners = [];
    this._sides = [];
    this._boundingBoxGizmo = {
      min: new Vector3(),
      max: new Vector3()
    };
    this._margin = 0.35;
    this._handleSize = 0.075;
    this._attachedSlate = null;
    this._existingSlateScale = new Vector3();
    this.fixedScreenSize = false;
    this.fixedScreenSizeDistanceFactor = 10;
    this._createNode();
    this.updateScale = false;
    this._renderObserver = this.gizmoLayer.originalScene.onBeforeRenderObservable.add(() => {
      if (this.attachedMesh && !this._existingSlateScale.equals(this.attachedMesh.scaling)) {
        this.updateBoundingBox();
      }
    });
  }
  _createNode() {
    this._handlesParent = new TransformNode("handlesParent", this.gizmoLayer.utilityLayerScene);
    this._handlesParent.rotationQuaternion = Quaternion.Identity();
    const masksCorners = [
      {
        dimensions: new Vector3(-1, -1, 0),
        origin: new Vector3(1, 0, 0)
      },
      {
        dimensions: new Vector3(1, -1, 0),
        origin: new Vector3(0, 0, 0)
      },
      {
        dimensions: new Vector3(1, 1, 0),
        origin: new Vector3(0, 1, 0)
      },
      {
        dimensions: new Vector3(-1, 1, 0),
        origin: new Vector3(1, 1, 0)
      }
    ];
    for (let i = 0; i < 4; i++) {
      const corner = new CornerHandle(this, this.gizmoLayer.utilityLayerScene);
      this._corners.push(corner);
      corner.node.rotation.z = Math.PI / 2 * i;
      corner.node.parent = this._handlesParent;
      this._assignDragBehaviorCorners(corner, (originStart, dimensionsStart, offset, masks) => this._moveHandle(originStart, dimensionsStart, offset, masks, true), masksCorners[i]);
    }
    for (let i = 0; i < 4; i++) {
      const side = new SideHandle(this, this.gizmoLayer.utilityLayerScene);
      this._sides.push(side);
      side.node.rotation.z = Math.PI / 2 * i;
      side.node.parent = this._handlesParent;
      this._assignDragBehaviorSides(side, i % 2 === 0 ? new Vector3(0, 1, 0) : new Vector3(1, 0, 0));
    }
    this._handlesParent.parent = this._rootMesh;
  }
  _keepAspectRatio(vector, aspectRatio, invertDiagonal = false) {
    const axis = TmpVectors.Vector3[0];
    axis.copyFromFloats(aspectRatio, 1, 0).normalize();
    if (invertDiagonal) {
      axis.y *= -1;
    }
    const dot = Vector3.Dot(vector, axis);
    vector.copyFrom(axis).scaleInPlace(dot);
  }
  _clampDimensions(vector, dimensions, mask, keepAspectRatio = false) {
    const impact = TmpVectors.Vector3[0];
    impact.copyFrom(vector).multiplyInPlace(mask);
    const clampedDimensions = TmpVectors.Vector3[1];
    clampedDimensions.copyFromFloats(Math.max(this._attachedSlate.minDimensions.x, impact.x + dimensions.x), Math.max(this._attachedSlate.minDimensions.y, impact.y + dimensions.y), 0);
    if (keepAspectRatio) {
      const ratio = dimensions.x / dimensions.y;
      clampedDimensions.x = Math.max(clampedDimensions.x, clampedDimensions.y * ratio);
      clampedDimensions.y = Math.max(clampedDimensions.y, clampedDimensions.x / ratio);
    }
    impact.copyFrom(clampedDimensions).subtractInPlace(dimensions);
    vector.x = Math.sign(vector.x) * Math.abs(impact.x);
    vector.y = Math.sign(vector.y) * Math.abs(impact.y);
  }
  _moveHandle(originStart, dimensionsStart, offset, masks, isCorner) {
    if (!this._attachedSlate) {
      return;
    }
    if (isCorner) {
      const aspectRatio = dimensionsStart.x / dimensionsStart.y;
      this._keepAspectRatio(offset, aspectRatio, masks.dimensions.x * masks.dimensions.y < 0);
    }
    this._clampDimensions(offset, dimensionsStart, masks.dimensions, isCorner);
    const offsetOriginMasked = TmpVectors.Vector3[0];
    const offsetDimensionsMasked = TmpVectors.Vector3[1];
    offsetOriginMasked.copyFrom(offset).multiplyInPlace(masks.origin);
    offsetDimensionsMasked.copyFrom(offset).multiplyInPlace(masks.dimensions);
    this._attachedSlate.origin.copyFrom(originStart).addInPlace(offsetOriginMasked);
    this._attachedSlate.dimensions.set(dimensionsStart.x + offsetDimensionsMasked.x, dimensionsStart.y + offsetDimensionsMasked.y);
  }
  _assignDragBehaviorCorners(handle, moveFn, masks) {
    const dimensionsStart = new Vector3();
    const originStart = new Vector3();
    const dragOrigin = new Vector3();
    const toObjectFrame = new Matrix();
    const dragPlaneNormal = new Vector3();
    const projectToRef = (position, normal, origin, ref) => {
      position.subtractToRef(origin, TmpVectors.Vector3[0]);
      const dot = Vector3.Dot(TmpVectors.Vector3[0], normal);
      TmpVectors.Vector3[1].copyFrom(normal).scaleInPlace(dot);
      TmpVectors.Vector3[0].subtractInPlace(TmpVectors.Vector3[1]);
      TmpVectors.Vector3[0].addToRef(origin, ref);
    };
    const dragStart = (event) => {
      if (this.attachedSlate && this.attachedMesh) {
        dimensionsStart.set(this.attachedSlate.dimensions.x, this.attachedSlate.dimensions.y, Epsilon);
        originStart.copyFrom(this.attachedSlate.origin);
        dragOrigin.copyFrom(event.position);
        toObjectFrame.copyFrom(this.attachedMesh.computeWorldMatrix(true));
        toObjectFrame.invert();
        this.attachedSlate._followButton.isToggled = false;
        Vector3.TransformNormalToRef(Vector3.Forward(), this.attachedMesh.getWorldMatrix(), dragPlaneNormal);
        dragPlaneNormal.normalize();
        if (this._handleHovered) {
          this._handleDragged = this._handleHovered;
          this._handleDragged.drag = true;
        }
      }
    };
    const dragging = (event) => {
      if (this.attachedSlate && this.attachedMesh) {
        projectToRef(event.position, dragPlaneNormal, dragOrigin, this._tmpVector);
        this._tmpVector.subtractInPlace(dragOrigin);
        Vector3.TransformNormalToRef(this._tmpVector, toObjectFrame, this._tmpVector);
        moveFn(originStart, dimensionsStart, this._tmpVector, masks);
        this.attachedSlate._positionElements();
        this.updateBoundingBox();
      }
    };
    const dragEnd = () => {
      if (this.attachedSlate && this.attachedNode) {
        this.attachedSlate._updatePivot();
        if (this._handleDragged) {
          this._handleDragged.drag = false;
          this._handleDragged = null;
        }
      }
    };
    handle.setDragBehavior(dragStart, dragging, dragEnd);
  }
  _assignDragBehaviorSides(handle, dragPlaneNormal) {
    const quaternionOrigin = new Quaternion();
    const dragOrigin = new Vector3();
    const directionOrigin = new Vector3();
    const worldPivot = new Vector3();
    const worldPlaneNormal = new Vector3();
    const dragStart = (event) => {
      if (this.attachedSlate && this.attachedMesh) {
        quaternionOrigin.copyFrom(this.attachedMesh.rotationQuaternion);
        dragOrigin.copyFrom(event.position);
        worldPivot.copyFrom(this.attachedMesh.getAbsolutePivotPoint());
        directionOrigin.copyFrom(dragOrigin).subtractInPlace(worldPivot).normalize();
        this.attachedSlate._followButton.isToggled = false;
        Vector3.TransformNormalToRef(dragPlaneNormal, this.attachedMesh.getWorldMatrix(), worldPlaneNormal);
        worldPlaneNormal.normalize();
        if (this._handleHovered) {
          this._handleDragged = this._handleHovered;
          this._handleDragged.drag = true;
        }
      }
    };
    const dragging = (event) => {
      if (this.attachedSlate && this.attachedMesh) {
        this._tmpVector.copyFrom(event.position);
        this._tmpVector.subtractInPlace(worldPivot);
        this._tmpVector.normalize();
        const angle = -Vector3.GetAngleBetweenVectorsOnPlane(this._tmpVector, directionOrigin, worldPlaneNormal);
        Quaternion.RotationAxisToRef(dragPlaneNormal, angle, this._tmpQuaternion);
        quaternionOrigin.multiplyToRef(this._tmpQuaternion, this.attachedMesh.rotationQuaternion);
      }
    };
    const dragEnd = () => {
      if (this.attachedSlate && this.attachedNode) {
        this.attachedSlate._updatePivot();
        if (this._handleDragged) {
          this._handleDragged.drag = false;
          this._handleDragged = null;
        }
      }
    };
    handle.setDragBehavior(dragStart, dragging, dragEnd);
  }
  _attachedNodeChanged(value) {
    if (value) {
      this.updateBoundingBox();
    }
  }
  /**
   * Updates the bounding box information for the gizmo
   */
  updateBoundingBox() {
    if (this.attachedMesh) {
      PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);
      const originalParent = this.attachedMesh.parent;
      this.attachedMesh.setParent(null);
      this._update();
      if (!this.attachedMesh.rotationQuaternion) {
        this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);
      }
      this._tmpQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);
      this._tmpVector.copyFrom(this.attachedMesh.position);
      this.attachedMesh.rotationQuaternion.set(0, 0, 0, 1);
      this.attachedMesh.position.set(0, 0, 0);
      const boundingMinMax = this.attachedMesh.getHierarchyBoundingVectors();
      boundingMinMax.max.subtractToRef(boundingMinMax.min, this._boundingDimensions);
      this._boundingBoxGizmo.min = boundingMinMax.min;
      this._boundingBoxGizmo.max = boundingMinMax.max;
      this._updateHandlesPosition();
      this._updateHandlesScaling();
      this.attachedMesh.rotationQuaternion.copyFrom(this._tmpQuaternion);
      this.attachedMesh.position.copyFrom(this._tmpVector);
      PivotTools._RestorePivotPoint(this.attachedMesh);
      this.attachedMesh.setParent(originalParent);
      this.attachedMesh.computeWorldMatrix(true);
      this._existingSlateScale.copyFrom(this.attachedMesh.scaling);
    }
  }
  _updateHandlesPosition() {
    const min = this._boundingBoxGizmo.min.clone();
    const max = this._boundingBoxGizmo.max.clone();
    const handleScaling = this._corners[0].node.scaling.length();
    min.x -= this._margin * handleScaling;
    min.y -= this._margin * handleScaling;
    max.x += this._margin * handleScaling;
    max.y += this._margin * handleScaling;
    const center = min.add(max).scaleInPlace(0.5);
    this._corners[0].node.position.copyFromFloats(min.x, min.y, 0);
    this._corners[1].node.position.copyFromFloats(max.x, min.y, 0);
    this._corners[2].node.position.copyFromFloats(max.x, max.y, 0);
    this._corners[3].node.position.copyFromFloats(min.x, max.y, 0);
    this._sides[0].node.position.copyFromFloats(min.x, center.y, 0);
    this._sides[1].node.position.copyFromFloats(center.x, min.y, 0);
    this._sides[2].node.position.copyFromFloats(max.x, center.y, 0);
    this._sides[3].node.position.copyFromFloats(center.x, max.y, 0);
  }
  _updateHandlesScaling() {
    if (this._attachedSlate && this._attachedSlate.mesh) {
      const scaledWidth = this._attachedSlate.mesh.scaling.x * this._attachedSlate.dimensions.x;
      const scaledHeight = this._attachedSlate.mesh.scaling.y * this._attachedSlate.dimensions.y;
      const scale = Math.min(scaledWidth, scaledHeight) * this._handleSize;
      for (let index = 0; index < this._corners.length; index++) {
        this._corners[index].node.scaling.setAll(scale);
      }
      for (let index = 0; index < this._sides.length; index++) {
        this._sides[index].node.scaling.setAll(scale);
      }
    }
  }
  _update() {
    super._update();
    if (!this.gizmoLayer.utilityLayerScene.activeCamera) {
      return;
    }
    if (this._attachedSlate && this._attachedSlate.mesh) {
      if (this.fixedScreenSize) {
        this._attachedSlate.mesh.absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);
        const distanceFromCamera = this._handleSize * this._tmpVector.length() / this.fixedScreenSizeDistanceFactor;
        for (let i = 0; i < this._corners.length; i++) {
          this._corners[i].node.scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);
        }
        for (let i = 0; i < this._sides.length; i++) {
          this._sides[i].node.scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);
        }
      }
      this._updateHandlesPosition();
    }
  }
  dispose() {
    this.gizmoLayer.originalScene.onBeforeRenderObservable.remove(this._renderObserver);
    super.dispose();
    for (const corner of this._corners) {
      corner.dispose();
    }
    for (const side of this._sides) {
      side.dispose();
    }
  }
};

// node_modules/@babylonjs/gui/3D/controls/holographicSlate.js
var HolographicSlate = class _HolographicSlate extends ContentDisplay3D {
  /**
   * Regroups all mesh behaviors for the slate
   */
  get defaultBehavior() {
    return this._defaultBehavior;
  }
  /**
   * 2D dimensions of the slate
   */
  get dimensions() {
    return this._dimensions;
  }
  set dimensions(value) {
    let scale = 1;
    if (value.x < this.minDimensions.x || value.y < this.minDimensions.y) {
      const newRatio = value.x / value.y;
      const minRatio = this.minDimensions.x / this.minDimensions.y;
      if (minRatio > newRatio) {
        scale = this.minDimensions.x / value.x;
      } else {
        scale = this.minDimensions.y / value.y;
      }
    }
    this._dimensions.copyFrom(value).scaleInPlace(scale);
    this._updatePivot();
    this._positionElements();
  }
  /**
   * Height of the title bar component
   */
  get titleBarHeight() {
    return this._titleBarHeight;
  }
  set titleBarHeight(value) {
    this._titleBarHeight = value;
  }
  /**
   * Rendering ground id of all the meshes
   */
  set renderingGroupId(id) {
    this._titleBar.renderingGroupId = id;
    this._titleBarTitle.renderingGroupId = id;
    this._contentPlate.renderingGroupId = id;
    this._backPlate.renderingGroupId = id;
  }
  get renderingGroupId() {
    return this._titleBar.renderingGroupId;
  }
  /**
   * The title text displayed at the top of the slate
   */
  set title(title) {
    this._titleText = title;
    if (this._titleTextComponent) {
      this._titleTextComponent.text = title;
    }
  }
  get title() {
    return this._titleText;
  }
  /**
   * Creates a new slate
   * @param name defines the control name
   */
  constructor(name22) {
    super(name22);
    this.titleBarMargin = 5e-3;
    this.origin = new Vector3(0, 0, 0);
    this._dimensions = new Vector2(21.875, 12.5);
    this._titleBarHeight = 0.625;
    this._titleText = "";
    this.fitContentToDimensions = false;
    this._contentScaleRatio = 1;
    this.minDimensions = new Vector2(15.625, 6.25);
    this.defaultDimensions = this._dimensions.clone();
    this._followButton = new TouchHolographicButton("followButton" + this.name);
    this._followButton.isToggleButton = true;
    this._closeButton = new TouchHolographicButton("closeButton" + this.name);
    this._contentViewport = new Viewport(0, 0, 1, 1);
    this._contentDragBehavior = new PointerDragBehavior({
      dragPlaneNormal: new Vector3(0, 0, -1)
    });
  }
  /**
   * Apply the facade texture (created from the content property).
   * This function can be overloaded by child classes
   * @param facadeTexture defines the AdvancedDynamicTexture to use
   */
  _applyFacade(facadeTexture) {
    this._contentMaterial.albedoTexture = facadeTexture;
    this._resetContentPositionAndZoom();
    this._applyContentViewport();
    facadeTexture.attachToMesh(this._contentPlate, true);
  }
  _addControl(control) {
    control._host = this._host;
    if (this._host.utilityLayer) {
      control._prepareNode(this._host.utilityLayer.utilityLayerScene);
    }
  }
  _getTypeName() {
    return "HolographicSlate";
  }
  /**
   * @internal
   */
  _positionElements() {
    const followButton = this._followButton;
    const closeButton = this._closeButton;
    const titleBar = this._titleBar;
    const titleBarTitle = this._titleBarTitle;
    const contentPlate = this._contentPlate;
    const backPlate = this._backPlate;
    if (followButton && closeButton && titleBar) {
      closeButton.scaling.setAll(this.titleBarHeight);
      followButton.scaling.setAll(this.titleBarHeight);
      closeButton.position.copyFromFloats(this.dimensions.x - this.titleBarHeight / 2, -this.titleBarHeight / 2, 0).addInPlace(this.origin);
      followButton.position.copyFromFloats(this.dimensions.x - 3 * this.titleBarHeight / 2, -this.titleBarHeight / 2, 0).addInPlace(this.origin);
      const contentPlateHeight = this.dimensions.y - this.titleBarHeight - this.titleBarMargin;
      const rightHandScene = contentPlate.getScene().useRightHandedSystem;
      titleBar.scaling.set(this.dimensions.x, this.titleBarHeight, Epsilon);
      titleBarTitle.scaling.set(this.dimensions.x - 2 * this.titleBarHeight, this.titleBarHeight, Epsilon);
      contentPlate.scaling.copyFromFloats(this.dimensions.x, contentPlateHeight, Epsilon);
      backPlate.scaling.copyFromFloats(this.dimensions.x, contentPlateHeight, Epsilon);
      titleBar.position.copyFromFloats(this.dimensions.x / 2, -(this.titleBarHeight / 2), 0).addInPlace(this.origin);
      titleBarTitle.position.copyFromFloats(this.dimensions.x / 2 - this.titleBarHeight, -(this.titleBarHeight / 2), rightHandScene ? Epsilon : -Epsilon).addInPlace(this.origin);
      contentPlate.position.copyFromFloats(this.dimensions.x / 2, -(this.titleBarHeight + this.titleBarMargin + contentPlateHeight / 2), 0).addInPlace(this.origin);
      backPlate.position.copyFromFloats(this.dimensions.x / 2, -(this.titleBarHeight + this.titleBarMargin + contentPlateHeight / 2), rightHandScene ? -Epsilon : Epsilon).addInPlace(this.origin);
      this._titleTextComponent.host.scaleTo(_HolographicSlate._DEFAULT_TEXT_RESOLUTION_Y * titleBarTitle.scaling.x / titleBarTitle.scaling.y, _HolographicSlate._DEFAULT_TEXT_RESOLUTION_Y);
      const aspectRatio = this.dimensions.x / contentPlateHeight;
      this._contentViewport.width = this._contentScaleRatio;
      this._contentViewport.height = this._contentScaleRatio / aspectRatio;
      this._applyContentViewport();
      if (this._gizmo) {
        this._gizmo.updateBoundingBox();
      }
    }
  }
  _applyContentViewport() {
    var _a;
    if (((_a = this._contentPlate) == null ? void 0 : _a.material) && this._contentPlate.material.albedoTexture) {
      const tex = this._contentPlate.material.albedoTexture;
      tex.uScale = this._contentScaleRatio;
      tex.vScale = this.fitContentToDimensions ? this._contentScaleRatio : this._contentScaleRatio / this._contentViewport.width * this._contentViewport.height;
      tex.uOffset = this._contentViewport.x;
      tex.vOffset = this._contentViewport.y;
    }
  }
  _resetContentPositionAndZoom() {
    this._contentViewport.x = 0;
    this._contentViewport.y = 0;
    this._contentScaleRatio = 1;
  }
  /**
   * @internal
   */
  _updatePivot() {
    if (!this.mesh) {
      return;
    }
    const center = new Vector3(this.dimensions.x * 0.5, -this.dimensions.y * 0.5, Epsilon);
    center.addInPlace(this.origin);
    center.z = 0;
    const origin = new Vector3(0, 0, 0);
    Vector3.TransformCoordinatesToRef(origin, this.mesh.computeWorldMatrix(true), origin);
    this.mesh.setPivotPoint(center);
    const origin2 = new Vector3(0, 0, 0);
    Vector3.TransformCoordinatesToRef(origin2, this.mesh.computeWorldMatrix(true), origin2);
    this.mesh.position.addInPlace(origin).subtractInPlace(origin2);
  }
  // Mesh association
  _createNode(scene) {
    const node = new Mesh("slate_" + this.name, scene);
    this._titleBar = CreateBox("titleBar_" + this.name, { size: 1 }, scene);
    this._titleBarTitle = CreatePlane("titleText_" + this.name, { size: 1 }, scene);
    this._titleBarTitle.parent = node;
    this._titleBarTitle.isPickable = false;
    const adt = AdvancedDynamicTexture.CreateForMesh(this._titleBarTitle);
    this._titleTextComponent = new TextBlock("titleText_" + this.name, this._titleText);
    this._titleTextComponent.textWrapping = 2;
    this._titleTextComponent.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
    this._titleTextComponent.color = "white";
    this._titleTextComponent.fontSize = _HolographicSlate._DEFAULT_TEXT_RESOLUTION_Y / 2;
    this._titleTextComponent.paddingLeft = _HolographicSlate._DEFAULT_TEXT_RESOLUTION_Y / 4;
    adt.addControl(this._titleTextComponent);
    if (scene.useRightHandedSystem) {
      const faceUV = new Vector4(0, 0, 1, 1);
      this._contentPlate = CreatePlane("contentPlate_" + this.name, { size: 1, sideOrientation: VertexData.BACKSIDE, frontUVs: faceUV }, scene);
      this._backPlate = CreatePlane("backPlate_" + this.name, { size: 1, sideOrientation: VertexData.FRONTSIDE }, scene);
    } else {
      const faceUV = new Vector4(0, 0, 1, 1);
      this._contentPlate = CreatePlane("contentPlate_" + this.name, { size: 1, sideOrientation: VertexData.FRONTSIDE, frontUVs: faceUV }, scene);
      this._backPlate = CreatePlane("backPlate_" + this.name, { size: 1, sideOrientation: VertexData.BACKSIDE }, scene);
    }
    this._titleBar.parent = node;
    this._titleBar.isNearGrabbable = true;
    this._contentPlate.parent = node;
    this._backPlate.parent = node;
    this._attachContentPlateBehavior();
    this._addControl(this._followButton);
    this._addControl(this._closeButton);
    const followButton = this._followButton;
    const closeButton = this._closeButton;
    followButton.node.parent = node;
    closeButton.node.parent = node;
    this._positionElements();
    const baseUrl = Tools.GetAssetUrl(_HolographicSlate.ASSETS_BASE_URL);
    this._followButton.imageUrl = baseUrl + _HolographicSlate.FOLLOW_ICON_FILENAME;
    this._closeButton.imageUrl = baseUrl + _HolographicSlate.CLOSE_ICON_FILENAME;
    this._followButton.isBackplateVisible = false;
    this._closeButton.isBackplateVisible = false;
    this._followButton.onToggleObservable.add((isToggled) => {
      this._defaultBehavior.followBehaviorEnabled = isToggled;
      if (this._defaultBehavior.followBehaviorEnabled) {
        this._defaultBehavior.followBehavior.recenter();
      }
    });
    this._closeButton.onPointerClickObservable.add(() => {
      this.dispose();
    });
    node.rotationQuaternion = Quaternion.Identity();
    node.isVisible = false;
    return node;
  }
  _attachContentPlateBehavior() {
    this._contentDragBehavior.attach(this._contentPlate);
    this._contentDragBehavior.moveAttached = false;
    this._contentDragBehavior.useObjectOrientationForDragging = true;
    this._contentDragBehavior.updateDragPlane = false;
    const origin = new Vector3();
    const worldDimensions = new Vector3();
    const upWorld = new Vector3();
    const rightWorld = new Vector3();
    const projectedOffset = new Vector2();
    let startViewport;
    let worldMatrix;
    this._contentDragBehavior.onDragStartObservable.add((event) => {
      if (!this.node) {
        return;
      }
      startViewport = this._contentViewport.clone();
      worldMatrix = this.node.computeWorldMatrix(true);
      origin.copyFrom(event.dragPlanePoint);
      worldDimensions.set(this.dimensions.x, this.dimensions.y, Epsilon);
      worldDimensions.y -= this.titleBarHeight + this.titleBarMargin;
      Vector3.TransformNormalToRef(worldDimensions, worldMatrix, worldDimensions);
      upWorld.copyFromFloats(0, 1, 0);
      Vector3.TransformNormalToRef(upWorld, worldMatrix, upWorld);
      rightWorld.copyFromFloats(1, 0, 0);
      Vector3.TransformNormalToRef(rightWorld, worldMatrix, rightWorld);
      upWorld.normalize();
      upWorld.scaleInPlace(1 / Vector3.Dot(upWorld, worldDimensions));
      rightWorld.normalize();
      rightWorld.scaleInPlace(1 / Vector3.Dot(rightWorld, worldDimensions));
    });
    const offset = new Vector3();
    this._contentDragBehavior.onDragObservable.add((event) => {
      if (this.fitContentToDimensions) {
        return;
      }
      offset.copyFrom(event.dragPlanePoint);
      offset.subtractInPlace(origin);
      projectedOffset.copyFromFloats(Vector3.Dot(offset, rightWorld), Vector3.Dot(offset, upWorld));
      this._contentViewport.x = Scalar.Clamp(startViewport.x - offset.x, 0, 1 - this._contentViewport.width * this._contentScaleRatio);
      this._contentViewport.y = Scalar.Clamp(startViewport.y - offset.y, 0, 1 - this._contentViewport.height * this._contentScaleRatio);
      this._applyContentViewport();
    });
  }
  _affectMaterial(mesh) {
    this._titleBarMaterial = new FluentBackplateMaterial(`${this.name} plateMaterial`, mesh.getScene());
    this._contentMaterial = new FluentMaterial(`${this.name} contentMaterial`, mesh.getScene());
    this._contentMaterial.renderBorders = true;
    this._backMaterial = new FluentBackplateMaterial(`${this.name} backPlate`, mesh.getScene());
    this._backMaterial.lineWidth = Epsilon;
    this._backMaterial.radius = 5e-3;
    this._backMaterial.backFaceCulling = true;
    this._titleBar.material = this._titleBarMaterial;
    this._contentPlate.material = this._contentMaterial;
    this._backPlate.material = this._backMaterial;
    this._resetContent();
    this._applyContentViewport();
  }
  /**
   * @internal
   */
  _prepareNode(scene) {
    super._prepareNode(scene);
    this._gizmo = new SlateGizmo(this._host.utilityLayer);
    this._gizmo.attachedSlate = this;
    this._defaultBehavior = new DefaultBehavior();
    this._defaultBehavior.attach(this.node, [this._titleBar]);
    this._defaultBehavior.sixDofDragBehavior.onDragStartObservable.add(() => {
      this._followButton.isToggled = false;
    });
    this._positionChangedObserver = this._defaultBehavior.sixDofDragBehavior.onPositionChangedObservable.add(() => {
      this._gizmo.updateBoundingBox();
    });
    this._updatePivot();
    this.resetDefaultAspectAndPose(false);
  }
  /**
   * Resets the aspect and pose of the slate so it is right in front of the active camera, facing towards it.
   * @param resetAspect Should the slate's dimensions/aspect ratio be reset as well
   */
  resetDefaultAspectAndPose(resetAspect = true) {
    if (!this._host || !this._host.utilityLayer || !this.node) {
      return;
    }
    const scene = this._host.utilityLayer.utilityLayerScene;
    const camera = scene.activeCamera;
    if (camera) {
      const worldMatrix = camera.getWorldMatrix();
      const backward = Vector3.TransformNormal(Vector3.Backward(scene.useRightHandedSystem), worldMatrix);
      this.origin.setAll(0);
      this._gizmo.updateBoundingBox();
      const pivot = this.node.getAbsolutePivotPoint();
      if (this.node.position.equalsToFloats(0, 0, 0)) {
        this.node.position.copyFrom(camera.position).subtractInPlace(backward).subtractInPlace(pivot);
      }
      this.node.rotationQuaternion = Quaternion.FromLookDirectionLH(backward, new Vector3(0, 1, 0));
      if (resetAspect) {
        this.dimensions = this.defaultDimensions;
      }
    }
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    super.dispose();
    this._titleBarMaterial.dispose();
    this._contentMaterial.dispose();
    this._titleBar.dispose();
    this._titleBarTitle.dispose();
    this._contentPlate.dispose();
    this._backPlate.dispose();
    this._followButton.dispose();
    this._closeButton.dispose();
    this._host.onPickedPointChangedObservable.remove(this._pickedPointObserver);
    this._defaultBehavior.sixDofDragBehavior.onPositionChangedObservable.remove(this._positionChangedObserver);
    this._defaultBehavior.detach();
    this._gizmo.dispose();
    this._contentDragBehavior.detach();
  }
};
HolographicSlate.ASSETS_BASE_URL = "https://assets.babylonjs.com/core/MRTK/";
HolographicSlate.CLOSE_ICON_FILENAME = "IconClose.png";
HolographicSlate.FOLLOW_ICON_FILENAME = "IconFollowMe.png";
HolographicSlate._DEFAULT_TEXT_RESOLUTION_Y = 102.4;

// node_modules/@babylonjs/gui/3D/controls/meshButton3D.js
var MeshButton3D = class extends Button3D {
  /**
   * Creates a new 3D button based on a mesh
   * @param mesh mesh to become a 3D button
   * @param name defines the control name
   */
  constructor(mesh, name22) {
    super(name22);
    this._currentMesh = mesh;
    this.pointerEnterAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this.mesh.scaling.scaleInPlace(1.1);
    };
    this.pointerOutAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this.mesh.scaling.scaleInPlace(1 / 1.1);
    };
    this.pointerDownAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this.mesh.scaling.scaleInPlace(0.95);
    };
    this.pointerUpAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this.mesh.scaling.scaleInPlace(1 / 0.95);
    };
  }
  _getTypeName() {
    return "MeshButton3D";
  }
  // Mesh association
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _createNode(scene) {
    this._currentMesh.getChildMeshes().forEach((mesh) => {
      this._injectGUI3DReservedDataStore(mesh).control = this;
    });
    return this._currentMesh;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _affectMaterial(mesh) {
  }
};

// node_modules/@babylonjs/gui/3D/controls/nearMenu.js
var NearMenu = class _NearMenu extends TouchHolographicMenu {
  /**
   * Regroups all mesh behaviors for the near menu
   */
  get defaultBehavior() {
    return this._defaultBehavior;
  }
  /**
   * Indicates if the near menu is world-pinned
   */
  get isPinned() {
    return this._isPinned;
  }
  set isPinned(value) {
    if (this._pinButton.isToggled !== value) {
      this._pinButton.isToggled = value;
      return;
    }
    this._isPinned = value;
    if (value) {
      this._defaultBehavior.followBehaviorEnabled = false;
    } else {
      this._defaultBehavior.followBehaviorEnabled = true;
    }
  }
  _createPinButton(parent) {
    const control = new TouchHolographicButton("pin" + this.name, false);
    const baseUrl = Tools.GetAssetUrl(_NearMenu._ASSETS_BASE_URL);
    control.imageUrl = baseUrl + _NearMenu._PIN_ICON_FILENAME;
    control.parent = this;
    control._host = this._host;
    control.isToggleButton = true;
    control.onToggleObservable.add((newState) => {
      this.isPinned = newState;
    });
    if (this._host.utilityLayer) {
      control._prepareNode(this._host.utilityLayer.utilityLayerScene);
      control.scaling.scaleInPlace(TouchHolographicMenu.MENU_BUTTON_SCALE);
      if (control.node) {
        control.node.parent = parent;
      }
    }
    return control;
  }
  _createNode(scene) {
    const node = super._createNode(scene);
    this._pinButton = this._createPinButton(node);
    this.isPinned = false;
    this._defaultBehavior.attach(node, [this._backPlate]);
    this._defaultBehavior.followBehavior.ignoreCameraPitchAndRoll = true;
    this._defaultBehavior.followBehavior.pitchOffset = -15;
    this._defaultBehavior.followBehavior.minimumDistance = 0.3;
    this._defaultBehavior.followBehavior.defaultDistance = 0.4;
    this._defaultBehavior.followBehavior.maximumDistance = 0.6;
    this._backPlate.isNearGrabbable = true;
    node.isVisible = false;
    return node;
  }
  _finalProcessing() {
    super._finalProcessing();
    this._pinButton.position.copyFromFloats((this._backPlate.scaling.x + TouchHolographicMenu.MENU_BUTTON_SCALE) / 2, this._backPlate.scaling.y / 2, 0);
  }
  /**
   * Creates a near menu GUI 3D control
   * @param name name of the near menu
   */
  constructor(name22) {
    super(name22);
    this._isPinned = false;
    this._defaultBehavior = new DefaultBehavior();
    this._dragObserver = this._defaultBehavior.sixDofDragBehavior.onDragObservable.add(() => {
      this.isPinned = true;
    });
    this.backPlateMargin = 1;
  }
  /**
   * Disposes the near menu
   */
  dispose() {
    super.dispose();
    this._defaultBehavior.sixDofDragBehavior.onDragObservable.remove(this._dragObserver);
    this._defaultBehavior.detach();
  }
};
NearMenu._ASSETS_BASE_URL = "https://assets.babylonjs.com/core/MRTK/";
NearMenu._PIN_ICON_FILENAME = "IconPin.png";

// node_modules/@babylonjs/gui/3D/controls/planePanel.js
var PlanePanel = class extends VolumeBasedPanel {
  _mapGridNode(control, nodePosition) {
    const mesh = control.mesh;
    if (!mesh) {
      return;
    }
    control.position = nodePosition.clone();
    const target = TmpVectors.Vector3[0];
    target.copyFrom(nodePosition);
    switch (this.orientation) {
      case Container3D.FACEORIGIN_ORIENTATION:
      case Container3D.FACEFORWARD_ORIENTATION:
        target.addInPlace(new Vector3(0, 0, 1));
        mesh.lookAt(target);
        break;
      case Container3D.FACEFORWARDREVERSED_ORIENTATION:
      case Container3D.FACEORIGINREVERSED_ORIENTATION:
        target.addInPlace(new Vector3(0, 0, -1));
        mesh.lookAt(target);
        break;
    }
  }
};

// node_modules/@babylonjs/gui/3D/controls/scatterPanel.js
var ScatterPanel = class extends VolumeBasedPanel {
  constructor() {
    super(...arguments);
    this._iteration = 100;
  }
  /**
   * Gets or sets the number of iteration to use to scatter the controls (100 by default)
   */
  get iteration() {
    return this._iteration;
  }
  set iteration(value) {
    if (this._iteration === value) {
      return;
    }
    this._iteration = value;
    Tools.SetImmediate(() => {
      this._arrangeChildren();
    });
  }
  _mapGridNode(control, nodePosition) {
    const mesh = control.mesh;
    const newPos = this._scatterMapping(nodePosition);
    if (!mesh) {
      return;
    }
    switch (this.orientation) {
      case Container3D.FACEORIGIN_ORIENTATION:
      case Container3D.FACEFORWARD_ORIENTATION:
        mesh.lookAt(new Vector3(0, 0, 1));
        break;
      case Container3D.FACEFORWARDREVERSED_ORIENTATION:
      case Container3D.FACEORIGINREVERSED_ORIENTATION:
        mesh.lookAt(new Vector3(0, 0, -1));
        break;
    }
    control.position = newPos;
  }
  _scatterMapping(source) {
    source.x = (1 - Math.random() * 2) * this._cellWidth;
    source.y = (1 - Math.random() * 2) * this._cellHeight;
    return source;
  }
  _finalProcessing() {
    const meshes = [];
    for (const child of this._children) {
      if (!child.mesh) {
        continue;
      }
      meshes.push(child.mesh);
    }
    for (let count = 0; count < this._iteration; count++) {
      meshes.sort((a, b) => {
        const distance1 = a.position.lengthSquared();
        const distance2 = b.position.lengthSquared();
        if (distance1 < distance2) {
          return 1;
        } else if (distance1 > distance2) {
          return -1;
        }
        return 0;
      });
      const radiusPaddingSquared = Math.pow(this.margin, 2);
      const cellSize = Math.max(this._cellWidth, this._cellHeight);
      const difference2D = TmpVectors.Vector2[0];
      const difference = TmpVectors.Vector3[0];
      for (let i = 0; i < meshes.length - 1; i++) {
        for (let j = i + 1; j < meshes.length; j++) {
          if (i != j) {
            meshes[j].position.subtractToRef(meshes[i].position, difference);
            difference2D.x = difference.x;
            difference2D.y = difference.y;
            const combinedRadius = cellSize;
            let distance = difference2D.lengthSquared() - radiusPaddingSquared;
            const minSeparation = Math.min(distance, radiusPaddingSquared);
            distance -= minSeparation;
            if (distance < Math.pow(combinedRadius, 2)) {
              difference2D.normalize();
              difference.scaleInPlace((combinedRadius - Math.sqrt(distance)) * 0.5);
              meshes[j].position.addInPlace(difference);
              meshes[i].position.subtractInPlace(difference);
            }
          }
        }
      }
    }
  }
};

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlSliderBar.fragment.js
var name10 = "mrdlSliderBarPixelShader";
var shader9 = `uniform vec3 cameraPosition;varying vec3 vPosition;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec3 vBinormal;varying vec4 vColor;varying vec4 vExtra1;varying vec4 vExtra2;varying vec4 vExtra3;uniform float _Radius_;uniform float _Bevel_Front_;uniform float _Bevel_Front_Stretch_;uniform float _Bevel_Back_;uniform float _Bevel_Back_Stretch_;uniform float _Radius_Top_Left_;uniform float _Radius_Top_Right_;uniform float _Radius_Bottom_Left_;uniform float _Radius_Bottom_Right_;uniform bool _Bulge_Enabled_;uniform float _Bulge_Height_;uniform float _Bulge_Radius_;uniform float _Sun_Intensity_;uniform float _Sun_Theta_;uniform float _Sun_Phi_;uniform float _Indirect_Diffuse_;uniform vec4 _Albedo_;uniform float _Specular_;uniform float _Shininess_;uniform float _Sharpness_;uniform float _Subsurface_;uniform vec4 _Left_Color_;uniform vec4 _Right_Color_;uniform float _Reflection_;uniform float _Front_Reflect_;uniform float _Edge_Reflect_;uniform float _Power_;uniform vec4 _Sky_Color_;uniform vec4 _Horizon_Color_;uniform vec4 _Ground_Color_;uniform float _Horizon_Power_;uniform sampler2D _Reflection_Map_;uniform sampler2D _Indirect_Environment_;uniform float _Width_;uniform float _Fuzz_;uniform float _Min_Fuzz_;uniform float _Clip_Fade_;uniform float _Hue_Shift_;uniform float _Saturation_Shift_;uniform float _Value_Shift_;uniform vec3 _Blob_Position_;uniform float _Blob_Intensity_;uniform float _Blob_Near_Size_;uniform float _Blob_Far_Size_;uniform float _Blob_Near_Distance_;uniform float _Blob_Far_Distance_;uniform float _Blob_Fade_Length_;uniform float _Blob_Pulse_;uniform float _Blob_Fade_;uniform sampler2D _Blob_Texture_;uniform vec3 _Blob_Position_2_;uniform float _Blob_Near_Size_2_;uniform float _Blob_Pulse_2_;uniform float _Blob_Fade_2_;uniform vec3 _Left_Index_Pos_;uniform vec3 _Right_Index_Pos_;uniform vec3 _Left_Index_Middle_Pos_;uniform vec3 _Right_Index_Middle_Pos_;uniform sampler2D _Decal_;uniform vec2 _Decal_Scale_XY_;uniform bool _Decal_Front_Only_;uniform float _Rim_Intensity_;uniform sampler2D _Rim_Texture_;uniform float _Rim_Hue_Shift_;uniform float _Rim_Saturation_Shift_;uniform float _Rim_Value_Shift_;uniform float _Iridescence_Intensity_;uniform sampler2D _Iridescence_Texture_;uniform bool Use_Global_Left_Index;uniform bool Use_Global_Right_Index;uniform vec4 Global_Left_Index_Tip_Position;uniform vec4 Global_Right_Index_Tip_Position;uniform vec4 Global_Left_Thumb_Tip_Position;uniform vec4 Global_Right_Thumb_Tip_Position;uniform vec4 Global_Left_Index_Middle_Position;uniform vec4 Global_Right_Index_Middle_Position;uniform float Global_Left_Index_Tip_Proximity;uniform float Global_Right_Index_Tip_Proximity;void Blob_Fragment_B30(
sampler2D Blob_Texture,
vec4 Blob_Info1,
vec4 Blob_Info2,
out vec4 Blob_Color)
{float k1=dot(Blob_Info1.xy,Blob_Info1.xy);float k2=dot(Blob_Info2.xy,Blob_Info2.xy);vec3 closer=k1<k2 ? vec3(k1,Blob_Info1.z,Blob_Info1.w) : vec3(k2,Blob_Info2.z,Blob_Info2.w);Blob_Color=closer.z*texture(Blob_Texture,vec2(vec2(sqrt(closer.x),closer.y).x,1.0-vec2(sqrt(closer.x),closer.y).y))*clamp(1.0-closer.x,0.0,1.0);}
void FastLinearTosRGB_B42(
vec4 Linear,
out vec4 sRGB)
{sRGB.rgb=sqrt(clamp(Linear.rgb,0.0,1.0));sRGB.a=Linear.a;}
void Scale_RGB_B59(
vec4 Color,
float Scalar,
out vec4 Result)
{Result=vec4(Scalar,Scalar,Scalar,1)*Color;}
void Fragment_Main_B121(
float Sun_Intensity,
float Sun_Theta,
float Sun_Phi,
vec3 Normal,
vec4 Albedo,
float Fresnel_Reflect,
float Shininess,
vec3 Incident,
vec4 Horizon_Color,
vec4 Sky_Color,
vec4 Ground_Color,
float Indirect_Diffuse,
float Specular,
float Horizon_Power,
float Reflection,
vec4 Reflection_Sample,
vec4 Indirect_Sample,
float Sharpness,
float SSS,
float Subsurface,
vec4 Translucence,
vec4 Rim_Light,
vec4 Iridescence,
out vec4 Result)
{float theta=Sun_Theta*2.0*3.14159;float phi=Sun_Phi*3.14159;vec3 lightDir= vec3(cos(phi)*cos(theta),sin(phi),cos(phi)*sin(theta));float NdotL=max(dot(lightDir,Normal),0.0);vec3 R=reflect(Incident,Normal);float RdotL=max(0.0,dot(R,lightDir));float specular=pow(RdotL,Shininess);specular=mix(specular,smoothstep(0.495*Sharpness,1.0-0.495*Sharpness,specular),Sharpness);vec4 gi=mix(Ground_Color,Sky_Color,Normal.y*0.5+0.5);Result=((Sun_Intensity*NdotL+Indirect_Sample*Indirect_Diffuse+Translucence)*(1.0+SSS*Subsurface))*Albedo*(1.0-Fresnel_Reflect)+(Sun_Intensity*specular*Specular+Fresnel_Reflect*Reflection*Reflection_Sample)+Fresnel_Reflect*Rim_Light+Iridescence;}
void Bulge_B79(
bool Enabled,
vec3 Normal,
vec3 Tangent,
float Bulge_Height,
vec4 UV,
float Bulge_Radius,
vec3 ButtonN,
out vec3 New_Normal)
{vec2 xy=clamp(UV.xy*2.0,vec2(-1,-1),vec2(1,1));vec3 B=(cross(Normal,Tangent));float k=-clamp(1.0-length(xy)/Bulge_Radius,0.0,1.0)*Bulge_Height;k=sin(k*3.14159*0.5);k*=smoothstep(0.9998,0.9999,abs(dot(ButtonN,Normal)));New_Normal=Normal*sqrt(1.0-k*k)+(xy.x*Tangent+xy.y*B)*k;New_Normal=Enabled ? New_Normal : Normal;}
void SSS_B77(
vec3 ButtonN,
vec3 Normal,
vec3 Incident,
out float Result)
{float NdotI=abs(dot(Normal,Incident));float BdotI=abs(dot(ButtonN,Incident));Result=(abs(NdotI-BdotI)); }
void FingerOcclusion_B67(
float Width,
float DistToCenter,
float Fuzz,
float Min_Fuzz,
vec3 Position,
vec3 Forward,
vec3 Nearest,
float Fade_Out,
out float NotInShadow)
{float d=dot((Nearest-Position),Forward);float sh=smoothstep(Width*0.5,Width*0.5+Fuzz*max(d,0.0)+Min_Fuzz,DistToCenter);NotInShadow=1.0-(1.0-sh)*smoothstep(-Fade_Out,0.0,d);}
void FingerOcclusion_B68(
float Width,
float DistToCenter,
float Fuzz,
float Min_Fuzz,
vec3 Position,
vec3 Forward,
vec3 Nearest,
float Fade_Out,
out float NotInShadow)
{float d=dot((Nearest-Position),Forward);float sh=smoothstep(Width*0.5,Width*0.5+Fuzz*max(d,0.0)+Min_Fuzz,DistToCenter);NotInShadow=1.0-(1.0-sh)*smoothstep(-Fade_Out,0.0,d);}
void Scale_Color_B91(
vec4 Color,
float Scalar,
out vec4 Result)
{Result=Scalar*Color;}
void From_HSV_B73(
float Hue,
float Saturation,
float Value,
float Alpha,
out vec4 Color)
{vec4 K=vec4(1.0,2.0/3.0,1.0/3.0,3.0);vec3 p=abs(fract(vec3(Hue,Hue,Hue)+K.xyz)*6.0-K.www);Color.rgb=Value*mix(K.xxx,clamp(p-K.xxx,0.0,1.0),Saturation);Color.a=Alpha;}
void Fast_Fresnel_B122(
float Front_Reflect,
float Edge_Reflect,
float Power,
vec3 Normal,
vec3 Incident,
out float Transmit,
out float Reflect)
{float d=max(-dot(Incident,Normal),0.0);Reflect=Front_Reflect+(Edge_Reflect-Front_Reflect)*pow(.01-d,Power);Transmit=1.0-Reflect;}
void Mapped_Environment_B51(
sampler2D Reflected_Environment,
sampler2D Indirect_Environment,
vec3 Dir,
out vec4 Reflected_Color,
out vec4 Indirect_Diffuse)
{Reflected_Color=texture(Reflected_Environment,vec2(atan(Dir.z,Dir.x)/3.14159*0.5,asin(Dir.y)/3.14159+0.5));Indirect_Diffuse=texture(Indirect_Environment,vec2(atan(Dir.z,Dir.x)/3.14159*0.5,asin(Dir.y)/3.14159+0.5));}
vec4 SampleEnv_Bid50(vec3 D,vec4 S,vec4 H,vec4 G,float exponent)
{float k=pow(abs(D.y),exponent);vec4 C;if (D.y>0.0) {C=mix(H,S,k);} else {C=mix(H,G,k); }
return C;}
void Sky_Environment_B50(
vec3 Normal,
vec3 Reflected,
vec4 Sky_Color,
vec4 Horizon_Color,
vec4 Ground_Color,
float Horizon_Power,
out vec4 Reflected_Color,
out vec4 Indirect_Color)
{Reflected_Color=SampleEnv_Bid50(Reflected,Sky_Color,Horizon_Color,Ground_Color,Horizon_Power);Indirect_Color=mix(Ground_Color,Sky_Color,Normal.y*0.5+0.5);}
void Min_Segment_Distance_B65(
vec3 P0,
vec3 P1,
vec3 Q0,
vec3 Q1,
out vec3 NearP,
out vec3 NearQ,
out float Distance)
{vec3 u=P1-P0;vec3 v=Q1-Q0;vec3 w=P0-Q0;float a=dot(u,u);float b=dot(u,v);float c=dot(v,v);float d=dot(u,w);float e=dot(v,w);float D=a*c-b*b;float sD=D;float tD=D;float sc,sN,tc,tN;if (D<0.00001) {sN=0.0;sD=1.0;tN=e;tD=c;} else {sN=(b*e-c*d);tN=(a*e-b*d);if (sN<0.0) {sN=0.0;tN=e;tD=c;} else if (sN>sD) {sN=sD;tN=e+b;tD=c;}}
if (tN<0.0) {tN=0.0;if (-d<0.0) {sN=0.0;} else if (-d>a) {sN=sD;} else {sN=-d;sD=a;}} else if (tN>tD) {tN=tD;if ((-d+b)<0.0) {sN=0.0;} else if ((-d+b)>a) {sN=sD;} else {sN=(-d+b);sD=a;}}
sc=abs(sN)<0.000001 ? 0.0 : sN/sD;tc=abs(tN)<0.000001 ? 0.0 : tN/tD;NearP=P0+sc*u;NearQ=Q0+tc*v;Distance=distance(NearP,NearQ);}
void To_XYZ_B74(
vec3 Vec3,
out float X,
out float Y,
out float Z)
{X=Vec3.x;Y=Vec3.y;Z=Vec3.z;}
void Finger_Positions_B64(
vec3 Left_Index_Pos,
vec3 Right_Index_Pos,
vec3 Left_Index_Middle_Pos,
vec3 Right_Index_Middle_Pos,
out vec3 Left_Index,
out vec3 Right_Index,
out vec3 Left_Index_Middle,
out vec3 Right_Index_Middle)
{Left_Index= (Use_Global_Left_Index ? Global_Left_Index_Tip_Position.xyz : Left_Index_Pos);Right_Index= (Use_Global_Right_Index ? Global_Right_Index_Tip_Position.xyz : Right_Index_Pos);Left_Index_Middle= (Use_Global_Left_Index ? Global_Left_Index_Middle_Position.xyz : Left_Index_Middle_Pos);Right_Index_Middle= (Use_Global_Right_Index ? Global_Right_Index_Middle_Position.xyz : Right_Index_Middle_Pos);}
void VaryHSV_B108(
vec3 HSV_In,
float Hue_Shift,
float Saturation_Shift,
float Value_Shift,
out vec3 HSV_Out)
{HSV_Out=vec3(fract(HSV_In.x+Hue_Shift),clamp(HSV_In.y+Saturation_Shift,0.0,1.0),clamp(HSV_In.z+Value_Shift,0.0,1.0));}
void Remap_Range_B114(
float In_Min,
float In_Max,
float Out_Min,
float Out_Max,
float In,
out float Out)
{Out=mix(Out_Min,Out_Max,clamp((In-In_Min)/(In_Max-In_Min),0.0,1.0));}
void To_HSV_B75(
vec4 Color,
out float Hue,
out float Saturation,
out float Value,
out float Alpha,
out vec3 HSV)
{vec4 K=vec4(0.0,-1.0/3.0,2.0/3.0,-1.0);vec4 p=Color.g<Color.b ? vec4(Color.bg,K.wz) : vec4(Color.gb,K.xy);vec4 q=Color.r<p.x ? vec4(p.xyw,Color.r) : vec4(Color.r,p.yzx);float d=q.x-min(q.w,q.y);float e=1.0e-10;Hue=abs(q.z+(q.w-q.y)/(6.0*d+e));Saturation=d/(q.x+e);Value=q.x;Alpha=Color.a;HSV=vec3(Hue,Saturation,Value);}
void Code_B110(
float X,
out float Result)
{Result=(acos(X)/3.14159-0.5)*2.0;}
void Rim_Light_B132(
vec3 Front,
vec3 Normal,
vec3 Incident,
float Rim_Intensity,
sampler2D Texture,
out vec4 Result)
{vec3 R=reflect(Incident,Normal);float RdotF=dot(R,Front);float RdotL=sqrt(1.0-RdotF*RdotF);vec2 UV=vec2(R.y*0.5+0.5,0.5);vec4 Color=texture(Texture,UV);Result=Color;}
void main()
{vec4 Blob_Color_Q30;
#if BLOB_ENABLE
Blob_Fragment_B30(_Blob_Texture_,vExtra2,vExtra3,Blob_Color_Q30);
#else
Blob_Color_Q30=vec4(0,0,0,0);
#endif
vec3 Incident_Q39=normalize(vPosition-cameraPosition);vec3 Normalized_Q38=normalize(vNormal);vec3 Normalized_Q71=normalize(vTangent);vec4 Color_Q83;
#if DECAL_ENABLE
Color_Q83=texture(_Decal_,vUV);
#else
Color_Q83=vec4(0,0,0,0);
#endif
float X_Q90;float Y_Q90;float Z_Q90;float W_Q90;X_Q90=vExtra1.x;Y_Q90=vExtra1.y;Z_Q90=vExtra1.z;W_Q90=vExtra1.w;vec4 Linear_Q43;Linear_Q43.rgb=clamp(_Sky_Color_.rgb*_Sky_Color_.rgb,0.0,1.0);Linear_Q43.a=_Sky_Color_.a;vec4 Linear_Q44;Linear_Q44.rgb=clamp(_Horizon_Color_.rgb*_Horizon_Color_.rgb,0.0,1.0);Linear_Q44.a=_Horizon_Color_.a;vec4 Linear_Q45;Linear_Q45.rgb=clamp(_Ground_Color_.rgb*_Ground_Color_.rgb,0.0,1.0);Linear_Q45.a=_Ground_Color_.a;vec3 Left_Index_Q64;vec3 Right_Index_Q64;vec3 Left_Index_Middle_Q64;vec3 Right_Index_Middle_Q64;Finger_Positions_B64(_Left_Index_Pos_,_Right_Index_Pos_,_Left_Index_Middle_Pos_,_Right_Index_Middle_Pos_,Left_Index_Q64,Right_Index_Q64,Left_Index_Middle_Q64,Right_Index_Middle_Q64);vec4 Linear_Q46;Linear_Q46.rgb=clamp(_Albedo_.rgb*_Albedo_.rgb,0.0,1.0);Linear_Q46.a=_Albedo_.a;vec3 Normalized_Q107=normalize(vBinormal);vec3 Incident_Q70=normalize(vPosition-cameraPosition);vec3 New_Normal_Q79;Bulge_B79(_Bulge_Enabled_,Normalized_Q38,Normalized_Q71,_Bulge_Height_,vColor,_Bulge_Radius_,vBinormal,New_Normal_Q79);float Result_Q77;SSS_B77(vBinormal,New_Normal_Q79,Incident_Q39,Result_Q77);vec4 Result_Q91;Scale_Color_B91(Color_Q83,X_Q90,Result_Q91);float Transmit_Q122;float Reflect_Q122;Fast_Fresnel_B122(_Front_Reflect_,_Edge_Reflect_,_Power_,New_Normal_Q79,Incident_Q39,Transmit_Q122,Reflect_Q122);float Product_Q125=Y_Q90*Y_Q90;vec3 NearP_Q65;vec3 NearQ_Q65;float Distance_Q65;Min_Segment_Distance_B65(Left_Index_Q64,Left_Index_Middle_Q64,vPosition,cameraPosition,NearP_Q65,NearQ_Q65,Distance_Q65);vec3 NearP_Q63;vec3 NearQ_Q63;float Distance_Q63;Min_Segment_Distance_B65(Right_Index_Q64,Right_Index_Middle_Q64,vPosition,cameraPosition,NearP_Q63,NearQ_Q63,Distance_Q63);vec3 Reflected_Q47=reflect(Incident_Q39,New_Normal_Q79);vec4 Product_Q103=Linear_Q46*vec4(1,1,1,1);vec4 Result_Q132;Rim_Light_B132(Normalized_Q107,Normalized_Q38,Incident_Q70,_Rim_Intensity_,_Rim_Texture_,Result_Q132);float Dot_Q72=dot(Incident_Q70, Normalized_Q71);float MaxAB_Q123=max(Reflect_Q122,Product_Q125);float NotInShadow_Q67;
#if OCCLUSION_ENABLED
FingerOcclusion_B67(_Width_,Distance_Q65,_Fuzz_,_Min_Fuzz_,vPosition,vBinormal,NearP_Q65,_Clip_Fade_,NotInShadow_Q67);
#else
NotInShadow_Q67=1.0;
#endif
float NotInShadow_Q68;
#if OCCLUSION_ENABLED
FingerOcclusion_B68(_Width_,Distance_Q63,_Fuzz_,_Min_Fuzz_,vPosition,vBinormal,NearP_Q63,_Clip_Fade_,NotInShadow_Q68);
#else
NotInShadow_Q68=1.0;
#endif
vec4 Reflected_Color_Q51;vec4 Indirect_Diffuse_Q51;
#if ENV_ENABLE
Mapped_Environment_B51(_Reflection_Map_,_Indirect_Environment_,Reflected_Q47,Reflected_Color_Q51,Indirect_Diffuse_Q51);
#else
Reflected_Color_Q51=vec4(0,0,0,1);Indirect_Diffuse_Q51=vec4(0,0,0,1);
#endif
vec4 Reflected_Color_Q50;vec4 Indirect_Color_Q50;
#if SKY_ENABLED
Sky_Environment_B50(New_Normal_Q79,Reflected_Q47,Linear_Q43,Linear_Q44,Linear_Q45,_Horizon_Power_,Reflected_Color_Q50,Indirect_Color_Q50);
#else
Reflected_Color_Q50=vec4(0,0,0,1);Indirect_Color_Q50=vec4(0,0,0,1);
#endif
float Hue_Q75;float Saturation_Q75;float Value_Q75;float Alpha_Q75;vec3 HSV_Q75;To_HSV_B75(Product_Q103,Hue_Q75,Saturation_Q75,Value_Q75,Alpha_Q75,HSV_Q75);float Hue_Q127;float Saturation_Q127;float Value_Q127;float Alpha_Q127;vec3 HSV_Q127;To_HSV_B75(Result_Q132,Hue_Q127,Saturation_Q127,Value_Q127,Alpha_Q127,HSV_Q127);float Result_Q110;Code_B110(Dot_Q72,Result_Q110);float AbsA_Q76=abs(Result_Q110);float MinAB_Q58=min(NotInShadow_Q67,NotInShadow_Q68);vec4 Sum_Q48=Reflected_Color_Q51+Reflected_Color_Q50;vec4 Sum_Q49=Indirect_Diffuse_Q51+Indirect_Color_Q50;vec3 HSV_Out_Q126;VaryHSV_B108(HSV_Q127,_Rim_Hue_Shift_,_Rim_Saturation_Shift_,_Rim_Value_Shift_,HSV_Out_Q126);float Out_Q114;Remap_Range_B114(-1.0,1.0,0.0,1.0,Result_Q110,Out_Q114);float Product_Q106;Product_Q106=AbsA_Q76*_Hue_Shift_;float X_Q128;float Y_Q128;float Z_Q128;To_XYZ_B74(HSV_Out_Q126,X_Q128,Y_Q128,Z_Q128);vec2 Vec2_Q112=vec2(Out_Q114,0.5);vec3 HSV_Out_Q108;VaryHSV_B108(HSV_Q75,Product_Q106,_Saturation_Shift_,_Value_Shift_,HSV_Out_Q108);vec4 Color_Q129;From_HSV_B73(X_Q128,Y_Q128,Z_Q128,0.0,Color_Q129);vec4 Color_Q111;
#if IRIDESCENCE_ENABLED
Color_Q111=texture(_Iridescence_Texture_,Vec2_Q112);
#else
Color_Q111=vec4(0,0,0,0);
#endif
float X_Q74;float Y_Q74;float Z_Q74;To_XYZ_B74(HSV_Out_Q108,X_Q74,Y_Q74,Z_Q74);vec4 Result_Q131=_Rim_Intensity_*Color_Q129;vec4 Result_Q113=_Iridescence_Intensity_*Color_Q111;vec4 Color_Q73;From_HSV_B73(X_Q74,Y_Q74,Z_Q74,0.0,Color_Q73);vec4 Result_Q84=Result_Q91+(1.0-Result_Q91.a)*Color_Q73;vec4 Result_Q121;Fragment_Main_B121(_Sun_Intensity_,_Sun_Theta_,_Sun_Phi_,New_Normal_Q79,Result_Q84,MaxAB_Q123,_Shininess_,Incident_Q39,_Horizon_Color_,_Sky_Color_,_Ground_Color_,_Indirect_Diffuse_,_Specular_,_Horizon_Power_,_Reflection_,Sum_Q48,Sum_Q49,_Sharpness_,Result_Q77,_Subsurface_,vec4(0,0,0,0),Result_Q131,Result_Q113,Result_Q121);vec4 Result_Q59;Scale_RGB_B59(Result_Q121,MinAB_Q58,Result_Q59);vec4 sRGB_Q42;FastLinearTosRGB_B42(Result_Q59,sRGB_Q42);vec4 Result_Q31=Blob_Color_Q30+(1.0-Blob_Color_Q30.a)*sRGB_Q42;vec4 Result_Q40=Result_Q31; Result_Q40.a=1.0;vec4 Out_Color=Result_Q40;float Clip_Threshold=0.001;bool To_sRGB=false;gl_FragColor=Out_Color;}`;
if (!ShaderStore.ShadersStore[name10]) {
  ShaderStore.ShadersStore[name10] = shader9;
}

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlSliderBar.vertex.js
var name11 = "mrdlSliderBarVertexShader";
var shader10 = `uniform mat4 world;uniform mat4 viewProjection;uniform vec3 cameraPosition;attribute vec3 position;attribute vec3 normal;attribute vec2 uv;
#ifdef TANGENT
attribute vec3 tangent;
#else
const vec3 tangent=vec3(0.);
#endif
uniform float _Radius_;uniform float _Bevel_Front_;uniform float _Bevel_Front_Stretch_;uniform float _Bevel_Back_;uniform float _Bevel_Back_Stretch_;uniform float _Radius_Top_Left_;uniform float _Radius_Top_Right_;uniform float _Radius_Bottom_Left_;uniform float _Radius_Bottom_Right_;uniform bool _Bulge_Enabled_;uniform float _Bulge_Height_;uniform float _Bulge_Radius_;uniform float _Sun_Intensity_;uniform float _Sun_Theta_;uniform float _Sun_Phi_;uniform float _Indirect_Diffuse_;uniform vec4 _Albedo_;uniform float _Specular_;uniform float _Shininess_;uniform float _Sharpness_;uniform float _Subsurface_;uniform vec4 _Left_Color_;uniform vec4 _Right_Color_;uniform float _Reflection_;uniform float _Front_Reflect_;uniform float _Edge_Reflect_;uniform float _Power_;uniform vec4 _Sky_Color_;uniform vec4 _Horizon_Color_;uniform vec4 _Ground_Color_;uniform float _Horizon_Power_;uniform sampler2D _Reflection_Map_;uniform sampler2D _Indirect_Environment_;uniform float _Width_;uniform float _Fuzz_;uniform float _Min_Fuzz_;uniform float _Clip_Fade_;uniform float _Hue_Shift_;uniform float _Saturation_Shift_;uniform float _Value_Shift_;uniform vec3 _Blob_Position_;uniform float _Blob_Intensity_;uniform float _Blob_Near_Size_;uniform float _Blob_Far_Size_;uniform float _Blob_Near_Distance_;uniform float _Blob_Far_Distance_;uniform float _Blob_Fade_Length_;uniform float _Blob_Pulse_;uniform float _Blob_Fade_;uniform sampler2D _Blob_Texture_;uniform vec3 _Blob_Position_2_;uniform float _Blob_Near_Size_2_;uniform float _Blob_Pulse_2_;uniform float _Blob_Fade_2_;uniform vec3 _Left_Index_Pos_;uniform vec3 _Right_Index_Pos_;uniform vec3 _Left_Index_Middle_Pos_;uniform vec3 _Right_Index_Middle_Pos_;uniform sampler2D _Decal_;uniform vec2 _Decal_Scale_XY_;uniform bool _Decal_Front_Only_;uniform float _Rim_Intensity_;uniform sampler2D _Rim_Texture_;uniform float _Rim_Hue_Shift_;uniform float _Rim_Saturation_Shift_;uniform float _Rim_Value_Shift_;uniform float _Iridescence_Intensity_;uniform sampler2D _Iridescence_Texture_;uniform bool Use_Global_Left_Index;uniform bool Use_Global_Right_Index;uniform vec4 Global_Left_Index_Tip_Position;uniform vec4 Global_Right_Index_Tip_Position;uniform vec4 Global_Left_Thumb_Tip_Position;uniform vec4 Global_Right_Thumb_Tip_Position;uniform float Global_Left_Index_Tip_Proximity;uniform float Global_Right_Index_Tip_Proximity;varying vec3 vPosition;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec3 vBinormal;varying vec4 vColor;varying vec4 vExtra1;varying vec4 vExtra2;varying vec4 vExtra3;void Object_To_World_Pos_B12(
vec3 Pos_Object,
out vec3 Pos_World)
{Pos_World=(world*vec4(Pos_Object,1.0)).xyz;}
void Object_To_World_Normal_B32(
vec3 Nrm_Object,
out vec3 Nrm_World)
{Nrm_World=(vec4(Nrm_Object,0.0)).xyz;}
void Blob_Vertex_B23(
vec3 Position,
vec3 Normal,
vec3 Tangent,
vec3 Bitangent,
vec3 Blob_Position,
float Intensity,
float Blob_Near_Size,
float Blob_Far_Size,
float Blob_Near_Distance,
float Blob_Far_Distance,
float Blob_Fade_Length,
float Blob_Pulse,
float Blob_Fade,
out vec4 Blob_Info)
{vec3 blob= (Use_Global_Left_Index ? Global_Left_Index_Tip_Position.xyz : Blob_Position);vec3 delta=blob-Position;float dist=dot(Normal,delta);float lerpValue=clamp((abs(dist)-Blob_Near_Distance)/(Blob_Far_Distance-Blob_Near_Distance),0.0,1.0);float fadeValue=1.0-clamp((abs(dist)-Blob_Far_Distance)/Blob_Fade_Length,0.0,1.0);float size=Blob_Near_Size+(Blob_Far_Size-Blob_Near_Size)*lerpValue;vec2 blobXY=vec2(dot(delta,Tangent),dot(delta,Bitangent))/(0.0001+size);float Fade=fadeValue*Intensity*Blob_Fade;float Distance=(lerpValue*0.5+0.5)*(1.0-Blob_Pulse);Blob_Info=vec4(blobXY.x,blobXY.y,Distance,Fade);}
void Blob_Vertex_B24(
vec3 Position,
vec3 Normal,
vec3 Tangent,
vec3 Bitangent,
vec3 Blob_Position,
float Intensity,
float Blob_Near_Size,
float Blob_Far_Size,
float Blob_Near_Distance,
float Blob_Far_Distance,
float Blob_Fade_Length,
float Blob_Pulse,
float Blob_Fade,
out vec4 Blob_Info)
{vec3 blob= (Use_Global_Right_Index ? Global_Right_Index_Tip_Position.xyz : Blob_Position);vec3 delta=blob-Position;float dist=dot(Normal,delta);float lerpValue=clamp((abs(dist)-Blob_Near_Distance)/(Blob_Far_Distance-Blob_Near_Distance),0.0,1.0);float fadeValue=1.0-clamp((abs(dist)-Blob_Far_Distance)/Blob_Fade_Length,0.0,1.0);float size=Blob_Near_Size+(Blob_Far_Size-Blob_Near_Size)*lerpValue;vec2 blobXY=vec2(dot(delta,Tangent),dot(delta,Bitangent))/(0.0001+size);float Fade=fadeValue*Intensity*Blob_Fade;float Distance=(lerpValue*0.5+0.5)*(1.0-Blob_Pulse);Blob_Info=vec4(blobXY.x,blobXY.y,Distance,Fade);}
void Move_Verts_B130(
float Anisotropy,
vec3 P,
float Radius,
float Bevel,
vec3 Normal_Object,
float ScaleZ,
float Stretch,
out vec3 New_P,
out vec2 New_UV,
out float Radial_Gradient,
out vec3 Radial_Dir,
out vec3 New_Normal)
{vec2 UV=P.xy*2.0+0.5;vec2 center=clamp(UV,0.0,1.0);vec2 delta=UV-center;float deltad=(length(delta)*2.0);float f=(Bevel+(Radius-Bevel)*Stretch)/Radius;float innerd=clamp(deltad*2.0,0.0,1.0);float outerd=clamp(deltad*2.0-1.0,0.0,1.0);float bevelAngle=outerd*3.14159*0.5;float sinb=sin(bevelAngle);float cosb=cos(bevelAngle);float beveld=(1.0-f)*innerd+f*sinb;float br=outerd;vec2 r2=2.0*vec2(Radius/Anisotropy,Radius);float dir=P.z<0.0001 ? 1.0 : -1.0;New_UV=center+r2*((0.5-center)+normalize(delta+vec2(0.0,0.000001))*beveld*0.5);New_P=vec3(New_UV-0.5,P.z+dir*(1.0-cosb)*Bevel*ScaleZ);Radial_Gradient=clamp((deltad-0.5)*2.0,0.0,1.0);Radial_Dir=vec3(delta*r2,0.0);vec3 beveledNormal=cosb*Normal_Object+sinb*vec3(delta.x,delta.y,0.0);New_Normal=Normal_Object.z==0.0 ? Normal_Object : beveledNormal;}
void Object_To_World_Dir_B60(
vec3 Dir_Object,
out vec3 Normal_World,
out vec3 Normal_World_N,
out float Normal_Length)
{Normal_World=(world*vec4(Dir_Object,0.0)).xyz;Normal_Length=length(Normal_World);Normal_World_N=Normal_World/Normal_Length;}
void To_XYZ_B78(
vec3 Vec3,
out float X,
out float Y,
out float Z)
{X=Vec3.x;Y=Vec3.y;Z=Vec3.z;}
void Conditional_Float_B93(
bool Which,
float If_True,
float If_False,
out float Result)
{Result=Which ? If_True : If_False;}
void Object_To_World_Dir_B28(
vec3 Dir_Object,
out vec3 Binormal_World,
out vec3 Binormal_World_N,
out float Binormal_Length)
{Binormal_World=(world*vec4(Dir_Object,0.0)).xyz;Binormal_Length=length(Binormal_World);Binormal_World_N=Binormal_World/Binormal_Length;}
void Pick_Radius_B69(
float Radius,
float Radius_Top_Left,
float Radius_Top_Right,
float Radius_Bottom_Left,
float Radius_Bottom_Right,
vec3 Position,
out float Result)
{bool whichY=Position.y>0.0;Result=Position.x<0.0 ? (whichY ? Radius_Top_Left : Radius_Bottom_Left) : (whichY ? Radius_Top_Right : Radius_Bottom_Right);Result*=Radius;}
void Conditional_Float_B36(
bool Which,
float If_True,
float If_False,
out float Result)
{Result=Which ? If_True : If_False;}
void Greater_Than_B37(
float Left,
float Right,
out bool Not_Greater_Than,
out bool Greater_Than)
{Greater_Than=Left>Right;Not_Greater_Than=!Greater_Than;}
void Remap_Range_B105(
float In_Min,
float In_Max,
float Out_Min,
float Out_Max,
float In,
out float Out)
{Out=mix(Out_Min,Out_Max,clamp((In-In_Min)/(In_Max-In_Min),0.0,1.0));}
void main()
{vec2 XY_Q85;XY_Q85=(uv-vec2(0.5,0.5))*_Decal_Scale_XY_+vec2(0.5,0.5);vec3 Tangent_World_Q27;vec3 Tangent_World_N_Q27;float Tangent_Length_Q27;Tangent_World_Q27=(world*vec4(vec3(1,0,0),0.0)).xyz;Tangent_Length_Q27=length(Tangent_World_Q27);Tangent_World_N_Q27=Tangent_World_Q27/Tangent_Length_Q27;vec3 Normal_World_Q60;vec3 Normal_World_N_Q60;float Normal_Length_Q60;Object_To_World_Dir_B60(vec3(0,0,1),Normal_World_Q60,Normal_World_N_Q60,Normal_Length_Q60);float X_Q78;float Y_Q78;float Z_Q78;To_XYZ_B78(position,X_Q78,Y_Q78,Z_Q78);vec3 Nrm_World_Q26;Nrm_World_Q26=normalize((world*vec4(normal,0.0)).xyz);vec3 Binormal_World_Q28;vec3 Binormal_World_N_Q28;float Binormal_Length_Q28;Object_To_World_Dir_B28(vec3(0,1,0),Binormal_World_Q28,Binormal_World_N_Q28,Binormal_Length_Q28);float Anisotropy_Q29=Tangent_Length_Q27/Binormal_Length_Q28;float Result_Q69;Pick_Radius_B69(_Radius_,_Radius_Top_Left_,_Radius_Top_Right_,_Radius_Bottom_Left_,_Radius_Bottom_Right_,position,Result_Q69);float Anisotropy_Q53=Binormal_Length_Q28/Normal_Length_Q60;bool Not_Greater_Than_Q37;bool Greater_Than_Q37;Greater_Than_B37(Z_Q78,0.0,Not_Greater_Than_Q37,Greater_Than_Q37);vec4 Linear_Q101;Linear_Q101.rgb=clamp(_Left_Color_.rgb*_Left_Color_.rgb,0.0,1.0);Linear_Q101.a=_Left_Color_.a;vec4 Linear_Q102;Linear_Q102.rgb=clamp(_Right_Color_.rgb*_Right_Color_.rgb,0.0,1.0);Linear_Q102.a=_Right_Color_.a;vec3 Difference_Q61=vec3(0,0,0)-Normal_World_N_Q60;vec4 Out_Color_Q34=vec4(X_Q78,Y_Q78,Z_Q78,1);float Result_Q36;Conditional_Float_B36(Greater_Than_Q37,_Bevel_Back_,_Bevel_Front_,Result_Q36);float Result_Q94;Conditional_Float_B36(Greater_Than_Q37,_Bevel_Back_Stretch_,_Bevel_Front_Stretch_,Result_Q94);vec3 New_P_Q130;vec2 New_UV_Q130;float Radial_Gradient_Q130;vec3 Radial_Dir_Q130;vec3 New_Normal_Q130;Move_Verts_B130(Anisotropy_Q29,position,Result_Q69,Result_Q36,normal,Anisotropy_Q53,Result_Q94,New_P_Q130,New_UV_Q130,Radial_Gradient_Q130,Radial_Dir_Q130,New_Normal_Q130);float X_Q98;float Y_Q98;X_Q98=New_UV_Q130.x;Y_Q98=New_UV_Q130.y;vec3 Pos_World_Q12;Object_To_World_Pos_B12(New_P_Q130,Pos_World_Q12);vec3 Nrm_World_Q32;Object_To_World_Normal_B32(New_Normal_Q130,Nrm_World_Q32);vec4 Blob_Info_Q23;
#if BLOB_ENABLE
Blob_Vertex_B23(Pos_World_Q12,Nrm_World_Q26,Tangent_World_N_Q27,Binormal_World_N_Q28,_Blob_Position_,_Blob_Intensity_,_Blob_Near_Size_,_Blob_Far_Size_,_Blob_Near_Distance_,_Blob_Far_Distance_,_Blob_Fade_Length_,_Blob_Pulse_,_Blob_Fade_,Blob_Info_Q23);
#else
Blob_Info_Q23=vec4(0,0,0,0);
#endif
vec4 Blob_Info_Q24;
#if BLOB_ENABLE_2
Blob_Vertex_B24(Pos_World_Q12,Nrm_World_Q26,Tangent_World_N_Q27,Binormal_World_N_Q28,_Blob_Position_2_,_Blob_Intensity_,_Blob_Near_Size_2_,_Blob_Far_Size_,_Blob_Near_Distance_,_Blob_Far_Distance_,_Blob_Fade_Length_,_Blob_Pulse_2_,_Blob_Fade_2_,Blob_Info_Q24);
#else
Blob_Info_Q24=vec4(0,0,0,0);
#endif
float Out_Q105;Remap_Range_B105(0.0,1.0,0.0,1.0,X_Q98,Out_Q105);float X_Q86;float Y_Q86;float Z_Q86;To_XYZ_B78(Nrm_World_Q32,X_Q86,Y_Q86,Z_Q86);vec4 Color_At_T_Q97=mix(Linear_Q101,Linear_Q102,Out_Q105);float Minus_F_Q87=-Z_Q86;float R_Q99;float G_Q99;float B_Q99;float A_Q99;R_Q99=Color_At_T_Q97.r; G_Q99=Color_At_T_Q97.g; B_Q99=Color_At_T_Q97.b; A_Q99=Color_At_T_Q97.a;float ClampF_Q88=clamp(0.0,Minus_F_Q87,1.0);float Result_Q93;Conditional_Float_B93(_Decal_Front_Only_,ClampF_Q88,1.0,Result_Q93);vec4 Vec4_Q89=vec4(Result_Q93,Radial_Gradient_Q130,G_Q99,B_Q99);vec3 Position=Pos_World_Q12;vec3 Normal=Nrm_World_Q32;vec2 UV=XY_Q85;vec3 Tangent=Tangent_World_N_Q27;vec3 Binormal=Difference_Q61;vec4 Color=Out_Color_Q34;vec4 Extra1=Vec4_Q89;vec4 Extra2=Blob_Info_Q23;vec4 Extra3=Blob_Info_Q24;gl_Position=viewProjection*vec4(Position,1);vPosition=Position;vNormal=Normal;vUV=UV;vTangent=Tangent;vBinormal=Binormal;vColor=Color;vExtra1=Extra1;vExtra2=Extra2;vExtra3=Extra3;}`;
if (!ShaderStore.ShadersStore[name11]) {
  ShaderStore.ShadersStore[name11] = shader10;
}

// node_modules/@babylonjs/gui/3D/materials/mrdl/mrdlSliderBarMaterial.js
var MRDLSliderBarMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.SKY_ENABLED = true;
    this.BLOB_ENABLE_2 = true;
    this.IRIDESCENCE_ENABLED = true;
    this._needNormals = true;
    this._needUVs = true;
    this.rebuild();
  }
};
var MRDLSliderBarMaterial = class _MRDLSliderBarMaterial extends PushMaterial {
  constructor(name22, scene) {
    super(name22, scene);
    this.radius = 0.6;
    this.bevelFront = 0.6;
    this.bevelFrontStretch = 0.077;
    this.bevelBack = 0;
    this.bevelBackStretch = 0;
    this.radiusTopLeft = 1;
    this.radiusTopRight = 1;
    this.radiusBottomLeft = 1;
    this.radiusBottomRight = 1;
    this.bulgeEnabled = false;
    this.bulgeHeight = -0.323;
    this.bulgeRadius = 0.73;
    this.sunIntensity = 1.102;
    this.sunTheta = 0.76;
    this.sunPhi = 0.526;
    this.indirectDiffuse = 0.658;
    this.albedo = new Color4(0.0117647, 0.505882, 0.996078, 1);
    this.specular = 0;
    this.shininess = 10;
    this.sharpness = 0;
    this.subsurface = 0;
    this.leftGradientColor = new Color4(0.0117647, 0.505882, 0.996078, 1);
    this.rightGradientColor = new Color4(0.0117647, 0.505882, 0.996078, 1);
    this.reflection = 0.749;
    this.frontReflect = 0;
    this.edgeReflect = 0.09;
    this.power = 8.13;
    this.skyColor = new Color4(0.0117647, 0.964706, 0.996078, 1);
    this.horizonColor = new Color4(0.0117647, 0.333333, 0.996078, 1);
    this.groundColor = new Color4(0, 0.254902, 0.996078, 1);
    this.horizonPower = 1;
    this.width = 0.02;
    this.fuzz = 0.5;
    this.minFuzz = 1e-3;
    this.clipFade = 0.01;
    this.hueShift = 0;
    this.saturationShift = 0;
    this.valueShift = 0;
    this.blobPosition = new Vector3(0, 0, 0.1);
    this.blobIntensity = 0.5;
    this.blobNearSize = 0.01;
    this.blobFarSize = 0.03;
    this.blobNearDistance = 0;
    this.blobFarDistance = 0.08;
    this.blobFadeLength = 0.576;
    this.blobPulse = 0;
    this.blobFade = 1;
    this.blobPosition2 = new Vector3(0.2, 0, 0.1);
    this.blobNearSize2 = 0.01;
    this.blobPulse2 = 0;
    this.blobFade2 = 1;
    this.blobTexture = new Texture("", this.getScene());
    this.leftIndexPosition = new Vector3(0, 0, 1);
    this.rightIndexPosition = new Vector3(-1, -1, -1);
    this.leftIndexMiddlePosition = new Vector3(0, 0, 0);
    this.rightIndexMiddlePosition = new Vector3(0, 0, 0);
    this.decalScaleXY = new Vector2(1.5, 1.5);
    this.decalFrontOnly = true;
    this.rimIntensity = 0.287;
    this.rimHueShift = 0;
    this.rimSaturationShift = 0;
    this.rimValueShift = -1;
    this.iridescenceIntensity = 0;
    this.useGlobalLeftIndex = 1;
    this.useGlobalRightIndex = 1;
    this.globalLeftIndexTipProximity = 0;
    this.globalRightIndexTipProximity = 0;
    this.globalLeftIndexTipPosition = new Vector4(0.5, 0, -0.55, 1);
    this.globaRightIndexTipPosition = new Vector4(0, 0, 0, 1);
    this.globalLeftThumbTipPosition = new Vector4(0.5, 0, -0.55, 1);
    this.globalRightThumbTipPosition = new Vector4(0, 0, 0, 1);
    this.globalLeftIndexMiddlePosition = new Vector4(0.5, 0, -0.55, 1);
    this.globalRightIndexMiddlePosition = new Vector4(0, 0, 0, 1);
    this.alphaMode = Constants.ALPHA_DISABLE;
    this.backFaceCulling = false;
    const textureUrl = Tools.GetAssetUrl(_MRDLSliderBarMaterial.BLUE_GRADIENT_TEXTURE_URL);
    this._blueGradientTexture = new Texture(textureUrl, this.getScene(), true, false, Texture.NEAREST_SAMPLINGMODE);
    this._decalTexture = new Texture("", this.getScene());
    this._reflectionMapTexture = new Texture("", this.getScene());
    this._indirectEnvTexture = new Texture("", this.getScene());
  }
  needAlphaBlending() {
    return false;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new MRDLSliderBarMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    PrepareDefinesForAttributes(mesh, defines, false, false);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks);
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      if (defines.TANGENT) {
        attribs.push(VertexBuffer.TangentKind);
      }
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "mrdlSliderBar";
      const join = defines.toString();
      const uniforms = [
        "world",
        "viewProjection",
        "cameraPosition",
        "_Radius_",
        "_Bevel_Front_",
        "_Bevel_Front_Stretch_",
        "_Bevel_Back_",
        "_Bevel_Back_Stretch_",
        "_Radius_Top_Left_",
        "_Radius_Top_Right_",
        "_Radius_Bottom_Left_",
        "_Radius_Bottom_Right_",
        "_Bulge_Enabled_",
        "_Bulge_Height_",
        "_Bulge_Radius_",
        "_Sun_Intensity_",
        "_Sun_Theta_",
        "_Sun_Phi_",
        "_Indirect_Diffuse_",
        "_Albedo_",
        "_Specular_",
        "_Shininess_",
        "_Sharpness_",
        "_Subsurface_",
        "_Left_Color_",
        "_Right_Color_",
        "_Reflection_",
        "_Front_Reflect_",
        "_Edge_Reflect_",
        "_Power_",
        "_Sky_Color_",
        "_Horizon_Color_",
        "_Ground_Color_",
        "_Horizon_Power_",
        "_Reflection_Map_",
        "_Indirect_Environment_",
        "_Width_",
        "_Fuzz_",
        "_Min_Fuzz_",
        "_Clip_Fade_",
        "_Hue_Shift_",
        "_Saturation_Shift_",
        "_Value_Shift_",
        "_Blob_Position_",
        "_Blob_Intensity_",
        "_Blob_Near_Size_",
        "_Blob_Far_Size_",
        "_Blob_Near_Distance_",
        "_Blob_Far_Distance_",
        "_Blob_Fade_Length_",
        "_Blob_Pulse_",
        "_Blob_Fade_",
        "_Blob_Texture_",
        "_Blob_Position_2_",
        "_Blob_Near_Size_2_",
        "_Blob_Pulse_2_",
        "_Blob_Fade_2_",
        "_Left_Index_Pos_",
        "_Right_Index_Pos_",
        "_Left_Index_Middle_Pos_",
        "_Right_Index_Middle_Pos_",
        "_Decal_",
        "_Decal_Scale_XY_",
        "_Decal_Front_Only_",
        "_Rim_Intensity_",
        "_Rim_Texture_",
        "_Rim_Hue_Shift_",
        "_Rim_Saturation_Shift_",
        "_Rim_Value_Shift_",
        "_Iridescence_Intensity_",
        "_Iridescence_Texture_",
        "Use_Global_Left_Index",
        "Use_Global_Right_Index",
        "Global_Left_Index_Tip_Position",
        "Global_Right_Index_Tip_Position",
        "Global_Left_Thumb_Tip_Position",
        "Global_Right_Thumb_Tip_Position",
        "Global_Left_Index_Middle_Position;",
        "Global_Right_Index_Middle_Position",
        "Global_Left_Index_Tip_Proximity",
        "Global_Right_Index_Tip_Proximity"
      ];
      const samplers = ["_Rim_Texture_", "_Iridescence_Texture_"];
      const uniformBuffers = [];
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 4
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 4 }
      }, engine), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", this.getScene().getTransformMatrix());
    this._activeEffect.setVector3("cameraPosition", this.getScene().activeCamera.position);
    this._activeEffect.setFloat("_Radius_", this.radius);
    this._activeEffect.setFloat("_Bevel_Front_", this.bevelFront);
    this._activeEffect.setFloat("_Bevel_Front_Stretch_", this.bevelFrontStretch);
    this._activeEffect.setFloat("_Bevel_Back_", this.bevelBack);
    this._activeEffect.setFloat("_Bevel_Back_Stretch_", this.bevelBackStretch);
    this._activeEffect.setFloat("_Radius_Top_Left_", this.radiusTopLeft);
    this._activeEffect.setFloat("_Radius_Top_Right_", this.radiusTopRight);
    this._activeEffect.setFloat("_Radius_Bottom_Left_", this.radiusBottomLeft);
    this._activeEffect.setFloat("_Radius_Bottom_Right_", this.radiusBottomRight);
    this._activeEffect.setFloat("_Bulge_Enabled_", this.bulgeEnabled ? 1 : 0);
    this._activeEffect.setFloat("_Bulge_Height_", this.bulgeHeight);
    this._activeEffect.setFloat("_Bulge_Radius_", this.bulgeRadius);
    this._activeEffect.setFloat("_Sun_Intensity_", this.sunIntensity);
    this._activeEffect.setFloat("_Sun_Theta_", this.sunTheta);
    this._activeEffect.setFloat("_Sun_Phi_", this.sunPhi);
    this._activeEffect.setFloat("_Indirect_Diffuse_", this.indirectDiffuse);
    this._activeEffect.setDirectColor4("_Albedo_", this.albedo);
    this._activeEffect.setFloat("_Specular_", this.specular);
    this._activeEffect.setFloat("_Shininess_", this.shininess);
    this._activeEffect.setFloat("_Sharpness_", this.sharpness);
    this._activeEffect.setFloat("_Subsurface_", this.subsurface);
    this._activeEffect.setDirectColor4("_Left_Color_", this.leftGradientColor);
    this._activeEffect.setDirectColor4("_Right_Color_", this.rightGradientColor);
    this._activeEffect.setFloat("_Reflection_", this.reflection);
    this._activeEffect.setFloat("_Front_Reflect_", this.frontReflect);
    this._activeEffect.setFloat("_Edge_Reflect_", this.edgeReflect);
    this._activeEffect.setFloat("_Power_", this.power);
    this._activeEffect.setDirectColor4("_Sky_Color_", this.skyColor);
    this._activeEffect.setDirectColor4("_Horizon_Color_", this.horizonColor);
    this._activeEffect.setDirectColor4("_Ground_Color_", this.groundColor);
    this._activeEffect.setFloat("_Horizon_Power_", this.horizonPower);
    this._activeEffect.setTexture("_Reflection_Map_", this._reflectionMapTexture);
    this._activeEffect.setTexture("_Indirect_Environment_", this._indirectEnvTexture);
    this._activeEffect.setFloat("_Width_", this.width);
    this._activeEffect.setFloat("_Fuzz_", this.fuzz);
    this._activeEffect.setFloat("_Min_Fuzz_", this.minFuzz);
    this._activeEffect.setFloat("_Clip_Fade_", this.clipFade);
    this._activeEffect.setFloat("_Hue_Shift_", this.hueShift);
    this._activeEffect.setFloat("_Saturation_Shift_", this.saturationShift);
    this._activeEffect.setFloat("_Value_Shift_", this.valueShift);
    this._activeEffect.setVector3("_Blob_Position_", this.blobPosition);
    this._activeEffect.setFloat("_Blob_Intensity_", this.blobIntensity);
    this._activeEffect.setFloat("_Blob_Near_Size_", this.blobNearSize);
    this._activeEffect.setFloat("_Blob_Far_Size_", this.blobFarSize);
    this._activeEffect.setFloat("_Blob_Near_Distance_", this.blobNearDistance);
    this._activeEffect.setFloat("_Blob_Far_Distance_", this.blobFarDistance);
    this._activeEffect.setFloat("_Blob_Fade_Length_", this.blobFadeLength);
    this._activeEffect.setFloat("_Blob_Pulse_", this.blobPulse);
    this._activeEffect.setFloat("_Blob_Fade_", this.blobFade);
    this._activeEffect.setTexture("_Blob_Texture_", this.blobTexture);
    this._activeEffect.setVector3("_Blob_Position_2_", this.blobPosition2);
    this._activeEffect.setFloat("_Blob_Near_Size_2_", this.blobNearSize2);
    this._activeEffect.setFloat("_Blob_Pulse_2_", this.blobPulse2);
    this._activeEffect.setFloat("_Blob_Fade_2_", this.blobFade2);
    this._activeEffect.setVector3("_Left_Index_Pos_", this.leftIndexPosition);
    this._activeEffect.setVector3("_Right_Index_Pos_", this.rightIndexPosition);
    this._activeEffect.setVector3("_Left_Index_Middle_Pos_", this.leftIndexMiddlePosition);
    this._activeEffect.setVector3("_Right_Index_Middle_Pos_", this.rightIndexMiddlePosition);
    this._activeEffect.setTexture("_Decal_", this._decalTexture);
    this._activeEffect.setVector2("_Decal_Scale_XY_", this.decalScaleXY);
    this._activeEffect.setFloat("_Decal_Front_Only_", this.decalFrontOnly ? 1 : 0);
    this._activeEffect.setFloat("_Rim_Intensity_", this.rimIntensity);
    this._activeEffect.setTexture("_Rim_Texture_", this._blueGradientTexture);
    this._activeEffect.setFloat("_Rim_Hue_Shift_", this.rimHueShift);
    this._activeEffect.setFloat("_Rim_Saturation_Shift_", this.rimSaturationShift);
    this._activeEffect.setFloat("_Rim_Value_Shift_", this.rimValueShift);
    this._activeEffect.setFloat("_Iridescence_Intensity_", this.iridescenceIntensity);
    this._activeEffect.setTexture("_Iridescence_Texture_", this._blueGradientTexture);
    this._activeEffect.setFloat("Use_Global_Left_Index", this.useGlobalLeftIndex);
    this._activeEffect.setFloat("Use_Global_Right_Index", this.useGlobalRightIndex);
    this._activeEffect.setVector4("Global_Left_Index_Tip_Position", this.globalLeftIndexTipPosition);
    this._activeEffect.setVector4("Global_Right_Index_Tip_Position", this.globaRightIndexTipPosition);
    this._activeEffect.setVector4("Global_Left_Thumb_Tip_Position", this.globalLeftThumbTipPosition);
    this._activeEffect.setVector4("Global_Right_Thumb_Tip_Position", this.globalRightThumbTipPosition);
    this._activeEffect.setVector4("Global_Left_Index_Middle_Position", this.globalLeftIndexMiddlePosition);
    this._activeEffect.setVector4("Global_Right_Index_Middle_Position", this.globalRightIndexMiddlePosition);
    this._activeEffect.setFloat("Global_Left_Index_Tip_Proximity", this.globalLeftIndexTipProximity);
    this._activeEffect.setFloat("Global_Right_Index_Tip_Proximity", this.globalRightIndexTipProximity);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  /**
   * Get the list of animatables in the material.
   * @returns the list of animatables object used in the material
   */
  getAnimatables() {
    return [];
  }
  dispose(forceDisposeEffect) {
    super.dispose(forceDisposeEffect);
    this._reflectionMapTexture.dispose();
    this._indirectEnvTexture.dispose();
    this._blueGradientTexture.dispose();
    this._decalTexture.dispose();
  }
  clone(name22) {
    return SerializationHelper.Clone(() => new _MRDLSliderBarMaterial(name22, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.MRDLSliderBarMaterial";
    return serializationObject;
  }
  getClassName() {
    return "MRDLSliderBarMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _MRDLSliderBarMaterial(source.name, scene), source, scene, rootUrl);
  }
};
MRDLSliderBarMaterial.BLUE_GRADIENT_TEXTURE_URL = "https://assets.babylonjs.com/core/MRTK/MRDL/mrtk-mrdl-blue-gradient.png";
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "radius", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "bevelFront", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "bevelFrontStretch", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "bevelBack", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "bevelBackStretch", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "radiusTopLeft", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "radiusTopRight", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "radiusBottomLeft", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "radiusBottomRight", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "bulgeEnabled", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "bulgeHeight", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "bulgeRadius", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "sunIntensity", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "sunTheta", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "sunPhi", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "indirectDiffuse", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "albedo", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "specular", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "shininess", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "sharpness", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "subsurface", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "leftGradientColor", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "rightGradientColor", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "reflection", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "frontReflect", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "edgeReflect", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "power", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "skyColor", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "horizonColor", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "groundColor", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "horizonPower", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "width", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "fuzz", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "minFuzz", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "clipFade", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "hueShift", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "saturationShift", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "valueShift", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobPosition", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobIntensity", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobNearSize", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobFarSize", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobNearDistance", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobFarDistance", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobFadeLength", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobPulse", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobFade", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobPosition2", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobNearSize2", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobPulse2", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobFade2", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "blobTexture", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "leftIndexPosition", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "rightIndexPosition", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "leftIndexMiddlePosition", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "rightIndexMiddlePosition", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "decalScaleXY", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "decalFrontOnly", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "rimIntensity", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "rimHueShift", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "rimSaturationShift", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "rimValueShift", void 0);
__decorate([
  serialize()
], MRDLSliderBarMaterial.prototype, "iridescenceIntensity", void 0);
RegisterClass("BABYLON.GUI.MRDLSliderBarMaterial", MRDLSliderBarMaterial);

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlSliderThumb.fragment.js
var name12 = "mrdlSliderThumbPixelShader";
var shader11 = `uniform vec3 cameraPosition;varying vec3 vPosition;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec3 vBinormal;varying vec4 vColor;varying vec4 vExtra1;varying vec4 vExtra2;varying vec4 vExtra3;uniform float _Radius_;uniform float _Bevel_Front_;uniform float _Bevel_Front_Stretch_;uniform float _Bevel_Back_;uniform float _Bevel_Back_Stretch_;uniform float _Radius_Top_Left_;uniform float _Radius_Top_Right_;uniform float _Radius_Bottom_Left_;uniform float _Radius_Bottom_Right_;uniform bool _Bulge_Enabled_;uniform float _Bulge_Height_;uniform float _Bulge_Radius_;uniform float _Sun_Intensity_;uniform float _Sun_Theta_;uniform float _Sun_Phi_;uniform float _Indirect_Diffuse_;uniform vec4 _Albedo_;uniform float _Specular_;uniform float _Shininess_;uniform float _Sharpness_;uniform float _Subsurface_;uniform vec4 _Left_Color_;uniform vec4 _Right_Color_;uniform float _Reflection_;uniform float _Front_Reflect_;uniform float _Edge_Reflect_;uniform float _Power_;uniform vec4 _Sky_Color_;uniform vec4 _Horizon_Color_;uniform vec4 _Ground_Color_;uniform float _Horizon_Power_;uniform sampler2D _Reflection_Map_;uniform sampler2D _Indirect_Environment_;uniform float _Width_;uniform float _Fuzz_;uniform float _Min_Fuzz_;uniform float _Clip_Fade_;uniform float _Hue_Shift_;uniform float _Saturation_Shift_;uniform float _Value_Shift_;uniform vec3 _Blob_Position_;uniform float _Blob_Intensity_;uniform float _Blob_Near_Size_;uniform float _Blob_Far_Size_;uniform float _Blob_Near_Distance_;uniform float _Blob_Far_Distance_;uniform float _Blob_Fade_Length_;uniform float _Blob_Pulse_;uniform float _Blob_Fade_;uniform sampler2D _Blob_Texture_;uniform vec3 _Blob_Position_2_;uniform float _Blob_Near_Size_2_;uniform float _Blob_Pulse_2_;uniform float _Blob_Fade_2_;uniform vec3 _Left_Index_Pos_;uniform vec3 _Right_Index_Pos_;uniform vec3 _Left_Index_Middle_Pos_;uniform vec3 _Right_Index_Middle_Pos_;uniform sampler2D _Decal_;uniform vec2 _Decal_Scale_XY_;uniform bool _Decal_Front_Only_;uniform float _Rim_Intensity_;uniform sampler2D _Rim_Texture_;uniform float _Rim_Hue_Shift_;uniform float _Rim_Saturation_Shift_;uniform float _Rim_Value_Shift_;uniform float _Iridescence_Intensity_;uniform sampler2D _Iridescence_Texture_;uniform bool Use_Global_Left_Index;uniform bool Use_Global_Right_Index;uniform vec4 Global_Left_Index_Tip_Position;uniform vec4 Global_Right_Index_Tip_Position;uniform vec4 Global_Left_Thumb_Tip_Position;uniform vec4 Global_Right_Thumb_Tip_Position;uniform vec4 Global_Left_Index_Middle_Position;uniform vec4 Global_Right_Index_Middle_Position;uniform float Global_Left_Index_Tip_Proximity;uniform float Global_Right_Index_Tip_Proximity;void Blob_Fragment_B180(
sampler2D Blob_Texture,
vec4 Blob_Info1,
vec4 Blob_Info2,
out vec4 Blob_Color)
{float k1=dot(Blob_Info1.xy,Blob_Info1.xy);float k2=dot(Blob_Info2.xy,Blob_Info2.xy);vec3 closer=k1<k2 ? vec3(k1,Blob_Info1.z,Blob_Info1.w) : vec3(k2,Blob_Info2.z,Blob_Info2.w);Blob_Color=closer.z*texture(Blob_Texture,vec2(vec2(sqrt(closer.x),closer.y).x,1.0-vec2(sqrt(closer.x),closer.y).y))*clamp(1.0-closer.x,0.0,1.0);}
void FastLinearTosRGB_B192(
vec4 Linear,
out vec4 sRGB)
{sRGB.rgb=sqrt(clamp(Linear.rgb,0.0,1.0));sRGB.a=Linear.a;}
void Scale_RGB_B209(
vec4 Color,
float Scalar,
out vec4 Result)
{Result=vec4(Scalar,Scalar,Scalar,1)*Color;}
void Fragment_Main_B271(
float Sun_Intensity,
float Sun_Theta,
float Sun_Phi,
vec3 Normal,
vec4 Albedo,
float Fresnel_Reflect,
float Shininess,
vec3 Incident,
vec4 Horizon_Color,
vec4 Sky_Color,
vec4 Ground_Color,
float Indirect_Diffuse,
float Specular,
float Horizon_Power,
float Reflection,
vec4 Reflection_Sample,
vec4 Indirect_Sample,
float Sharpness,
float SSS,
float Subsurface,
vec4 Translucence,
vec4 Rim_Light,
vec4 Iridescence,
out vec4 Result)
{float theta=Sun_Theta*2.0*3.14159;float phi=Sun_Phi*3.14159;vec3 lightDir= vec3(cos(phi)*cos(theta),sin(phi),cos(phi)*sin(theta));float NdotL=max(dot(lightDir,Normal),0.0);vec3 R=reflect(Incident,Normal);float RdotL=max(0.0,dot(R,lightDir));float specular=pow(RdotL,Shininess);specular=mix(specular,smoothstep(0.495*Sharpness,1.0-0.495*Sharpness,specular),Sharpness);vec4 gi=mix(Ground_Color,Sky_Color,Normal.y*0.5+0.5);Result=((Sun_Intensity*NdotL+Indirect_Sample*Indirect_Diffuse+Translucence)*(1.0+SSS*Subsurface))*Albedo*(1.0-Fresnel_Reflect)+(Sun_Intensity*specular*Specular+Fresnel_Reflect*Reflection*Reflection_Sample)+Fresnel_Reflect*Rim_Light+Iridescence;}
void Bulge_B229(
bool Enabled,
vec3 Normal,
vec3 Tangent,
float Bulge_Height,
vec4 UV,
float Bulge_Radius,
vec3 ButtonN,
out vec3 New_Normal)
{vec2 xy=clamp(UV.xy*2.0,vec2(-1,-1),vec2(1,1));vec3 B=(cross(Normal,Tangent));float k=-clamp(1.0-length(xy)/Bulge_Radius,0.0,1.0)*Bulge_Height;k=sin(k*3.14159*0.5);k*=smoothstep(0.9998,0.9999,abs(dot(ButtonN,Normal)));New_Normal=Normal*sqrt(1.0-k*k)+(xy.x*Tangent+xy.y*B)*k;New_Normal=Enabled ? New_Normal : Normal;}
void SSS_B227(
vec3 ButtonN,
vec3 Normal,
vec3 Incident,
out float Result)
{float NdotI=abs(dot(Normal,Incident));float BdotI=abs(dot(ButtonN,Incident));Result=(abs(NdotI-BdotI)); }
void FingerOcclusion_B217(
float Width,
float DistToCenter,
float Fuzz,
float Min_Fuzz,
vec3 Position,
vec3 Forward,
vec3 Nearest,
float Fade_Out,
out float NotInShadow)
{float d=dot((Nearest-Position),Forward);float sh=smoothstep(Width*0.5,Width*0.5+Fuzz*max(d,0.0)+Min_Fuzz,DistToCenter);NotInShadow=1.0-(1.0-sh)*smoothstep(-Fade_Out,0.0,d);}
void FingerOcclusion_B218(
float Width,
float DistToCenter,
float Fuzz,
float Min_Fuzz,
vec3 Position,
vec3 Forward,
vec3 Nearest,
float Fade_Out,
out float NotInShadow)
{float d=dot((Nearest-Position),Forward);float sh=smoothstep(Width*0.5,Width*0.5+Fuzz*max(d,0.0)+Min_Fuzz,DistToCenter);NotInShadow=1.0-(1.0-sh)*smoothstep(-Fade_Out,0.0,d);}
void Scale_Color_B241(
vec4 Color,
float Scalar,
out vec4 Result)
{Result=Scalar*Color;}
void From_HSV_B223(
float Hue,
float Saturation,
float Value,
float Alpha,
out vec4 Color)
{vec4 K=vec4(1.0,2.0/3.0,1.0/3.0,3.0);vec3 p=abs(fract(vec3(Hue,Hue,Hue)+K.xyz)*6.0-K.www);Color.rgb=Value*mix(K.xxx,clamp(p-K.xxx,0.0,1.0),Saturation);Color.a=Alpha;}
void Fast_Fresnel_B272(
float Front_Reflect,
float Edge_Reflect,
float Power,
vec3 Normal,
vec3 Incident,
out float Transmit,
out float Reflect)
{float d=max(-dot(Incident,Normal),0.0);Reflect=Front_Reflect+(Edge_Reflect-Front_Reflect)*pow(1.0-d,Power);Transmit=1.0-Reflect;}
void Mapped_Environment_B201(
sampler2D Reflected_Environment,
sampler2D Indirect_Environment,
vec3 Dir,
out vec4 Reflected_Color,
out vec4 Indirect_Diffuse)
{Reflected_Color=texture(Reflected_Environment,vec2(atan(Dir.z,Dir.x)/3.14159*0.5,asin(Dir.y)/3.14159+0.5));Indirect_Diffuse=texture(Indirect_Environment,vec2(atan(Dir.z,Dir.x)/3.14159*0.5,asin(Dir.y)/3.14159+0.5));}
vec4 SampleEnv_Bid200(vec3 D,vec4 S,vec4 H,vec4 G,float exponent)
{float k=pow(abs(D.y),exponent);vec4 C;if (D.y>0.0) {C=mix(H,S,k);} else {C=mix(H,G,k); }
return C;}
void Sky_Environment_B200(
vec3 Normal,
vec3 Reflected,
vec4 Sky_Color,
vec4 Horizon_Color,
vec4 Ground_Color,
float Horizon_Power,
out vec4 Reflected_Color,
out vec4 Indirect_Color)
{Reflected_Color=SampleEnv_Bid200(Reflected,Sky_Color,Horizon_Color,Ground_Color,Horizon_Power);Indirect_Color=mix(Ground_Color,Sky_Color,Normal.y*0.5+0.5);}
void Min_Segment_Distance_B215(
vec3 P0,
vec3 P1,
vec3 Q0,
vec3 Q1,
out vec3 NearP,
out vec3 NearQ,
out float Distance)
{vec3 u=P1-P0;vec3 v=Q1-Q0;vec3 w=P0-Q0;float a=dot(u,u);float b=dot(u,v);float c=dot(v,v);float d=dot(u,w);float e=dot(v,w);float D=a*c-b*b;float sD=D;float tD=D;float sc,sN,tc,tN;if (D<0.00001) {sN=0.0;sD=1.0;tN=e;tD=c;} else {sN=(b*e-c*d);tN=(a*e-b*d);if (sN<0.0) {sN=0.0;tN=e;tD=c;} else if (sN>sD) {sN=sD;tN=e+b;tD=c;}}
if (tN<0.0) {tN=0.0;if (-d<0.0) {sN=0.0;} else if (-d>a) {sN=sD;} else {sN=-d;sD=a;}} else if (tN>tD) {tN=tD;if ((-d+b)<0.0) {sN=0.0;} else if ((-d+b)>a) {sN=sD;} else {sN=(-d+b);sD=a;}}
sc=abs(sN)<0.000001 ? 0.0 : sN/sD;tc=abs(tN)<0.000001 ? 0.0 : tN/tD;NearP=P0+sc*u;NearQ=Q0+tc*v;Distance=distance(NearP,NearQ);}
void To_XYZ_B224(
vec3 Vec3,
out float X,
out float Y,
out float Z)
{X=Vec3.x;Y=Vec3.y;Z=Vec3.z;}
void Finger_Positions_B214(
vec3 Left_Index_Pos,
vec3 Right_Index_Pos,
vec3 Left_Index_Middle_Pos,
vec3 Right_Index_Middle_Pos,
out vec3 Left_Index,
out vec3 Right_Index,
out vec3 Left_Index_Middle,
out vec3 Right_Index_Middle)
{Left_Index= (Use_Global_Left_Index ? Global_Left_Index_Tip_Position.xyz : Left_Index_Pos);Right_Index= (Use_Global_Right_Index ? Global_Right_Index_Tip_Position.xyz : Right_Index_Pos);Left_Index_Middle= (Use_Global_Left_Index ? Global_Left_Index_Middle_Position.xyz : Left_Index_Middle_Pos);Right_Index_Middle= (Use_Global_Right_Index ? Global_Right_Index_Middle_Position.xyz : Right_Index_Middle_Pos);}
void VaryHSV_B258(
vec3 HSV_In,
float Hue_Shift,
float Saturation_Shift,
float Value_Shift,
out vec3 HSV_Out)
{HSV_Out=vec3(fract(HSV_In.x+Hue_Shift),clamp(HSV_In.y+Saturation_Shift,0.0,1.0),clamp(HSV_In.z+Value_Shift,0.0,1.0));}
void Remap_Range_B264(
float In_Min,
float In_Max,
float Out_Min,
float Out_Max,
float In,
out float Out)
{Out=mix(Out_Min,Out_Max,clamp((In-In_Min)/(In_Max-In_Min),0.0,1.0));}
void To_HSV_B225(
vec4 Color,
out float Hue,
out float Saturation,
out float Value,
out float Alpha,
out vec3 HSV)
{vec4 K=vec4(0.0,-1.0/3.0,2.0/3.0,-1.0);vec4 p=Color.g<Color.b ? vec4(Color.bg,K.wz) : vec4(Color.gb,K.xy);vec4 q=Color.r<p.x ? vec4(p.xyw,Color.r) : vec4(Color.r,p.yzx);float d=q.x-min(q.w,q.y);float e=1.0e-10;Hue=abs(q.z+(q.w-q.y)/(6.0*d+e));Saturation=d/(q.x+e);Value=q.x;Alpha=Color.a;HSV=vec3(Hue,Saturation,Value);}
void Code_B260(
float X,
out float Result)
{Result=(acos(X)/3.14159-0.5)*2.0;}
void Rim_Light_B282(
vec3 Front,
vec3 Normal,
vec3 Incident,
float Rim_Intensity,
sampler2D Texture,
out vec4 Result)
{vec3 R=reflect(Incident,Normal);float RdotF=dot(R,Front);float RdotL=sqrt(1.0-RdotF*RdotF);vec2 UV=vec2(R.y*0.5+0.5,0.5);vec4 Color=texture(Texture,UV);Result=Color;}
void main()
{vec4 Blob_Color_Q180;
#if BLOB_ENABLE
Blob_Fragment_B180(_Blob_Texture_,vExtra2,vExtra3,Blob_Color_Q180);
#else
Blob_Color_Q180=vec4(0,0,0,0);
#endif
vec3 Incident_Q189=normalize(vPosition-cameraPosition);vec3 Normalized_Q188=normalize(vNormal);vec3 Normalized_Q221=normalize(vTangent);vec4 Color_Q233;
#if DECAL_ENABLE
Color_Q233=texture(_Decal_,vUV);
#else
Color_Q233=vec4(0,0,0,0);
#endif
float X_Q240;float Y_Q240;float Z_Q240;float W_Q240;X_Q240=vExtra1.x;Y_Q240=vExtra1.y;Z_Q240=vExtra1.z;W_Q240=vExtra1.w;vec4 Linear_Q193;Linear_Q193.rgb=clamp(_Sky_Color_.rgb*_Sky_Color_.rgb,0.0,1.0);Linear_Q193.a=_Sky_Color_.a;vec4 Linear_Q194;Linear_Q194.rgb=clamp(_Horizon_Color_.rgb*_Horizon_Color_.rgb,0.0,1.0);Linear_Q194.a=_Horizon_Color_.a;vec4 Linear_Q195;Linear_Q195.rgb=clamp(_Ground_Color_.rgb*_Ground_Color_.rgb,0.0,1.0);Linear_Q195.a=_Ground_Color_.a;vec3 Left_Index_Q214;vec3 Right_Index_Q214;vec3 Left_Index_Middle_Q214;vec3 Right_Index_Middle_Q214;Finger_Positions_B214(_Left_Index_Pos_,_Right_Index_Pos_,_Left_Index_Middle_Pos_,_Right_Index_Middle_Pos_,Left_Index_Q214,Right_Index_Q214,Left_Index_Middle_Q214,Right_Index_Middle_Q214);vec4 Linear_Q196;Linear_Q196.rgb=clamp(_Albedo_.rgb*_Albedo_.rgb,0.0,1.0);Linear_Q196.a=_Albedo_.a;vec3 Normalized_Q257=normalize(vBinormal);vec3 Incident_Q220=normalize(vPosition-cameraPosition);vec3 New_Normal_Q229;Bulge_B229(_Bulge_Enabled_,Normalized_Q188,Normalized_Q221,_Bulge_Height_,vColor,_Bulge_Radius_,vBinormal,New_Normal_Q229);float Result_Q227;SSS_B227(vBinormal,New_Normal_Q229,Incident_Q189,Result_Q227);vec4 Result_Q241;Scale_Color_B241(Color_Q233,X_Q240,Result_Q241);float Transmit_Q272;float Reflect_Q272;Fast_Fresnel_B272(_Front_Reflect_,_Edge_Reflect_,_Power_,New_Normal_Q229,Incident_Q189,Transmit_Q272,Reflect_Q272);float Product_Q275=Y_Q240*Y_Q240;vec3 NearP_Q215;vec3 NearQ_Q215;float Distance_Q215;Min_Segment_Distance_B215(Left_Index_Q214,Left_Index_Middle_Q214,vPosition,cameraPosition,NearP_Q215,NearQ_Q215,Distance_Q215);vec3 NearP_Q213;vec3 NearQ_Q213;float Distance_Q213;Min_Segment_Distance_B215(Right_Index_Q214,Right_Index_Middle_Q214,vPosition,cameraPosition,NearP_Q213,NearQ_Q213,Distance_Q213);vec3 Reflected_Q197=reflect(Incident_Q189,New_Normal_Q229);vec4 Product_Q253=Linear_Q196*vec4(1,1,1,1);vec4 Result_Q282;Rim_Light_B282(Normalized_Q257,Normalized_Q188,Incident_Q220,_Rim_Intensity_,_Rim_Texture_,Result_Q282);float Dot_Q222=dot(Incident_Q220, Normalized_Q221);float MaxAB_Q273=max(Reflect_Q272,Product_Q275);float NotInShadow_Q217;
#if OCCLUSION_ENABLED
FingerOcclusion_B217(_Width_,Distance_Q215,_Fuzz_,_Min_Fuzz_,vPosition,vBinormal,NearP_Q215,_Clip_Fade_,NotInShadow_Q217);
#else
NotInShadow_Q217=1.0;
#endif
float NotInShadow_Q218;
#if OCCLUSION_ENABLED
FingerOcclusion_B218(_Width_,Distance_Q213,_Fuzz_,_Min_Fuzz_,vPosition,vBinormal,NearP_Q213,_Clip_Fade_,NotInShadow_Q218);
#else
NotInShadow_Q218=1.0;
#endif
vec4 Reflected_Color_Q201;vec4 Indirect_Diffuse_Q201;
#if ENV_ENABLE
Mapped_Environment_B201(_Reflection_Map_,_Indirect_Environment_,Reflected_Q197,Reflected_Color_Q201,Indirect_Diffuse_Q201);
#else
Reflected_Color_Q201=vec4(0,0,0,1);Indirect_Diffuse_Q201=vec4(0,0,0,1);
#endif
vec4 Reflected_Color_Q200;vec4 Indirect_Color_Q200;
#if SKY_ENABLED
Sky_Environment_B200(New_Normal_Q229,Reflected_Q197,Linear_Q193,Linear_Q194,Linear_Q195,_Horizon_Power_,Reflected_Color_Q200,Indirect_Color_Q200);
#else
Reflected_Color_Q200=vec4(0,0,0,1);Indirect_Color_Q200=vec4(0,0,0,1);
#endif
float Hue_Q225;float Saturation_Q225;float Value_Q225;float Alpha_Q225;vec3 HSV_Q225;To_HSV_B225(Product_Q253,Hue_Q225,Saturation_Q225,Value_Q225,Alpha_Q225,HSV_Q225);float Hue_Q277;float Saturation_Q277;float Value_Q277;float Alpha_Q277;vec3 HSV_Q277;To_HSV_B225(Result_Q282,Hue_Q277,Saturation_Q277,Value_Q277,Alpha_Q277,HSV_Q277);float Result_Q260;Code_B260(Dot_Q222,Result_Q260);float AbsA_Q226=abs(Result_Q260);float MinAB_Q208=min(NotInShadow_Q217,NotInShadow_Q218);vec4 Sum_Q198=Reflected_Color_Q201+Reflected_Color_Q200;vec4 Sum_Q199=Indirect_Diffuse_Q201+Indirect_Color_Q200;vec3 HSV_Out_Q276;VaryHSV_B258(HSV_Q277,_Rim_Hue_Shift_,_Rim_Saturation_Shift_,_Rim_Value_Shift_,HSV_Out_Q276);float Out_Q264;Remap_Range_B264(-1.0,1.0,0.0,1.0,Result_Q260,Out_Q264);float Product_Q256;Product_Q256=AbsA_Q226*_Hue_Shift_;float X_Q278;float Y_Q278;float Z_Q278;To_XYZ_B224(HSV_Out_Q276,X_Q278,Y_Q278,Z_Q278);vec2 Vec2_Q262=vec2(Out_Q264,0.5);vec3 HSV_Out_Q258;VaryHSV_B258(HSV_Q225,Product_Q256,_Saturation_Shift_,_Value_Shift_,HSV_Out_Q258);vec4 Color_Q279;From_HSV_B223(X_Q278,Y_Q278,Z_Q278,0.0,Color_Q279);vec4 Color_Q261;
#if IRIDESCENCE_ENABLED
Color_Q261=texture(_Iridescence_Texture_,Vec2_Q262);
#else
Color_Q261=vec4(0,0,0,0);
#endif
float X_Q224;float Y_Q224;float Z_Q224;To_XYZ_B224(HSV_Out_Q258,X_Q224,Y_Q224,Z_Q224);vec4 Result_Q281=_Rim_Intensity_*Color_Q279;vec4 Result_Q263=_Iridescence_Intensity_*Color_Q261;vec4 Color_Q223;From_HSV_B223(X_Q224,Y_Q224,Z_Q224,0.0,Color_Q223);vec4 Result_Q234=Result_Q241+(1.0-Result_Q241.a)*Color_Q223;vec4 Result_Q271;Fragment_Main_B271(_Sun_Intensity_,_Sun_Theta_,_Sun_Phi_,New_Normal_Q229,Result_Q234,MaxAB_Q273,_Shininess_,Incident_Q189,_Horizon_Color_,_Sky_Color_,_Ground_Color_,_Indirect_Diffuse_,_Specular_,_Horizon_Power_,_Reflection_,Sum_Q198,Sum_Q199,_Sharpness_,Result_Q227,_Subsurface_,vec4(0,0,0,0),Result_Q281,Result_Q263,Result_Q271);vec4 Result_Q209;Scale_RGB_B209(Result_Q271,MinAB_Q208,Result_Q209);vec4 sRGB_Q192;FastLinearTosRGB_B192(Result_Q209,sRGB_Q192);vec4 Result_Q181=Blob_Color_Q180+(1.0-Blob_Color_Q180.a)*sRGB_Q192;vec4 Result_Q190=Result_Q181; Result_Q190.a=1.0;vec4 Out_Color=Result_Q190;float Clip_Threshold=0.001;bool To_sRGB=false;gl_FragColor=Out_Color;}`;
if (!ShaderStore.ShadersStore[name12]) {
  ShaderStore.ShadersStore[name12] = shader11;
}

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlSliderThumb.vertex.js
var name13 = "mrdlSliderThumbVertexShader";
var shader12 = `uniform mat4 world;uniform mat4 viewProjection;uniform vec3 cameraPosition;attribute vec3 position;attribute vec3 normal;attribute vec2 uv;
#ifdef TANGENT
attribute vec3 tangent;
#else
const vec3 tangent=vec3(0.);
#endif
uniform float _Radius_;uniform float _Bevel_Front_;uniform float _Bevel_Front_Stretch_;uniform float _Bevel_Back_;uniform float _Bevel_Back_Stretch_;uniform float _Radius_Top_Left_;uniform float _Radius_Top_Right_;uniform float _Radius_Bottom_Left_;uniform float _Radius_Bottom_Right_;uniform bool _Bulge_Enabled_;uniform float _Bulge_Height_;uniform float _Bulge_Radius_;uniform float _Sun_Intensity_;uniform float _Sun_Theta_;uniform float _Sun_Phi_;uniform float _Indirect_Diffuse_;uniform vec4 _Albedo_;uniform float _Specular_;uniform float _Shininess_;uniform float _Sharpness_;uniform float _Subsurface_;uniform vec4 _Left_Color_;uniform vec4 _Right_Color_;uniform float _Reflection_;uniform float _Front_Reflect_;uniform float _Edge_Reflect_;uniform float _Power_;uniform vec4 _Sky_Color_;uniform vec4 _Horizon_Color_;uniform vec4 _Ground_Color_;uniform float _Horizon_Power_;uniform sampler2D _Reflection_Map_;uniform sampler2D _Indirect_Environment_;uniform float _Width_;uniform float _Fuzz_;uniform float _Min_Fuzz_;uniform float _Clip_Fade_;uniform float _Hue_Shift_;uniform float _Saturation_Shift_;uniform float _Value_Shift_;uniform vec3 _Blob_Position_;uniform float _Blob_Intensity_;uniform float _Blob_Near_Size_;uniform float _Blob_Far_Size_;uniform float _Blob_Near_Distance_;uniform float _Blob_Far_Distance_;uniform float _Blob_Fade_Length_;uniform float _Blob_Pulse_;uniform float _Blob_Fade_;uniform sampler2D _Blob_Texture_;uniform vec3 _Blob_Position_2_;uniform float _Blob_Near_Size_2_;uniform float _Blob_Pulse_2_;uniform float _Blob_Fade_2_;uniform vec3 _Left_Index_Pos_;uniform vec3 _Right_Index_Pos_;uniform vec3 _Left_Index_Middle_Pos_;uniform vec3 _Right_Index_Middle_Pos_;uniform sampler2D _Decal_;uniform vec2 _Decal_Scale_XY_;uniform bool _Decal_Front_Only_;uniform float _Rim_Intensity_;uniform sampler2D _Rim_Texture_;uniform float _Rim_Hue_Shift_;uniform float _Rim_Saturation_Shift_;uniform float _Rim_Value_Shift_;uniform float _Iridescence_Intensity_;uniform sampler2D _Iridescence_Texture_;uniform bool Use_Global_Left_Index;uniform bool Use_Global_Right_Index;uniform vec4 Global_Left_Index_Tip_Position;uniform vec4 Global_Right_Index_Tip_Position;uniform vec4 Global_Left_Thumb_Tip_Position;uniform vec4 Global_Right_Thumb_Tip_Position;uniform float Global_Left_Index_Tip_Proximity;uniform float Global_Right_Index_Tip_Proximity;varying vec3 vPosition;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec3 vBinormal;varying vec4 vColor;varying vec4 vExtra1;varying vec4 vExtra2;varying vec4 vExtra3;void Object_To_World_Pos_B162(
vec3 Pos_Object,
out vec3 Pos_World)
{Pos_World=(world*vec4(Pos_Object,1.0)).xyz;}
void Object_To_World_Normal_B182(
vec3 Nrm_Object,
out vec3 Nrm_World)
{Nrm_World=(vec4(Nrm_Object,0.0)).xyz;}
void Blob_Vertex_B173(
vec3 Position,
vec3 Normal,
vec3 Tangent,
vec3 Bitangent,
vec3 Blob_Position,
float Intensity,
float Blob_Near_Size,
float Blob_Far_Size,
float Blob_Near_Distance,
float Blob_Far_Distance,
float Blob_Fade_Length,
float Blob_Pulse,
float Blob_Fade,
out vec4 Blob_Info)
{vec3 blob= (Use_Global_Left_Index ? Global_Left_Index_Tip_Position.xyz : Blob_Position);vec3 delta=blob-Position;float dist=dot(Normal,delta);float lerpValue=clamp((abs(dist)-Blob_Near_Distance)/(Blob_Far_Distance-Blob_Near_Distance),0.0,1.0);float fadeValue=1.0-clamp((abs(dist)-Blob_Far_Distance)/Blob_Fade_Length,0.0,1.0);float size=Blob_Near_Size+(Blob_Far_Size-Blob_Near_Size)*lerpValue;vec2 blobXY=vec2(dot(delta,Tangent),dot(delta,Bitangent))/(0.0001+size);float Fade=fadeValue*Intensity*Blob_Fade;float Distance=(lerpValue*0.5+0.5)*(1.0-Blob_Pulse);Blob_Info=vec4(blobXY.x,blobXY.y,Distance,Fade);}
void Blob_Vertex_B174(
vec3 Position,
vec3 Normal,
vec3 Tangent,
vec3 Bitangent,
vec3 Blob_Position,
float Intensity,
float Blob_Near_Size,
float Blob_Far_Size,
float Blob_Near_Distance,
float Blob_Far_Distance,
float Blob_Fade_Length,
float Blob_Pulse,
float Blob_Fade,
out vec4 Blob_Info)
{vec3 blob= (Use_Global_Right_Index ? Global_Right_Index_Tip_Position.xyz : Blob_Position);vec3 delta=blob-Position;float dist=dot(Normal,delta);float lerpValue=clamp((abs(dist)-Blob_Near_Distance)/(Blob_Far_Distance-Blob_Near_Distance),0.0,1.0);float fadeValue=1.0-clamp((abs(dist)-Blob_Far_Distance)/Blob_Fade_Length,0.0,1.0);float size=Blob_Near_Size+(Blob_Far_Size-Blob_Near_Size)*lerpValue;vec2 blobXY=vec2(dot(delta,Tangent),dot(delta,Bitangent))/(0.0001+size);float Fade=fadeValue*Intensity*Blob_Fade;float Distance=(lerpValue*0.5+0.5)*(1.0-Blob_Pulse);Blob_Info=vec4(blobXY.x,blobXY.y,Distance,Fade);}
void Move_Verts_B280(
float Anisotropy,
vec3 P,
float Radius,
float Bevel,
vec3 Normal_Object,
float ScaleZ,
float Stretch,
out vec3 New_P,
out vec2 New_UV,
out float Radial_Gradient,
out vec3 Radial_Dir,
out vec3 New_Normal)
{vec2 UV=P.xy*2.0+0.5;vec2 center=clamp(UV,0.0,1.0);vec2 delta=UV-center;float deltad=(length(delta)*2.0);float f=(Bevel+(Radius-Bevel)*Stretch)/Radius;float innerd=clamp(deltad*2.0,0.0,1.0);float outerd=clamp(deltad*2.0-1.0,0.0,1.0);float bevelAngle=outerd*3.14159*0.5;float sinb=sin(bevelAngle);float cosb=cos(bevelAngle);float beveld=(1.0-f)*innerd+f*sinb;float br=outerd;vec2 r2=2.0*vec2(Radius/Anisotropy,Radius);float dir=P.z<0.0001 ? 1.0 : -1.0;New_UV=center+r2*((0.5-center)+normalize(delta+vec2(0.0,0.000001))*beveld*0.5);New_P=vec3(New_UV-0.5,P.z+dir*(1.0-cosb)*Bevel*ScaleZ);Radial_Gradient=clamp((deltad-0.5)*2.0,0.0,1.0);Radial_Dir=vec3(delta*r2,0.0);vec3 beveledNormal=cosb*Normal_Object+sinb*vec3(delta.x,delta.y,0.0);New_Normal=Normal_Object.z==0.0 ? Normal_Object : beveledNormal;}
void Object_To_World_Dir_B210(
vec3 Dir_Object,
out vec3 Normal_World,
out vec3 Normal_World_N,
out float Normal_Length)
{Normal_World=(world*vec4(Dir_Object,0.0)).xyz;Normal_Length=length(Normal_World);Normal_World_N=Normal_World/Normal_Length;}
void To_XYZ_B228(
vec3 Vec3,
out float X,
out float Y,
out float Z)
{X=Vec3.x;Y=Vec3.y;Z=Vec3.z;}
void Conditional_Float_B243(
bool Which,
float If_True,
float If_False,
out float Result)
{Result=Which ? If_True : If_False;}
void Object_To_World_Dir_B178(
vec3 Dir_Object,
out vec3 Binormal_World,
out vec3 Binormal_World_N,
out float Binormal_Length)
{Binormal_World=(world*vec4(Dir_Object,0.0)).xyz;Binormal_Length=length(Binormal_World);Binormal_World_N=Binormal_World/Binormal_Length;}
void Pick_Radius_B219(
float Radius,
float Radius_Top_Left,
float Radius_Top_Right,
float Radius_Bottom_Left,
float Radius_Bottom_Right,
vec3 Position,
out float Result)
{bool whichY=Position.y>0.0;Result=Position.x<0.0 ? (whichY ? Radius_Top_Left : Radius_Bottom_Left) : (whichY ? Radius_Top_Right : Radius_Bottom_Right);Result*=Radius;}
void Conditional_Float_B186(
bool Which,
float If_True,
float If_False,
out float Result)
{Result=Which ? If_True : If_False;}
void Greater_Than_B187(
float Left,
float Right,
out bool Not_Greater_Than,
out bool Greater_Than)
{Greater_Than=Left>Right;Not_Greater_Than=!Greater_Than;}
void Remap_Range_B255(
float In_Min,
float In_Max,
float Out_Min,
float Out_Max,
float In,
out float Out)
{Out=mix(Out_Min,Out_Max,clamp((In-In_Min)/(In_Max-In_Min),0.0,1.0));}
void main()
{vec2 XY_Q235;XY_Q235=(uv-vec2(0.5,0.5))*_Decal_Scale_XY_+vec2(0.5,0.5);vec3 Tangent_World_Q177;vec3 Tangent_World_N_Q177;float Tangent_Length_Q177;Tangent_World_Q177=(world*vec4(vec3(1,0,0),0.0)).xyz;Tangent_Length_Q177=length(Tangent_World_Q177);Tangent_World_N_Q177=Tangent_World_Q177/Tangent_Length_Q177;vec3 Normal_World_Q210;vec3 Normal_World_N_Q210;float Normal_Length_Q210;Object_To_World_Dir_B210(vec3(0,0,1),Normal_World_Q210,Normal_World_N_Q210,Normal_Length_Q210);float X_Q228;float Y_Q228;float Z_Q228;To_XYZ_B228(position,X_Q228,Y_Q228,Z_Q228);vec3 Nrm_World_Q176;Nrm_World_Q176=normalize((world*vec4(normal,0.0)).xyz);vec3 Binormal_World_Q178;vec3 Binormal_World_N_Q178;float Binormal_Length_Q178;Object_To_World_Dir_B178(vec3(0,1,0),Binormal_World_Q178,Binormal_World_N_Q178,Binormal_Length_Q178);float Anisotropy_Q179=Tangent_Length_Q177/Binormal_Length_Q178;float Result_Q219;Pick_Radius_B219(_Radius_,_Radius_Top_Left_,_Radius_Top_Right_,_Radius_Bottom_Left_,_Radius_Bottom_Right_,position,Result_Q219);float Anisotropy_Q203=Binormal_Length_Q178/Normal_Length_Q210;bool Not_Greater_Than_Q187;bool Greater_Than_Q187;Greater_Than_B187(Z_Q228,0.0,Not_Greater_Than_Q187,Greater_Than_Q187);vec4 Linear_Q251;Linear_Q251.rgb=clamp(_Left_Color_.rgb*_Left_Color_.rgb,0.0,1.0);Linear_Q251.a=_Left_Color_.a;vec4 Linear_Q252;Linear_Q252.rgb=clamp(_Right_Color_.rgb*_Right_Color_.rgb,0.0,1.0);Linear_Q252.a=_Right_Color_.a;vec3 Difference_Q211=vec3(0,0,0)-Normal_World_N_Q210;vec4 Out_Color_Q184=vec4(X_Q228,Y_Q228,Z_Q228,1);float Result_Q186;Conditional_Float_B186(Greater_Than_Q187,_Bevel_Back_,_Bevel_Front_,Result_Q186);float Result_Q244;Conditional_Float_B186(Greater_Than_Q187,_Bevel_Back_Stretch_,_Bevel_Front_Stretch_,Result_Q244);vec3 New_P_Q280;vec2 New_UV_Q280;float Radial_Gradient_Q280;vec3 Radial_Dir_Q280;vec3 New_Normal_Q280;Move_Verts_B280(Anisotropy_Q179,position,Result_Q219,Result_Q186,normal,Anisotropy_Q203,Result_Q244,New_P_Q280,New_UV_Q280,Radial_Gradient_Q280,Radial_Dir_Q280,New_Normal_Q280);float X_Q248;float Y_Q248;X_Q248=New_UV_Q280.x;Y_Q248=New_UV_Q280.y;vec3 Pos_World_Q162;Object_To_World_Pos_B162(New_P_Q280,Pos_World_Q162);vec3 Nrm_World_Q182;Object_To_World_Normal_B182(New_Normal_Q280,Nrm_World_Q182);vec4 Blob_Info_Q173;
#if BLOB_ENABLE
Blob_Vertex_B173(Pos_World_Q162,Nrm_World_Q176,Tangent_World_N_Q177,Binormal_World_N_Q178,_Blob_Position_,_Blob_Intensity_,_Blob_Near_Size_,_Blob_Far_Size_,_Blob_Near_Distance_,_Blob_Far_Distance_,_Blob_Fade_Length_,_Blob_Pulse_,_Blob_Fade_,Blob_Info_Q173);
#else
Blob_Info_Q173=vec4(0,0,0,0);
#endif
vec4 Blob_Info_Q174;
#if BLOB_ENABLE_2
Blob_Vertex_B174(Pos_World_Q162,Nrm_World_Q176,Tangent_World_N_Q177,Binormal_World_N_Q178,_Blob_Position_2_,_Blob_Intensity_,_Blob_Near_Size_2_,_Blob_Far_Size_,_Blob_Near_Distance_,_Blob_Far_Distance_,_Blob_Fade_Length_,_Blob_Pulse_2_,_Blob_Fade_2_,Blob_Info_Q174);
#else
Blob_Info_Q174=vec4(0,0,0,0);
#endif
float Out_Q255;Remap_Range_B255(0.0,1.0,0.0,1.0,X_Q248,Out_Q255);float X_Q236;float Y_Q236;float Z_Q236;To_XYZ_B228(Nrm_World_Q182,X_Q236,Y_Q236,Z_Q236);vec4 Color_At_T_Q247=mix(Linear_Q251,Linear_Q252,Out_Q255);float Minus_F_Q237=-Z_Q236;float R_Q249;float G_Q249;float B_Q249;float A_Q249;R_Q249=Color_At_T_Q247.r; G_Q249=Color_At_T_Q247.g; B_Q249=Color_At_T_Q247.b; A_Q249=Color_At_T_Q247.a;float ClampF_Q238=clamp(0.0,Minus_F_Q237,1.0);float Result_Q243;Conditional_Float_B243(_Decal_Front_Only_,ClampF_Q238,1.0,Result_Q243);vec4 Vec4_Q239=vec4(Result_Q243,Radial_Gradient_Q280,G_Q249,B_Q249);vec3 Position=Pos_World_Q162;vec3 Normal=Nrm_World_Q182;vec2 UV=XY_Q235;vec3 Tangent=Tangent_World_N_Q177;vec3 Binormal=Difference_Q211;vec4 Color=Out_Color_Q184;vec4 Extra1=Vec4_Q239;vec4 Extra2=Blob_Info_Q173;vec4 Extra3=Blob_Info_Q174;gl_Position=viewProjection*vec4(Position,1);vPosition=Position;vNormal=Normal;vUV=UV;vTangent=Tangent;vBinormal=Binormal;vColor=Color;vExtra1=Extra1;vExtra2=Extra2;vExtra3=Extra3;}`;
if (!ShaderStore.ShadersStore[name13]) {
  ShaderStore.ShadersStore[name13] = shader12;
}

// node_modules/@babylonjs/gui/3D/materials/mrdl/mrdlSliderThumbMaterial.js
var MRDLSliderThumbMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.SKY_ENABLED = true;
    this.BLOB_ENABLE_2 = true;
    this.IRIDESCENCE_ENABLED = true;
    this._needNormals = true;
    this._needUVs = true;
    this.rebuild();
  }
};
var MRDLSliderThumbMaterial = class _MRDLSliderThumbMaterial extends PushMaterial {
  constructor(name22, scene) {
    super(name22, scene);
    this.radius = 0.157;
    this.bevelFront = 0.065;
    this.bevelFrontStretch = 0.077;
    this.bevelBack = 0.031;
    this.bevelBackStretch = 0;
    this.radiusTopLeft = 1;
    this.radiusTopRight = 1;
    this.radiusBottomLeft = 1;
    this.radiusBottomRight = 1;
    this.bulgeEnabled = false;
    this.bulgeHeight = -0.323;
    this.bulgeRadius = 0.73;
    this.sunIntensity = 2;
    this.sunTheta = 0.937;
    this.sunPhi = 0.555;
    this.indirectDiffuse = 1;
    this.albedo = new Color4(0.0117647, 0.505882, 0.996078, 1);
    this.specular = 0;
    this.shininess = 10;
    this.sharpness = 0;
    this.subsurface = 0.31;
    this.leftGradientColor = new Color4(0.0117647, 0.505882, 0.996078, 1);
    this.rightGradientColor = new Color4(0.0117647, 0.505882, 0.996078, 1);
    this.reflection = 0.749;
    this.frontReflect = 0;
    this.edgeReflect = 0.09;
    this.power = 8.1;
    this.skyColor = new Color4(0.0117647, 0.960784, 0.996078, 1);
    this.horizonColor = new Color4(0.0117647, 0.333333, 0.996078, 1);
    this.groundColor = new Color4(0, 0.254902, 0.996078, 1);
    this.horizonPower = 1;
    this.width = 0.02;
    this.fuzz = 0.5;
    this.minFuzz = 1e-3;
    this.clipFade = 0.01;
    this.hueShift = 0;
    this.saturationShift = 0;
    this.valueShift = 0;
    this.blobPosition = new Vector3(0, 0, 0.1);
    this.blobIntensity = 0.5;
    this.blobNearSize = 0.01;
    this.blobFarSize = 0.03;
    this.blobNearDistance = 0;
    this.blobFarDistance = 0.08;
    this.blobFadeLength = 0.576;
    this.blobPulse = 0;
    this.blobFade = 1;
    this.blobPosition2 = new Vector3(0.2, 0, 0.1);
    this.blobNearSize2 = 0.01;
    this.blobPulse2 = 0;
    this.blobFade2 = 1;
    this.blobTexture = new Texture("", this.getScene());
    this.leftIndexPosition = new Vector3(0, 0, 1);
    this.rightIndexPosition = new Vector3(-1, -1, -1);
    this.leftIndexMiddlePosition = new Vector3(0, 0, 0);
    this.rightIndexMiddlePosition = new Vector3(0, 0, 0);
    this.decalScaleXY = new Vector2(1.5, 1.5);
    this.decalFrontOnly = true;
    this.rimIntensity = 0.287;
    this.rimHueShift = 0;
    this.rimSaturationShift = 0;
    this.rimValueShift = -1;
    this.iridescenceIntensity = 0;
    this.useGlobalLeftIndex = 1;
    this.useGlobalRightIndex = 1;
    this.globalLeftIndexTipProximity = 0;
    this.globalRightIndexTipProximity = 0;
    this.globalLeftIndexTipPosition = new Vector4(0.5, 0, -0.55, 1);
    this.globaRightIndexTipPosition = new Vector4(0, 0, 0, 1);
    this.globalLeftThumbTipPosition = new Vector4(0.5, 0, -0.55, 1);
    this.globalRightThumbTipPosition = new Vector4(0, 0, 0, 1);
    this.globalLeftIndexMiddlePosition = new Vector4(0.5, 0, -0.55, 1);
    this.globalRightIndexMiddlePosition = new Vector4(0, 0, 0, 1);
    this.alphaMode = Constants.ALPHA_DISABLE;
    this.backFaceCulling = false;
    const textureUrl = Tools.GetAssetUrl(_MRDLSliderThumbMaterial.BLUE_GRADIENT_TEXTURE_URL);
    this._blueGradientTexture = new Texture(textureUrl, scene, true, false, Texture.NEAREST_SAMPLINGMODE);
    this._decalTexture = new Texture("", this.getScene());
    this._reflectionMapTexture = new Texture("", this.getScene());
    this._indirectEnvTexture = new Texture("", this.getScene());
  }
  needAlphaBlending() {
    return false;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new MRDLSliderThumbMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    PrepareDefinesForAttributes(mesh, defines, false, false);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks);
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      if (defines.TANGENT) {
        attribs.push(VertexBuffer.TangentKind);
      }
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "mrdlSliderThumb";
      const join = defines.toString();
      const uniforms = [
        "world",
        "viewProjection",
        "cameraPosition",
        "_Radius_",
        "_Bevel_Front_",
        "_Bevel_Front_Stretch_",
        "_Bevel_Back_",
        "_Bevel_Back_Stretch_",
        "_Radius_Top_Left_",
        "_Radius_Top_Right_",
        "_Radius_Bottom_Left_",
        "_Radius_Bottom_Right_",
        "_Bulge_Enabled_",
        "_Bulge_Height_",
        "_Bulge_Radius_",
        "_Sun_Intensity_",
        "_Sun_Theta_",
        "_Sun_Phi_",
        "_Indirect_Diffuse_",
        "_Albedo_",
        "_Specular_",
        "_Shininess_",
        "_Sharpness_",
        "_Subsurface_",
        "_Left_Color_",
        "_Right_Color_",
        "_Reflection_",
        "_Front_Reflect_",
        "_Edge_Reflect_",
        "_Power_",
        "_Sky_Color_",
        "_Horizon_Color_",
        "_Ground_Color_",
        "_Horizon_Power_",
        "_Reflection_Map_",
        "_Indirect_Environment_",
        "_Width_",
        "_Fuzz_",
        "_Min_Fuzz_",
        "_Clip_Fade_",
        "_Hue_Shift_",
        "_Saturation_Shift_",
        "_Value_Shift_",
        "_Blob_Position_",
        "_Blob_Intensity_",
        "_Blob_Near_Size_",
        "_Blob_Far_Size_",
        "_Blob_Near_Distance_",
        "_Blob_Far_Distance_",
        "_Blob_Fade_Length_",
        "_Blob_Pulse_",
        "_Blob_Fade_",
        "_Blob_Texture_",
        "_Blob_Position_2_",
        "_Blob_Near_Size_2_",
        "_Blob_Pulse_2_",
        "_Blob_Fade_2_",
        "_Left_Index_Pos_",
        "_Right_Index_Pos_",
        "_Left_Index_Middle_Pos_",
        "_Right_Index_Middle_Pos_",
        "_Decal_",
        "_Decal_Scale_XY_",
        "_Decal_Front_Only_",
        "_Rim_Intensity_",
        "_Rim_Texture_",
        "_Rim_Hue_Shift_",
        "_Rim_Saturation_Shift_",
        "_Rim_Value_Shift_",
        "_Iridescence_Intensity_",
        "_Iridescence_Texture_",
        "Use_Global_Left_Index",
        "Use_Global_Right_Index",
        "Global_Left_Index_Tip_Position",
        "Global_Right_Index_Tip_Position",
        "Global_Left_Thumb_Tip_Position",
        "Global_Right_Thumb_Tip_Position",
        "Global_Left_Index_Middle_Position;",
        "Global_Right_Index_Middle_Position",
        "Global_Left_Index_Tip_Proximity",
        "Global_Right_Index_Tip_Proximity"
      ];
      const samplers = ["_Rim_Texture_", "_Iridescence_Texture_"];
      const uniformBuffers = [];
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 4
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 4 }
      }, engine), defines);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", this.getScene().getTransformMatrix());
    this._activeEffect.setVector3("cameraPosition", this.getScene().activeCamera.position);
    this._activeEffect.setFloat("_Radius_", this.radius);
    this._activeEffect.setFloat("_Bevel_Front_", this.bevelFront);
    this._activeEffect.setFloat("_Bevel_Front_Stretch_", this.bevelFrontStretch);
    this._activeEffect.setFloat("_Bevel_Back_", this.bevelBack);
    this._activeEffect.setFloat("_Bevel_Back_Stretch_", this.bevelBackStretch);
    this._activeEffect.setFloat("_Radius_Top_Left_", this.radiusTopLeft);
    this._activeEffect.setFloat("_Radius_Top_Right_", this.radiusTopRight);
    this._activeEffect.setFloat("_Radius_Bottom_Left_", this.radiusBottomLeft);
    this._activeEffect.setFloat("_Radius_Bottom_Right_", this.radiusBottomRight);
    this._activeEffect.setFloat("_Bulge_Enabled_", this.bulgeEnabled ? 1 : 0);
    this._activeEffect.setFloat("_Bulge_Height_", this.bulgeHeight);
    this._activeEffect.setFloat("_Bulge_Radius_", this.bulgeRadius);
    this._activeEffect.setFloat("_Sun_Intensity_", this.sunIntensity);
    this._activeEffect.setFloat("_Sun_Theta_", this.sunTheta);
    this._activeEffect.setFloat("_Sun_Phi_", this.sunPhi);
    this._activeEffect.setFloat("_Indirect_Diffuse_", this.indirectDiffuse);
    this._activeEffect.setDirectColor4("_Albedo_", this.albedo);
    this._activeEffect.setFloat("_Specular_", this.specular);
    this._activeEffect.setFloat("_Shininess_", this.shininess);
    this._activeEffect.setFloat("_Sharpness_", this.sharpness);
    this._activeEffect.setFloat("_Subsurface_", this.subsurface);
    this._activeEffect.setDirectColor4("_Left_Color_", this.leftGradientColor);
    this._activeEffect.setDirectColor4("_Right_Color_", this.rightGradientColor);
    this._activeEffect.setFloat("_Reflection_", this.reflection);
    this._activeEffect.setFloat("_Front_Reflect_", this.frontReflect);
    this._activeEffect.setFloat("_Edge_Reflect_", this.edgeReflect);
    this._activeEffect.setFloat("_Power_", this.power);
    this._activeEffect.setDirectColor4("_Sky_Color_", this.skyColor);
    this._activeEffect.setDirectColor4("_Horizon_Color_", this.horizonColor);
    this._activeEffect.setDirectColor4("_Ground_Color_", this.groundColor);
    this._activeEffect.setFloat("_Horizon_Power_", this.horizonPower);
    this._activeEffect.setTexture("_Reflection_Map_", this._reflectionMapTexture);
    this._activeEffect.setTexture("_Indirect_Environment_", this._indirectEnvTexture);
    this._activeEffect.setFloat("_Width_", this.width);
    this._activeEffect.setFloat("_Fuzz_", this.fuzz);
    this._activeEffect.setFloat("_Min_Fuzz_", this.minFuzz);
    this._activeEffect.setFloat("_Clip_Fade_", this.clipFade);
    this._activeEffect.setFloat("_Hue_Shift_", this.hueShift);
    this._activeEffect.setFloat("_Saturation_Shift_", this.saturationShift);
    this._activeEffect.setFloat("_Value_Shift_", this.valueShift);
    this._activeEffect.setVector3("_Blob_Position_", this.blobPosition);
    this._activeEffect.setFloat("_Blob_Intensity_", this.blobIntensity);
    this._activeEffect.setFloat("_Blob_Near_Size_", this.blobNearSize);
    this._activeEffect.setFloat("_Blob_Far_Size_", this.blobFarSize);
    this._activeEffect.setFloat("_Blob_Near_Distance_", this.blobNearDistance);
    this._activeEffect.setFloat("_Blob_Far_Distance_", this.blobFarDistance);
    this._activeEffect.setFloat("_Blob_Fade_Length_", this.blobFadeLength);
    this._activeEffect.setFloat("_Blob_Pulse_", this.blobPulse);
    this._activeEffect.setFloat("_Blob_Fade_", this.blobFade);
    this._activeEffect.setTexture("_Blob_Texture_", this.blobTexture);
    this._activeEffect.setVector3("_Blob_Position_2_", this.blobPosition2);
    this._activeEffect.setFloat("_Blob_Near_Size_2_", this.blobNearSize2);
    this._activeEffect.setFloat("_Blob_Pulse_2_", this.blobPulse2);
    this._activeEffect.setFloat("_Blob_Fade_2_", this.blobFade2);
    this._activeEffect.setVector3("_Left_Index_Pos_", this.leftIndexPosition);
    this._activeEffect.setVector3("_Right_Index_Pos_", this.rightIndexPosition);
    this._activeEffect.setVector3("_Left_Index_Middle_Pos_", this.leftIndexMiddlePosition);
    this._activeEffect.setVector3("_Right_Index_Middle_Pos_", this.rightIndexMiddlePosition);
    this._activeEffect.setTexture("_Decal_", this._decalTexture);
    this._activeEffect.setVector2("_Decal_Scale_XY_", this.decalScaleXY);
    this._activeEffect.setFloat("_Decal_Front_Only_", this.decalFrontOnly ? 1 : 0);
    this._activeEffect.setFloat("_Rim_Intensity_", this.rimIntensity);
    this._activeEffect.setTexture("_Rim_Texture_", this._blueGradientTexture);
    this._activeEffect.setFloat("_Rim_Hue_Shift_", this.rimHueShift);
    this._activeEffect.setFloat("_Rim_Saturation_Shift_", this.rimSaturationShift);
    this._activeEffect.setFloat("_Rim_Value_Shift_", this.rimValueShift);
    this._activeEffect.setFloat("_Iridescence_Intensity_", this.iridescenceIntensity);
    this._activeEffect.setTexture("_Iridescence_Texture_", this._blueGradientTexture);
    this._activeEffect.setFloat("Use_Global_Left_Index", this.useGlobalLeftIndex);
    this._activeEffect.setFloat("Use_Global_Right_Index", this.useGlobalRightIndex);
    this._activeEffect.setVector4("Global_Left_Index_Tip_Position", this.globalLeftIndexTipPosition);
    this._activeEffect.setVector4("Global_Right_Index_Tip_Position", this.globaRightIndexTipPosition);
    this._activeEffect.setVector4("Global_Left_Thumb_Tip_Position", this.globalLeftThumbTipPosition);
    this._activeEffect.setVector4("Global_Right_Thumb_Tip_Position", this.globalRightThumbTipPosition);
    this._activeEffect.setVector4("Global_Left_Index_Middle_Position", this.globalLeftIndexMiddlePosition);
    this._activeEffect.setVector4("Global_Right_Index_Middle_Position", this.globalRightIndexMiddlePosition);
    this._activeEffect.setFloat("Global_Left_Index_Tip_Proximity", this.globalLeftIndexTipProximity);
    this._activeEffect.setFloat("Global_Right_Index_Tip_Proximity", this.globalRightIndexTipProximity);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  /**
   * Get the list of animatables in the material.
   * @returns the list of animatables object used in the material
   */
  getAnimatables() {
    return [];
  }
  dispose(forceDisposeEffect) {
    super.dispose(forceDisposeEffect);
    this._reflectionMapTexture.dispose();
    this._indirectEnvTexture.dispose();
    this._blueGradientTexture.dispose();
    this._decalTexture.dispose();
  }
  clone(name22) {
    return SerializationHelper.Clone(() => new _MRDLSliderThumbMaterial(name22, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.MRDLSliderThumbMaterial";
    return serializationObject;
  }
  getClassName() {
    return "MRDLSliderThumbMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _MRDLSliderThumbMaterial(source.name, scene), source, scene, rootUrl);
  }
};
MRDLSliderThumbMaterial.BLUE_GRADIENT_TEXTURE_URL = "https://assets.babylonjs.com/core/MRTK/MRDL/mrtk-mrdl-blue-gradient.png";
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "radius", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "bevelFront", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "bevelFrontStretch", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "bevelBack", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "bevelBackStretch", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "radiusTopLeft", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "radiusTopRight", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "radiusBottomLeft", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "radiusBottomRight", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "bulgeEnabled", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "bulgeHeight", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "bulgeRadius", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "sunIntensity", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "sunTheta", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "sunPhi", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "indirectDiffuse", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "albedo", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "specular", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "shininess", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "sharpness", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "subsurface", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "leftGradientColor", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "rightGradientColor", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "reflection", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "frontReflect", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "edgeReflect", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "power", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "skyColor", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "horizonColor", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "groundColor", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "horizonPower", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "width", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "fuzz", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "minFuzz", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "clipFade", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "hueShift", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "saturationShift", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "valueShift", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobPosition", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobIntensity", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobNearSize", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobFarSize", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobNearDistance", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobFarDistance", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobFadeLength", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobPulse", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobFade", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobPosition2", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobNearSize2", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobPulse2", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobFade2", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "blobTexture", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "leftIndexPosition", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "rightIndexPosition", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "leftIndexMiddlePosition", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "rightIndexMiddlePosition", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "decalScaleXY", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "decalFrontOnly", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "rimIntensity", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "rimHueShift", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "rimSaturationShift", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "rimValueShift", void 0);
__decorate([
  serialize()
], MRDLSliderThumbMaterial.prototype, "iridescenceIntensity", void 0);
RegisterClass("BABYLON.GUI.MRDLSliderThumbMaterial", MRDLSliderThumbMaterial);

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlBackplate.fragment.js
var name14 = "mrdlBackplatePixelShader";
var shader13 = `uniform vec3 cameraPosition;varying vec3 vPosition;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec3 vBinormal;varying vec4 vExtra1;varying vec4 vExtra2;uniform float _Radius_;uniform float _Line_Width_;uniform bool _Absolute_Sizes_;uniform float _Filter_Width_;uniform vec4 _Base_Color_;uniform vec4 _Line_Color_;uniform float _Radius_Top_Left_;uniform float _Radius_Top_Right_;uniform float _Radius_Bottom_Left_;uniform float _Radius_Bottom_Right_;uniform float _Rate_;uniform vec4 _Highlight_Color_;uniform float _Highlight_Width_;uniform vec4 _Highlight_Transform_;uniform float _Highlight_;uniform float _Iridescence_Intensity_;uniform float _Iridescence_Edge_Intensity_;uniform vec4 _Iridescence_Tint_;uniform sampler2D _Iridescent_Map_;uniform float _Angle_;uniform bool _Reflected_;uniform float _Frequency_;uniform float _Vertical_Offset_;uniform vec4 _Gradient_Color_;uniform vec4 _Top_Left_;uniform vec4 _Top_Right_;uniform vec4 _Bottom_Left_;uniform vec4 _Bottom_Right_;uniform float _Edge_Width_;uniform float _Edge_Power_;uniform float _Line_Gradient_Blend_;uniform float _Fade_Out_;void FastLinearTosRGB_B353(
vec4 Linear,
out vec4 sRGB)
{sRGB.rgb=sqrt(clamp(Linear.rgb,0.0,1.0));sRGB.a=Linear.a;}
void Round_Rect_Fragment_B332(
float Radius,
float Line_Width,
vec4 Line_Color,
float Filter_Width,
vec2 UV,
float Line_Visibility,
vec4 Rect_Parms,
vec4 Fill_Color,
out vec4 Color)
{float d=length(max(abs(UV)-Rect_Parms.xy,0.0));float dx=max(fwidth(d)*Filter_Width,0.00001);float g=min(Rect_Parms.z,Rect_Parms.w);float dgrad=max(fwidth(g)*Filter_Width,0.00001);float Inside_Rect=clamp(g/dgrad,0.0,1.0);float inner=clamp((d+dx*0.5-max(Radius-Line_Width,d-dx*0.5))/dx,0.0,1.0);Color=clamp(mix(Fill_Color,Line_Color,inner),0.0,1.0)*Inside_Rect;}
void Iridescence_B343(
vec3 Position,
vec3 Normal,
vec2 UV,
vec3 Axis,
vec3 Eye,
vec4 Tint,
sampler2D Texture,
bool Reflected,
float Frequency,
float Vertical_Offset,
out vec4 Color)
{vec3 i=normalize(Position-Eye);vec3 r=reflect(i,Normal);float idota=dot(i,Axis);float idotr=dot(i,r);float x=Reflected ? idotr : idota;vec2 xy;xy.x=fract((x*Frequency+1.0)*0.5+UV.y*Vertical_Offset);xy.y=0.5;Color=texture(Texture,xy);Color.rgb*=Tint.rgb;}
void Scale_RGB_B346(
vec4 Color,
float Scalar,
out vec4 Result)
{Result=vec4(Scalar,Scalar,Scalar,1)*Color;}
void Scale_RGB_B344(
float Scalar,
vec4 Color,
out vec4 Result)
{Result=vec4(Scalar,Scalar,Scalar,1)*Color;}
void Line_Fragment_B362(
vec4 Base_Color,
vec4 Highlight_Color,
float Highlight_Width,
vec3 Line_Vertex,
float Highlight,
out vec4 Line_Color)
{float k2=1.0-clamp(abs(Line_Vertex.y/Highlight_Width),0.0,1.0);Line_Color=mix(Base_Color,Highlight_Color,Highlight*k2);}
void Edge_B356(
vec4 RectParms,
float Radius,
float Line_Width,
vec2 UV,
float Edge_Width,
float Edge_Power,
out float Result)
{float d=length(max(abs(UV)-RectParms.xy,0.0));float edge=1.0-clamp((1.0-d/(Radius-Line_Width))/Edge_Width,0.0,1.0);Result=pow(edge,Edge_Power);}
void Gradient_B355(
vec4 Gradient_Color,
vec4 Top_Left,
vec4 Top_Right,
vec4 Bottom_Left,
vec4 Bottom_Right,
vec2 UV,
out vec4 Result)
{vec3 top=Top_Left.rgb+(Top_Right.rgb-Top_Left.rgb)*UV.x;vec3 bottom=Bottom_Left.rgb+(Bottom_Right.rgb-Bottom_Left.rgb)*UV.x;Result.rgb=Gradient_Color.rgb*(bottom+(top-bottom)*UV.y);Result.a=1.0;}
void main()
{float X_Q338;float Y_Q338;float Z_Q338;float W_Q338;X_Q338=vExtra2.x;Y_Q338=vExtra2.y;Z_Q338=vExtra2.z;W_Q338=vExtra2.w;vec4 Color_Q343;
#if IRIDESCENCE_ENABLE
Iridescence_B343(vPosition,vNormal,vUV,vBinormal,cameraPosition,_Iridescence_Tint_,_Iridescent_Map_,_Reflected_,_Frequency_,_Vertical_Offset_,Color_Q343);
#else
Color_Q343=vec4(0,0,0,0);
#endif
vec4 Result_Q344;Scale_RGB_B344(_Iridescence_Intensity_,Color_Q343,Result_Q344);vec4 Line_Color_Q362;Line_Fragment_B362(_Line_Color_,_Highlight_Color_,_Highlight_Width_,vTangent,_Highlight_,Line_Color_Q362);float Result_Q356;
#if EDGE_ONLY
Edge_B356(vExtra1,Z_Q338,W_Q338,vUV,_Edge_Width_,_Edge_Power_,Result_Q356);
#else
Result_Q356=1.0;
#endif
vec2 Vec2_Q339=vec2(X_Q338,Y_Q338);vec4 Result_Q355;Gradient_B355(_Gradient_Color_,_Top_Left_,_Top_Right_,_Bottom_Left_,_Bottom_Right_,Vec2_Q339,Result_Q355);vec4 Linear_Q348;Linear_Q348.rgb=clamp(Result_Q355.rgb*Result_Q355.rgb,0.0,1.0);Linear_Q348.a=Result_Q355.a;vec4 Result_Q346;Scale_RGB_B346(Linear_Q348,Result_Q356,Result_Q346);vec4 Sum_Q345=Result_Q346+Result_Q344;vec4 Color_At_T_Q347=mix(Line_Color_Q362,Result_Q346,_Line_Gradient_Blend_);vec4 Base_And_Iridescent_Q350;Base_And_Iridescent_Q350=_Base_Color_+vec4(Sum_Q345.rgb,0.0);vec4 Sum_Q349=Color_At_T_Q347+_Iridescence_Edge_Intensity_*Color_Q343;vec4 Result_Q351=Sum_Q349; Result_Q351.a=1.0;vec4 Color_Q332;Round_Rect_Fragment_B332(Z_Q338,W_Q338,Result_Q351,_Filter_Width_,vUV,1.0,vExtra1,Base_And_Iridescent_Q350,Color_Q332);vec4 Result_Q354=_Fade_Out_*Color_Q332;vec4 sRGB_Q353;FastLinearTosRGB_B353(Result_Q354,sRGB_Q353);vec4 Out_Color=sRGB_Q353;float Clip_Threshold=0.001;bool To_sRGB=false;gl_FragColor=Out_Color;}`;
if (!ShaderStore.ShadersStore[name14]) {
  ShaderStore.ShadersStore[name14] = shader13;
}

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlBackplate.vertex.js
var name15 = "mrdlBackplateVertexShader";
var shader14 = `uniform mat4 world;uniform mat4 viewProjection;uniform vec3 cameraPosition;attribute vec3 position;attribute vec3 normal;attribute vec3 tangent;uniform float _Radius_;uniform float _Line_Width_;uniform bool _Absolute_Sizes_;uniform float _Filter_Width_;uniform vec4 _Base_Color_;uniform vec4 _Line_Color_;uniform float _Radius_Top_Left_;uniform float _Radius_Top_Right_;uniform float _Radius_Bottom_Left_;uniform float _Radius_Bottom_Right_;uniform float _Rate_;uniform vec4 _Highlight_Color_;uniform float _Highlight_Width_;uniform vec4 _Highlight_Transform_;uniform float _Highlight_;uniform float _Iridescence_Intensity_;uniform float _Iridescence_Edge_Intensity_;uniform vec4 _Iridescence_Tint_;uniform sampler2D _Iridescent_Map_;uniform float _Angle_;uniform bool _Reflected_;uniform float _Frequency_;uniform float _Vertical_Offset_;uniform vec4 _Gradient_Color_;uniform vec4 _Top_Left_;uniform vec4 _Top_Right_;uniform vec4 _Bottom_Left_;uniform vec4 _Bottom_Right_;uniform float _Edge_Width_;uniform float _Edge_Power_;uniform float _Line_Gradient_Blend_;uniform float _Fade_Out_;varying vec3 vPosition;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec3 vBinormal;varying vec4 vExtra1;varying vec4 vExtra2;void Object_To_World_Pos_B314(
vec3 Pos_Object,
out vec3 Pos_World)
{Pos_World=(world*vec4(Pos_Object,1.0)).xyz;}
void Round_Rect_Vertex_B357(
vec2 UV,
float Radius,
float Margin,
float Anisotropy,
float Gradient1,
float Gradient2,
vec3 Normal,
vec4 Color_Scale_Translate,
out vec2 Rect_UV,
out vec4 Rect_Parms,
out vec2 Scale_XY,
out vec2 Line_UV,
out vec2 Color_UV_Info)
{Scale_XY=vec2(Anisotropy,1.0);Line_UV=(UV-vec2(0.5,0.5));Rect_UV=Line_UV*Scale_XY;Rect_Parms.xy=Scale_XY*0.5-vec2(Radius,Radius)-vec2(Margin,Margin);Rect_Parms.z=Gradient1; 
Rect_Parms.w=Gradient2;Color_UV_Info=(Line_UV+vec2(0.5,0.5))*Color_Scale_Translate.xy+Color_Scale_Translate.zw;}
void Line_Vertex_B333(
vec2 Scale_XY,
vec2 UV,
float Time,
float Rate,
vec4 Highlight_Transform,
out vec3 Line_Vertex)
{float angle2=(Rate*Time)*2.0*3.1416;float sinAngle2=sin(angle2);float cosAngle2=cos(angle2);vec2 xformUV=UV*Highlight_Transform.xy+Highlight_Transform.zw;Line_Vertex.x=0.0;Line_Vertex.y=cosAngle2*xformUV.x-sinAngle2*xformUV.y;Line_Vertex.z=0.0; }
void PickDir_B334(
float Degrees,
vec3 DirX,
vec3 DirY,
out vec3 Dir)
{float a=Degrees*3.14159/180.0;Dir=cos(a)*DirX+sin(a)*DirY;}
void Move_Verts_B327(
float Anisotropy,
vec3 P,
float Radius,
out vec3 New_P,
out vec2 New_UV,
out float Radial_Gradient,
out vec3 Radial_Dir)
{vec2 UV=P.xy*2.0+0.5;vec2 center=clamp(UV,0.0,1.0);vec2 delta=UV-center;vec2 r2=2.0*vec2(Radius/Anisotropy,Radius);New_UV=center+r2*(UV-2.0*center+0.5);New_P=vec3(New_UV-0.5,P.z);Radial_Gradient=1.0-length(delta)*2.0;Radial_Dir=vec3(delta*r2,0.0);}
void Pick_Radius_B336(
float Radius,
float Radius_Top_Left,
float Radius_Top_Right,
float Radius_Bottom_Left,
float Radius_Bottom_Right,
vec3 Position,
out float Result)
{bool whichY=Position.y>0.0;Result=Position.x<0.0 ? (whichY ? Radius_Top_Left : Radius_Bottom_Left) : (whichY ? Radius_Top_Right : Radius_Bottom_Right);Result*=Radius;}
void Edge_AA_Vertex_B328(
vec3 Position_World,
vec3 Position_Object,
vec3 Normal_Object,
vec3 Eye,
float Radial_Gradient,
vec3 Radial_Dir,
vec3 Tangent,
out float Gradient1,
out float Gradient2)
{vec3 I=(Eye-Position_World);vec3 T=(vec4(Tangent,0.0)).xyz;float g=(dot(T,I)<0.0) ? 0.0 : 1.0;if (Normal_Object.z==0.0) { 
Gradient1=Position_Object.z>0.0 ? g : 1.0;Gradient2=Position_Object.z>0.0 ? 1.0 : g;} else {Gradient1=g+(1.0-g)*(Radial_Gradient);Gradient2=1.0;}}
void Object_To_World_Dir_B330(
vec3 Dir_Object,
out vec3 Binormal_World,
out vec3 Binormal_World_N,
out float Binormal_Length)
{Binormal_World=(world*vec4(Dir_Object,0.0)).xyz;Binormal_Length=length(Binormal_World);Binormal_World_N=Binormal_World/Binormal_Length;}
void RelativeOrAbsoluteDetail_B341(
float Nominal_Radius,
float Nominal_LineWidth,
bool Absolute_Measurements,
float Height,
out float Radius,
out float Line_Width)
{float scale=Absolute_Measurements ? 1.0/Height : 1.0;Radius=Nominal_Radius*scale;Line_Width=Nominal_LineWidth*scale;}
void main()
{vec3 Nrm_World_Q326;Nrm_World_Q326=normalize((world*vec4(normal,0.0)).xyz);vec3 Tangent_World_Q329;vec3 Tangent_World_N_Q329;float Tangent_Length_Q329;Tangent_World_Q329=(world*vec4(vec3(1,0,0),0.0)).xyz;Tangent_Length_Q329=length(Tangent_World_Q329);Tangent_World_N_Q329=Tangent_World_Q329/Tangent_Length_Q329;vec3 Binormal_World_Q330;vec3 Binormal_World_N_Q330;float Binormal_Length_Q330;Object_To_World_Dir_B330(vec3(0,1,0),Binormal_World_Q330,Binormal_World_N_Q330,Binormal_Length_Q330);float Radius_Q341;float Line_Width_Q341;RelativeOrAbsoluteDetail_B341(_Radius_,_Line_Width_,_Absolute_Sizes_,Binormal_Length_Q330,Radius_Q341,Line_Width_Q341);vec3 Dir_Q334;PickDir_B334(_Angle_,Tangent_World_N_Q329,Binormal_World_N_Q330,Dir_Q334);float Result_Q336;Pick_Radius_B336(Radius_Q341,_Radius_Top_Left_,_Radius_Top_Right_,_Radius_Bottom_Left_,_Radius_Bottom_Right_,position,Result_Q336);float Anisotropy_Q331=Tangent_Length_Q329/Binormal_Length_Q330;vec4 Out_Color_Q337=vec4(Result_Q336,Line_Width_Q341,0,1);vec3 New_P_Q327;vec2 New_UV_Q327;float Radial_Gradient_Q327;vec3 Radial_Dir_Q327;Move_Verts_B327(Anisotropy_Q331,position,Result_Q336,New_P_Q327,New_UV_Q327,Radial_Gradient_Q327,Radial_Dir_Q327);vec3 Pos_World_Q314;Object_To_World_Pos_B314(New_P_Q327,Pos_World_Q314);float Gradient1_Q328;float Gradient2_Q328;
#if SMOOTH_EDGES
Edge_AA_Vertex_B328(Pos_World_Q314,position,normal,cameraPosition,Radial_Gradient_Q327,Radial_Dir_Q327,tangent,Gradient1_Q328,Gradient2_Q328);
#else
Gradient1_Q328=1.0;Gradient2_Q328=1.0;
#endif
vec2 Rect_UV_Q357;vec4 Rect_Parms_Q357;vec2 Scale_XY_Q357;vec2 Line_UV_Q357;vec2 Color_UV_Info_Q357;Round_Rect_Vertex_B357(New_UV_Q327,Result_Q336,0.0,Anisotropy_Q331,Gradient1_Q328,Gradient2_Q328,normal,vec4(1,1,0,0),Rect_UV_Q357,Rect_Parms_Q357,Scale_XY_Q357,Line_UV_Q357,Color_UV_Info_Q357);vec3 Line_Vertex_Q333;Line_Vertex_B333(Scale_XY_Q357,Line_UV_Q357,(20.0),_Rate_,_Highlight_Transform_,Line_Vertex_Q333);float X_Q359;float Y_Q359;X_Q359=Color_UV_Info_Q357.x;Y_Q359=Color_UV_Info_Q357.y;vec4 Vec4_Q358=vec4(X_Q359,Y_Q359,Result_Q336,Line_Width_Q341);vec3 Position=Pos_World_Q314;vec3 Normal=Nrm_World_Q326;vec2 UV=Rect_UV_Q357;vec3 Tangent=Line_Vertex_Q333;vec3 Binormal=Dir_Q334;vec4 Color=Out_Color_Q337;vec4 Extra1=Rect_Parms_Q357;vec4 Extra2=Vec4_Q358;vec4 Extra3=vec4(0,0,0,0);gl_Position=viewProjection*vec4(Position,1);vPosition=Position;vNormal=Normal;vUV=UV;vTangent=Tangent;vBinormal=Binormal;vExtra1=Extra1;vExtra2=Extra2;}`;
if (!ShaderStore.ShadersStore[name15]) {
  ShaderStore.ShadersStore[name15] = shader14;
}

// node_modules/@babylonjs/gui/3D/materials/mrdl/mrdlBackplateMaterial.js
var MRDLBackplateMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.IRIDESCENCE_ENABLE = true;
    this.SMOOTH_EDGES = true;
    this._needNormals = true;
    this.rebuild();
  }
};
var MRDLBackplateMaterial = class _MRDLBackplateMaterial extends PushMaterial {
  constructor(name22, scene) {
    super(name22, scene);
    this.radius = 0.3;
    this.lineWidth = 3e-3;
    this.absoluteSizes = false;
    this._filterWidth = 1;
    this.baseColor = new Color4(0, 0, 0, 1);
    this.lineColor = new Color4(0.2, 0.262745, 0.4, 1);
    this.radiusTopLeft = 1;
    this.radiusTopRight = 1;
    this.radiusBottomLeft = 1;
    this.radiusBottomRight = 1;
    this._rate = 0;
    this.highlightColor = new Color4(0.239216, 0.435294, 0.827451, 1);
    this.highlightWidth = 0;
    this._highlightTransform = new Vector4(1, 1, 0, 0);
    this._highlight = 1;
    this.iridescenceIntensity = 0.45;
    this.iridescenceEdgeIntensity = 1;
    this.iridescenceTint = new Color4(1, 1, 1, 1);
    this._angle = -45;
    this.fadeOut = 1;
    this._reflected = true;
    this._frequency = 1;
    this._verticalOffset = 0;
    this.gradientColor = new Color4(0.74902, 0.74902, 0.74902, 1);
    this.topLeftGradientColor = new Color4(784314e-8, 0.294118, 0.580392, 1);
    this.topRightGradientColor = new Color4(0.305882, 0, 1, 1);
    this.bottomLeftGradientColor = new Color4(0.133333, 0.258824, 0.992157, 1);
    this.bottomRightGradientColor = new Color4(0.176471, 0.176471, 0.619608, 1);
    this.edgeWidth = 0.5;
    this.edgePower = 1;
    this.edgeLineGradientBlend = 0.5;
    this.alphaMode = Constants.ALPHA_DISABLE;
    this.backFaceCulling = false;
    const textureUrl = Tools.GetAssetUrl(_MRDLBackplateMaterial.IRIDESCENT_MAP_TEXTURE_URL);
    this._iridescentMapTexture = new Texture(textureUrl, this.getScene(), true, false, Texture.NEAREST_SAMPLINGMODE);
  }
  needAlphaBlending() {
    return false;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new MRDLBackplateMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    PrepareDefinesForAttributes(mesh, defines, false, false);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks);
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      if (defines.TANGENT) {
        attribs.push(VertexBuffer.TangentKind);
      }
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "mrdlBackplate";
      const join = defines.toString();
      const uniforms = [
        "world",
        "viewProjection",
        "cameraPosition",
        "_Radius_",
        "_Line_Width_",
        "_Absolute_Sizes_",
        "_Filter_Width_",
        "_Base_Color_",
        "_Line_Color_",
        "_Radius_Top_Left_",
        "_Radius_Top_Right_",
        "_Radius_Bottom_Left_",
        "_Radius_Bottom_Right_",
        "_Rate_",
        "_Highlight_Color_",
        "_Highlight_Width_",
        "_Highlight_Transform_",
        "_Highlight_",
        "_Iridescence_Intensity_",
        "_Iridescence_Edge_Intensity_",
        "_Iridescence_Tint_",
        "_Iridescent_Map_",
        "_Angle_",
        "_Reflected_",
        "_Frequency_",
        "_Vertical_Offset_",
        "_Gradient_Color_",
        "_Top_Left_",
        "_Top_Right_",
        "_Bottom_Left_",
        "_Bottom_Right_",
        "_Edge_Width_",
        "_Edge_Power_",
        "_Line_Gradient_Blend_",
        "_Fade_Out_"
      ];
      const samplers = ["_Iridescent_Map_"];
      const uniformBuffers = [];
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 4
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 4 }
      }, engine), defines);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", this.getScene().getTransformMatrix());
    this._activeEffect.setVector3("cameraPosition", this.getScene().activeCamera.position);
    this._activeEffect.setFloat("_Radius_", this.radius);
    this._activeEffect.setFloat("_Line_Width_", this.lineWidth);
    this._activeEffect.setFloat("_Absolute_Sizes_", this.absoluteSizes ? 1 : 0);
    this._activeEffect.setFloat("_Filter_Width_", this._filterWidth);
    this._activeEffect.setDirectColor4("_Base_Color_", this.baseColor);
    this._activeEffect.setDirectColor4("_Line_Color_", this.lineColor);
    this._activeEffect.setFloat("_Radius_Top_Left_", this.radiusTopLeft);
    this._activeEffect.setFloat("_Radius_Top_Right_", this.radiusTopRight);
    this._activeEffect.setFloat("_Radius_Bottom_Left_", this.radiusBottomLeft);
    this._activeEffect.setFloat("_Radius_Bottom_Right_", this.radiusBottomRight);
    this._activeEffect.setFloat("_Rate_", this._rate);
    this._activeEffect.setDirectColor4("_Highlight_Color_", this.highlightColor);
    this._activeEffect.setFloat("_Highlight_Width_", this.highlightWidth);
    this._activeEffect.setVector4("_Highlight_Transform_", this._highlightTransform);
    this._activeEffect.setFloat("_Highlight_", this._highlight);
    this._activeEffect.setFloat("_Iridescence_Intensity_", this.iridescenceIntensity);
    this._activeEffect.setFloat("_Iridescence_Edge_Intensity_", this.iridescenceEdgeIntensity);
    this._activeEffect.setDirectColor4("_Iridescence_Tint_", this.iridescenceTint);
    this._activeEffect.setTexture("_Iridescent_Map_", this._iridescentMapTexture);
    this._activeEffect.setFloat("_Angle_", this._angle);
    this._activeEffect.setFloat("_Reflected_", this._reflected ? 1 : 0);
    this._activeEffect.setFloat("_Frequency_", this._frequency);
    this._activeEffect.setFloat("_Vertical_Offset_", this._verticalOffset);
    this._activeEffect.setDirectColor4("_Gradient_Color_", this.gradientColor);
    this._activeEffect.setDirectColor4("_Top_Left_", this.topLeftGradientColor);
    this._activeEffect.setDirectColor4("_Top_Right_", this.topRightGradientColor);
    this._activeEffect.setDirectColor4("_Bottom_Left_", this.bottomLeftGradientColor);
    this._activeEffect.setDirectColor4("_Bottom_Right_", this.bottomRightGradientColor);
    this._activeEffect.setFloat("_Edge_Width_", this.edgeWidth);
    this._activeEffect.setFloat("_Edge_Power_", this.edgePower);
    this._activeEffect.setFloat("_Line_Gradient_Blend_", this.edgeLineGradientBlend);
    this._activeEffect.setFloat("_Fade_Out_", this.fadeOut);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  /**
   * Get the list of animatables in the material.
   * @returns the list of animatables object used in the material
   */
  getAnimatables() {
    return [];
  }
  dispose(forceDisposeEffect) {
    super.dispose(forceDisposeEffect);
  }
  clone(name22) {
    return SerializationHelper.Clone(() => new _MRDLBackplateMaterial(name22, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.MRDLBackplateMaterial";
    return serializationObject;
  }
  getClassName() {
    return "MRDLBackplateMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _MRDLBackplateMaterial(source.name, scene), source, scene, rootUrl);
  }
};
MRDLBackplateMaterial.IRIDESCENT_MAP_TEXTURE_URL = "https://assets.babylonjs.com/core/MRTK/MRDL/mrtk-mrdl-backplate-iridescence.png";
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "radius", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "lineWidth", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "absoluteSizes", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "baseColor", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "lineColor", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "radiusTopLeft", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "radiusTopRight", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "radiusBottomLeft", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "radiusBottomRight", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "highlightColor", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "highlightWidth", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "iridescenceIntensity", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "iridescenceEdgeIntensity", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "iridescenceTint", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "fadeOut", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "gradientColor", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "topLeftGradientColor", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "topRightGradientColor", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "bottomLeftGradientColor", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "bottomRightGradientColor", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "edgeWidth", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "edgePower", void 0);
__decorate([
  serialize()
], MRDLBackplateMaterial.prototype, "edgeLineGradientBlend", void 0);
RegisterClass("BABYLON.GUI.MRDLBackplateMaterial", MRDLBackplateMaterial);

// node_modules/@babylonjs/gui/3D/controls/slider3D.js
var SLIDER_MIN = 0;
var SLIDER_MAX = 100;
var SLIDER_VAL = 50;
var SLIDER_STEP = 0;
var SLIDER_SCALING = 1;
var SLIDER_MARGIN = 0.2;
var Slider3D = class _Slider3D extends Control3D {
  /**
   * Creates a new slider
   * @param name defines the control name
   * @param sliderBackplateVisible defines if the control has a backplate, default is false
   */
  constructor(name22, sliderBackplateVisible) {
    super(name22);
    this.onValueChangedObservable = new Observable();
    this._sliderBackplateVisible = sliderBackplateVisible || false;
    this._minimum = SLIDER_MIN;
    this._maximum = SLIDER_MAX;
    this._step = SLIDER_STEP;
    this._value = SLIDER_VAL;
  }
  /**
   * Gets the mesh used to render this control
   */
  get mesh() {
    if (this.node) {
      return this._sliderThumb;
    }
    return null;
  }
  /** Gets or sets minimum value */
  get minimum() {
    return this._minimum;
  }
  set minimum(value) {
    if (this._minimum === value) {
      return;
    }
    this._minimum = Math.max(value, SLIDER_MIN);
    this._value = Math.max(Math.min(this._value, this._maximum), this._minimum);
  }
  /** Gets or sets maximum value */
  get maximum() {
    return this._maximum;
  }
  set maximum(value) {
    if (this._maximum === value) {
      return;
    }
    this._maximum = Math.max(value, this._minimum);
    this._value = Math.max(Math.min(this._value, this._maximum), this._minimum);
  }
  /** Gets or sets step value */
  get step() {
    return this._step;
  }
  set step(value) {
    if (this._step === value) {
      return;
    }
    this._step = Math.max(Math.min(value, this._maximum - this._minimum), SLIDER_STEP);
  }
  /** Gets or sets current value */
  get value() {
    return this._value;
  }
  set value(value) {
    if (this._value === value) {
      return;
    }
    this._value = Math.max(Math.min(value, this._maximum), this._minimum);
    if (this._sliderThumb) {
      this._sliderThumb.position.x = this._convertToPosition(this.value);
    }
    this.onValueChangedObservable.notifyObservers(this._value);
  }
  get start() {
    if (!this.node) {
      return -SLIDER_SCALING / 2;
    }
    return this._sliderBar.position.x - this._sliderBar.scaling.x / 2;
  }
  get end() {
    if (!this.node) {
      return SLIDER_SCALING / 2;
    }
    return this._sliderBar.position.x + this._sliderBar.scaling.x / 2;
  }
  /**
   * Gets the slider bar material used by this control
   */
  get sliderBarMaterial() {
    return this._sliderBarMaterial;
  }
  /**
   * Gets the slider thumb material used by this control
   */
  get sliderThumbMaterial() {
    return this._sliderThumbMaterial;
  }
  /**
   * Gets the slider backplate material used by this control
   */
  get sliderBackplateMaterial() {
    return this._sliderBackplateMaterial;
  }
  /**
   * Gets the slider bar mesh used by this control
   */
  get sliderBar() {
    return this._sliderBar;
  }
  /**
   * Gets the slider thumb mesh used by this control
   */
  get sliderThumb() {
    return this._sliderThumb;
  }
  /**
   * Gets the slider backplate mesh used by this control
   */
  get sliderBackplate() {
    return this._sliderBackplate;
  }
  /** Sets a boolean indicating if the control is visible */
  set isVisible(value) {
    var _a;
    if (this._isVisible === value) {
      return;
    }
    this._isVisible = value;
    (_a = this.node) == null ? void 0 : _a.setEnabled(value);
  }
  // Mesh association
  _createNode(scene) {
    const sliderBackplate = CreateBox(`${this.name}_sliderbackplate`, {
      width: 1,
      height: 1,
      depth: 1
    }, scene);
    sliderBackplate.isPickable = false;
    sliderBackplate.visibility = 0;
    sliderBackplate.scaling = new Vector3(1, 0.5, 0.8);
    const baseUrl = Tools.GetAssetUrl(_Slider3D.MODEL_BASE_URL);
    SceneLoader.ImportMeshAsync(void 0, baseUrl, _Slider3D.MODEL_FILENAME, scene).then((result) => {
      result.meshes.forEach((m) => {
        m.isPickable = false;
      });
      const sliderBackplateModel = result.meshes[1];
      const sliderBarModel = result.meshes[1].clone(`${this.name}_sliderbar`, sliderBackplate);
      const sliderThumbModel = result.meshes[1].clone(`${this.name}_sliderthumb`, sliderBackplate);
      sliderBackplateModel.visibility = 0;
      if (this._sliderBackplateVisible) {
        sliderBackplateModel.visibility = 1;
        sliderBackplateModel.name = `${this.name}_sliderbackplate`;
        sliderBackplateModel.scaling.x = 1;
        sliderBackplateModel.scaling.z = 0.2;
        sliderBackplateModel.parent = sliderBackplate;
        if (this._sliderBackplateMaterial) {
          sliderBackplateModel.material = this._sliderBackplateMaterial;
        }
        this._sliderBackplate = sliderBackplateModel;
      }
      if (sliderBarModel) {
        sliderBarModel.parent = sliderBackplate;
        sliderBarModel.position.z = -0.1;
        sliderBarModel.scaling = new Vector3(SLIDER_SCALING - SLIDER_MARGIN, 0.04, 0.3);
        if (this._sliderBarMaterial) {
          sliderBarModel.material = this._sliderBarMaterial;
        }
        this._sliderBar = sliderBarModel;
      }
      if (sliderThumbModel) {
        sliderThumbModel.parent = sliderBackplate;
        sliderThumbModel.isPickable = true;
        sliderThumbModel.position.z = -0.115;
        sliderThumbModel.scaling = new Vector3(0.025, 0.3, 0.6);
        sliderThumbModel.position.x = this._convertToPosition(this.value);
        sliderThumbModel.addBehavior(this._createBehavior());
        if (this._sliderThumbMaterial) {
          sliderThumbModel.material = this._sliderThumbMaterial;
        }
        this._sliderThumb = sliderThumbModel;
      }
      this._injectGUI3DReservedDataStore(sliderBackplate).control = this;
      sliderBackplate.getChildMeshes().forEach((mesh) => {
        this._injectGUI3DReservedDataStore(mesh).control = this;
      });
    });
    this._affectMaterial(sliderBackplate);
    return sliderBackplate;
  }
  _affectMaterial(mesh) {
    this._sliderBackplateMaterial = this._sliderBackplateMaterial ?? new MRDLBackplateMaterial(`${this.name}_sliderbackplate_material`, mesh.getScene());
    this._sliderBarMaterial = this._sliderBarMaterial ?? new MRDLSliderBarMaterial(`${this.name}_sliderbar_material`, mesh.getScene());
    this._sliderThumbMaterial = this._sliderThumbMaterial ?? new MRDLSliderThumbMaterial(`${this.name}_sliderthumb_material`, mesh.getScene());
  }
  _createBehavior() {
    const pointerDragBehavior = new PointerDragBehavior({ dragAxis: Vector3.Right() });
    pointerDragBehavior.moveAttached = false;
    pointerDragBehavior.onDragStartObservable.add(() => {
      this._draggedPosition = this._sliderThumb.position.x;
    });
    pointerDragBehavior.onDragObservable.add((event) => {
      this._draggedPosition += event.dragDistance / this.scaling.x;
      this.value = this._convertToValue(this._draggedPosition);
    });
    return pointerDragBehavior;
  }
  _convertToPosition(value) {
    const position = (value - this.minimum) / (this.maximum - this.minimum) * (this.end - this.start) + this.start;
    return Math.min(Math.max(position, this.start), this.end);
  }
  _convertToValue(position) {
    let value = (position - this.start) / (this.end - this.start) * (this.maximum - this.minimum);
    value = this.step ? Math.round(value / this.step) * this.step : value;
    return Math.max(Math.min(this.minimum + value, this._maximum), this._minimum);
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    var _a, _b, _c, _d, _e, _f;
    super.dispose();
    (_a = this._sliderBar) == null ? void 0 : _a.dispose();
    (_b = this._sliderThumb) == null ? void 0 : _b.dispose();
    (_c = this._sliderBarMaterial) == null ? void 0 : _c.dispose();
    (_d = this._sliderThumbMaterial) == null ? void 0 : _d.dispose();
    (_e = this._sliderBackplate) == null ? void 0 : _e.dispose();
    (_f = this._sliderBackplateMaterial) == null ? void 0 : _f.dispose();
  }
};
Slider3D.MODEL_BASE_URL = "https://assets.babylonjs.com/core/MRTK/";
Slider3D.MODEL_FILENAME = "mrtk-fluent-backplate.glb";

// node_modules/@babylonjs/gui/3D/controls/spherePanel.js
var SpherePanel = class extends VolumeBasedPanel {
  constructor() {
    super(...arguments);
    this._radius = 5;
  }
  /**
   * Gets or sets the radius of the sphere where to project controls (5 by default)
   */
  get radius() {
    return this._radius;
  }
  set radius(value) {
    if (this._radius === value) {
      return;
    }
    this._radius = value;
    Tools.SetImmediate(() => {
      this._arrangeChildren();
    });
  }
  _mapGridNode(control, nodePosition) {
    const mesh = control.mesh;
    if (!mesh) {
      return;
    }
    const newPos = this._sphericalMapping(nodePosition);
    control.position = newPos;
    switch (this.orientation) {
      case Container3D.FACEORIGIN_ORIENTATION:
        mesh.lookAt(new Vector3(2 * newPos.x, 2 * newPos.y, 2 * newPos.z));
        break;
      case Container3D.FACEORIGINREVERSED_ORIENTATION:
        mesh.lookAt(new Vector3(-newPos.x, -newPos.y, -newPos.z));
        break;
      case Container3D.FACEFORWARD_ORIENTATION:
        break;
      case Container3D.FACEFORWARDREVERSED_ORIENTATION:
        mesh.rotate(
          Axis.Y,
          Math.PI,
          0
          /* Space.LOCAL */
        );
        break;
    }
  }
  _sphericalMapping(source) {
    const newPos = new Vector3(0, 0, this._radius);
    const xAngle = source.y / this._radius;
    const yAngle = -(source.x / this._radius);
    Matrix.RotationYawPitchRollToRef(yAngle, xAngle, 0, TmpVectors.Matrix[0]);
    return Vector3.TransformNormal(newPos, TmpVectors.Matrix[0]);
  }
};

// node_modules/@babylonjs/gui/3D/controls/stackPanel3D.js
var StackPanel3D = class extends Container3D {
  /**
   * Gets or sets a boolean indicating if the stack panel is vertical or horizontal (horizontal by default)
   */
  get isVertical() {
    return this._isVertical;
  }
  set isVertical(value) {
    if (this._isVertical === value) {
      return;
    }
    this._isVertical = value;
    Tools.SetImmediate(() => {
      this._arrangeChildren();
    });
  }
  /**
   * Creates new StackPanel
   * @param isVertical
   */
  constructor(isVertical = false) {
    super();
    this._isVertical = false;
    this.margin = 0.1;
    this._isVertical = isVertical;
  }
  _arrangeChildren() {
    let width = 0;
    let height = 0;
    let controlCount = 0;
    const extendSizes = [];
    const currentInverseWorld = Matrix.Invert(this.node.computeWorldMatrix(true));
    for (const child of this._children) {
      if (!child.mesh) {
        continue;
      }
      controlCount++;
      child.mesh.computeWorldMatrix(true);
      child.mesh.getWorldMatrix().multiplyToRef(currentInverseWorld, TmpVectors.Matrix[0]);
      const boundingBox = child.mesh.getBoundingInfo().boundingBox;
      const extendSize = Vector3.TransformNormal(boundingBox.extendSize, TmpVectors.Matrix[0]);
      extendSizes.push(extendSize);
      if (this._isVertical) {
        height += extendSize.y;
      } else {
        width += extendSize.x;
      }
    }
    if (this._isVertical) {
      height += (controlCount - 1) * this.margin / 2;
    } else {
      width += (controlCount - 1) * this.margin / 2;
    }
    let offset;
    if (this._isVertical) {
      offset = -height;
    } else {
      offset = -width;
    }
    let index = 0;
    for (const child of this._children) {
      if (!child.mesh) {
        continue;
      }
      controlCount--;
      const extendSize = extendSizes[index++];
      if (this._isVertical) {
        child.position.y = offset + extendSize.y;
        child.position.x = 0;
        offset += extendSize.y * 2;
      } else {
        child.position.x = offset + extendSize.x;
        child.position.y = 0;
        offset += extendSize.x * 2;
      }
      offset += controlCount > 0 ? this.margin : 0;
    }
  }
};

// node_modules/@babylonjs/gui/3D/controls/touchMeshButton3D.js
var TouchMeshButton3D = class extends TouchButton3D {
  /**
   * Creates a new 3D button based on a mesh
   * @param mesh mesh to become a 3D button. By default this is also the mesh for near interaction collision checking
   * @param name defines the control name
   */
  constructor(mesh, name22) {
    super(name22, mesh);
    this._currentMesh = mesh;
    this.pointerEnterAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this.mesh.scaling.scaleInPlace(1.1);
    };
    this.pointerOutAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this.mesh.scaling.scaleInPlace(1 / 1.1);
    };
    this.pointerDownAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this.mesh.scaling.scaleInPlace(0.95);
    };
    this.pointerUpAnimation = () => {
      if (!this.mesh) {
        return;
      }
      this.mesh.scaling.scaleInPlace(1 / 0.95);
    };
  }
  _getTypeName() {
    return "TouchMeshButton3D";
  }
  // Mesh association
  _createNode() {
    this._currentMesh.getChildMeshes().forEach((mesh) => {
      this._injectGUI3DReservedDataStore(mesh).control = this;
    });
    return this._currentMesh;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _affectMaterial(mesh) {
  }
};

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlBackglow.fragment.js
var name16 = "mrdlBackglowPixelShader";
var shader15 = `uniform vec3 cameraPosition;varying vec3 vNormal;varying vec2 vUV;uniform float _Bevel_Radius_;uniform float _Line_Width_;uniform bool _Absolute_Sizes_;uniform float _Tuning_Motion_;uniform float _Motion_;uniform float _Max_Intensity_;uniform float _Intensity_Fade_In_Exponent_;uniform float _Outer_Fuzz_Start_;uniform float _Outer_Fuzz_End_;uniform vec4 _Color_;uniform vec4 _Inner_Color_;uniform float _Blend_Exponent_;uniform float _Falloff_;uniform float _Bias_;float BiasFunc(float b,float v) {return pow(v,log(clamp(b,0.001,0.999))/log(0.5));}
void Fuzzy_Round_Rect_B33(
float Size_X,
float Size_Y,
float Radius_X,
float Radius_Y,
float Line_Width,
vec2 UV,
float Outer_Fuzz,
float Max_Outer_Fuzz,
out float Rect_Distance,
out float Inner_Distance)
{vec2 halfSize=vec2(Size_X,Size_Y)*0.5;vec2 r=max(min(vec2(Radius_X,Radius_Y),halfSize),vec2(0.001,0.001));float radius=min(r.x,r.y)-Max_Outer_Fuzz;vec2 v=abs(UV);vec2 nearestp=min(v,halfSize-r);float d=distance(nearestp,v);Inner_Distance=clamp(1.0-(radius-d)/Line_Width,0.0,1.0);Rect_Distance=clamp(1.0-(d-radius)/Outer_Fuzz,0.0,1.0)*Inner_Distance;}
void main()
{float X_Q42;float Y_Q42;X_Q42=vNormal.x;Y_Q42=vNormal.y;float MaxAB_Q24=max(_Tuning_Motion_,_Motion_);float Sqrt_F_Q27=sqrt(MaxAB_Q24);float Power_Q43=pow(MaxAB_Q24,_Intensity_Fade_In_Exponent_);float Value_At_T_Q26=mix(_Outer_Fuzz_Start_,_Outer_Fuzz_End_,Sqrt_F_Q27);float Product_Q23=_Max_Intensity_*Power_Q43;float Rect_Distance_Q33;float Inner_Distance_Q33;Fuzzy_Round_Rect_B33(X_Q42,Y_Q42,_Bevel_Radius_,_Bevel_Radius_,_Line_Width_,vUV,Value_At_T_Q26,_Outer_Fuzz_Start_,Rect_Distance_Q33,Inner_Distance_Q33);float Power_Q44=pow(Inner_Distance_Q33,_Blend_Exponent_);float Result_Q45=pow(BiasFunc(_Bias_,Rect_Distance_Q33),_Falloff_);vec4 Color_At_T_Q25=mix(_Inner_Color_,_Color_,Power_Q44);float Product_Q22=Result_Q45*Product_Q23;vec4 Result_Q28=Product_Q22*Color_At_T_Q25;vec4 Out_Color=Result_Q28;float Clip_Threshold=0.0;gl_FragColor=Out_Color;}`;
if (!ShaderStore.ShadersStore[name16]) {
  ShaderStore.ShadersStore[name16] = shader15;
}

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlBackglow.vertex.js
var name17 = "mrdlBackglowVertexShader";
var shader16 = `uniform mat4 world;uniform mat4 viewProjection;uniform vec3 cameraPosition;attribute vec3 position;attribute vec3 normal;attribute vec2 uv;attribute vec3 tangent;uniform float _Bevel_Radius_;uniform float _Line_Width_;uniform bool _Absolute_Sizes_;uniform float _Tuning_Motion_;uniform float _Motion_;uniform float _Max_Intensity_;uniform float _Intensity_Fade_In_Exponent_;uniform float _Outer_Fuzz_Start_;uniform float _Outer_Fuzz_End_;uniform vec4 _Color_;uniform vec4 _Inner_Color_;uniform float _Blend_Exponent_;uniform float _Falloff_;uniform float _Bias_;varying vec3 vNormal;varying vec2 vUV;void main()
{vec3 Dir_World_Q41=(world*vec4(tangent,0.0)).xyz;vec3 Dir_World_Q40=(world*vec4((cross(normal,tangent)),0.0)).xyz;float MaxAB_Q24=max(_Tuning_Motion_,_Motion_);float Length_Q16=length(Dir_World_Q41);float Length_Q17=length(Dir_World_Q40);bool Greater_Than_Q37=MaxAB_Q24>0.0;vec3 Sizes_Q35;vec2 XY_Q35;Sizes_Q35=(_Absolute_Sizes_ ? vec3(Length_Q16,Length_Q17,0) : vec3(Length_Q16/Length_Q17,1,0));XY_Q35=(uv-vec2(0.5,0.5))*Sizes_Q35.xy;vec3 Result_Q38=Greater_Than_Q37 ? position : vec3(0,0,0);vec3 Pos_World_Q39=(world*vec4(Result_Q38,1.0)).xyz;vec3 Position=Pos_World_Q39;vec3 Normal=Sizes_Q35;vec2 UV=XY_Q35;vec3 Tangent=vec3(0,0,0);vec3 Binormal=vec3(0,0,0);vec4 Color=vec4(1,1,1,1);gl_Position=viewProjection*vec4(Position,1);vNormal=Normal;vUV=UV;}`;
if (!ShaderStore.ShadersStore[name17]) {
  ShaderStore.ShadersStore[name17] = shader16;
}

// node_modules/@babylonjs/gui/3D/materials/mrdl/mrdlBackglowMaterial.js
var MRDLBackglowMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this._needNormals = true;
    this._needUVs = true;
    this.rebuild();
  }
};
var MRDLBackglowMaterial = class _MRDLBackglowMaterial extends PushMaterial {
  constructor(name22, scene) {
    super(name22, scene);
    this.bevelRadius = 0.16;
    this.lineWidth = 0.16;
    this.absoluteSizes = false;
    this.tuningMotion = 0;
    this.motion = 1;
    this.maxIntensity = 0.7;
    this.intensityFadeInExponent = 2;
    this.outerFuzzStart = 0.04;
    this.outerFuzzEnd = 0.04;
    this.color = new Color4(0.682353, 0.698039, 1, 1);
    this.innerColor = new Color4(0.356863, 0.392157, 0.796078, 1);
    this.blendExponent = 1.5;
    this.falloff = 2;
    this.bias = 0.5;
    this.alphaMode = Constants.ALPHA_ADD;
    this.disableDepthWrite = true;
    this.backFaceCulling = false;
  }
  needAlphaBlending() {
    return true;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new MRDLBackglowMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    PrepareDefinesForAttributes(mesh, defines, false, false);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks);
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      if (defines.TANGENT) {
        attribs.push(VertexBuffer.TangentKind);
      }
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "mrdlBackglow";
      const join = defines.toString();
      const uniforms = [
        "world",
        "worldView",
        "worldViewProjection",
        "view",
        "projection",
        "viewProjection",
        "cameraPosition",
        "_Bevel_Radius_",
        "_Line_Width_",
        "_Absolute_Sizes_",
        "_Tuning_Motion_",
        "_Motion_",
        "_Max_Intensity_",
        "_Intensity_Fade_In_Exponent_",
        "_Outer_Fuzz_Start_",
        "_Outer_Fuzz_End_",
        "_Color_",
        "_Inner_Color_",
        "_Blend_Exponent_",
        "_Falloff_",
        "_Bias_"
      ];
      const samplers = [];
      const uniformBuffers = [];
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 4
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 4 }
      }, engine), defines);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    this._activeEffect.setVector3("cameraPosition", scene.activeCamera.position);
    this._activeEffect.setFloat("_Bevel_Radius_", this.bevelRadius);
    this._activeEffect.setFloat("_Line_Width_", this.lineWidth);
    this._activeEffect.setFloat("_Absolute_Sizes_", this.absoluteSizes ? 1 : 0);
    this._activeEffect.setFloat("_Tuning_Motion_", this.tuningMotion);
    this._activeEffect.setFloat("_Motion_", this.motion);
    this._activeEffect.setFloat("_Max_Intensity_", this.maxIntensity);
    this._activeEffect.setFloat("_Intensity_Fade_In_Exponent_", this.intensityFadeInExponent);
    this._activeEffect.setFloat("_Outer_Fuzz_Start_", this.outerFuzzStart);
    this._activeEffect.setFloat("_Outer_Fuzz_End_", this.outerFuzzEnd);
    this._activeEffect.setDirectColor4("_Color_", this.color);
    this._activeEffect.setDirectColor4("_Inner_Color_", this.innerColor);
    this._activeEffect.setFloat("_Blend_Exponent_", this.blendExponent);
    this._activeEffect.setFloat("_Falloff_", this.falloff);
    this._activeEffect.setFloat("_Bias_", this.bias);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  /**
   * Get the list of animatables in the material.
   * @returns the list of animatables object used in the material
   */
  getAnimatables() {
    return [];
  }
  dispose(forceDisposeEffect) {
    super.dispose(forceDisposeEffect);
  }
  clone(name22) {
    return SerializationHelper.Clone(() => new _MRDLBackglowMaterial(name22, this.getScene()), this);
  }
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "BABYLON.MRDLBackglowMaterial";
    return serializationObject;
  }
  getClassName() {
    return "MRDLBackglowMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _MRDLBackglowMaterial(source.name, scene), source, scene, rootUrl);
  }
};
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "bevelRadius", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "lineWidth", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "absoluteSizes", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "tuningMotion", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "motion", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "maxIntensity", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "intensityFadeInExponent", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "outerFuzzStart", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "outerFuzzEnd", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "color", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "innerColor", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "blendExponent", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "falloff", void 0);
__decorate([
  serialize()
], MRDLBackglowMaterial.prototype, "bias", void 0);
RegisterClass("BABYLON.GUI.MRDLBackglowMaterial", MRDLBackglowMaterial);

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlFrontplate.fragment.js
var name18 = "mrdlFrontplatePixelShader";
var shader17 = `uniform vec3 cameraPosition;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec4 vExtra1;varying vec4 vExtra2;varying vec4 vExtra3;uniform float _Radius_;uniform float _Line_Width_;uniform bool _Relative_To_Height_;uniform float _Filter_Width_;uniform vec4 _Edge_Color_;uniform float _Fade_Out_;uniform bool _Smooth_Edges_;uniform bool _Blob_Enable_;uniform vec3 _Blob_Position_;uniform float _Blob_Intensity_;uniform float _Blob_Near_Size_;uniform float _Blob_Far_Size_;uniform float _Blob_Near_Distance_;uniform float _Blob_Far_Distance_;uniform float _Blob_Fade_Length_;uniform float _Blob_Inner_Fade_;uniform float _Blob_Pulse_;uniform float _Blob_Fade_;uniform float _Blob_Pulse_Max_Size_;uniform bool _Blob_Enable_2_;uniform vec3 _Blob_Position_2_;uniform float _Blob_Near_Size_2_;uniform float _Blob_Inner_Fade_2_;uniform float _Blob_Pulse_2_;uniform float _Blob_Fade_2_;uniform float _Gaze_Intensity_;uniform float _Gaze_Focus_;uniform sampler2D _Blob_Texture_;uniform float _Selection_Fuzz_;uniform float _Selected_;uniform float _Selection_Fade_;uniform float _Selection_Fade_Size_;uniform float _Selected_Distance_;uniform float _Selected_Fade_Length_;uniform float _Proximity_Max_Intensity_;uniform float _Proximity_Far_Distance_;uniform float _Proximity_Near_Radius_;uniform float _Proximity_Anisotropy_;uniform bool _Use_Global_Left_Index_;uniform bool _Use_Global_Right_Index_;uniform vec4 Global_Left_Index_Tip_Position;uniform vec4 Global_Right_Index_Tip_Position;void Scale_Color_B54(
vec4 Color,
float Scalar,
out vec4 Result)
{Result=Scalar*Color;}
void Scale_RGB_B50(
vec4 Color,
float Scalar,
out vec4 Result)
{Result=vec4(Scalar,Scalar,Scalar,1)*Color;}
void Proximity_Fragment_B51(
float Proximity_Max_Intensity,
float Proximity_Near_Radius,
vec4 Deltas,
float Show_Selection,
float Distance_Fade1,
float Distance_Fade2,
float Strength,
out float Proximity)
{float proximity1=(1.0-clamp(length(Deltas.xy)/Proximity_Near_Radius,0.0,1.0))*Distance_Fade1;float proximity2=(1.0-clamp(length(Deltas.zw)/Proximity_Near_Radius,0.0,1.0))*Distance_Fade2;Proximity=Strength*(Proximity_Max_Intensity*max(proximity1,proximity2) *(1.0-Show_Selection)+Show_Selection);}
void Blob_Fragment_B56(
vec2 UV,
vec3 Blob_Info,
sampler2D Blob_Texture,
out vec4 Blob_Color)
{float k=dot(UV,UV);Blob_Color=Blob_Info.y*texture(Blob_Texture,vec2(vec2(sqrt(k),Blob_Info.x).x,1.0-vec2(sqrt(k),Blob_Info.x).y))*(1.0-clamp(k,0.0,1.0));}
void Round_Rect_Fragment_B61(
float Radius,
vec4 Line_Color,
float Filter_Width,
float Line_Visibility,
vec4 Fill_Color,
bool Smooth_Edges,
vec4 Rect_Parms,
out float Inside_Rect)
{float d=length(max(abs(Rect_Parms.zw)-Rect_Parms.xy,0.0));float dx=max(fwidth(d)*Filter_Width,0.00001);Inside_Rect=Smooth_Edges ? clamp((Radius-d)/dx,0.0,1.0) : 1.0-step(Radius,d);}
void main()
{float Is_Quad_Q53;Is_Quad_Q53=vNormal.z;vec4 Blob_Color_Q56;Blob_Fragment_B56(vUV,vTangent,_Blob_Texture_,Blob_Color_Q56);float X_Q52;float Y_Q52;float Z_Q52;float W_Q52;X_Q52=vExtra3.x;Y_Q52=vExtra3.y;Z_Q52=vExtra3.z;W_Q52=vExtra3.w;float Proximity_Q51;Proximity_Fragment_B51(_Proximity_Max_Intensity_,_Proximity_Near_Radius_,vExtra2,X_Q52,Y_Q52,Z_Q52,1.0,Proximity_Q51);float Inside_Rect_Q61;Round_Rect_Fragment_B61(W_Q52,vec4(1,1,1,1),_Filter_Width_,1.0,vec4(0,0,0,0),_Smooth_Edges_,vExtra1,Inside_Rect_Q61);vec4 Result_Q50;Scale_RGB_B50(_Edge_Color_,Proximity_Q51,Result_Q50);vec4 Result_Q47=Inside_Rect_Q61*Blob_Color_Q56;vec4 Color_At_T_Q48=mix(Result_Q50,Result_Q47,Is_Quad_Q53);vec4 Result_Q54;Scale_Color_B54(Color_At_T_Q48,_Fade_Out_,Result_Q54);vec4 Out_Color=Result_Q54;float Clip_Threshold=0.001;bool To_sRGB=false;gl_FragColor=Out_Color;}`;
if (!ShaderStore.ShadersStore[name18]) {
  ShaderStore.ShadersStore[name18] = shader17;
}

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlFrontplate.vertex.js
var name19 = "mrdlFrontplateVertexShader";
var shader18 = `uniform mat4 world;uniform mat4 viewProjection;uniform vec3 cameraPosition;attribute vec3 position;attribute vec3 normal;attribute vec2 uv;attribute vec3 tangent;attribute vec4 color;uniform float _Radius_;uniform float _Line_Width_;uniform bool _Relative_To_Height_;uniform float _Filter_Width_;uniform vec4 _Edge_Color_;uniform float _Fade_Out_;uniform bool _Smooth_Edges_;uniform bool _Blob_Enable_;uniform vec3 _Blob_Position_;uniform float _Blob_Intensity_;uniform float _Blob_Near_Size_;uniform float _Blob_Far_Size_;uniform float _Blob_Near_Distance_;uniform float _Blob_Far_Distance_;uniform float _Blob_Fade_Length_;uniform float _Blob_Inner_Fade_;uniform float _Blob_Pulse_;uniform float _Blob_Fade_;uniform float _Blob_Pulse_Max_Size_;uniform bool _Blob_Enable_2_;uniform vec3 _Blob_Position_2_;uniform float _Blob_Near_Size_2_;uniform float _Blob_Inner_Fade_2_;uniform float _Blob_Pulse_2_;uniform float _Blob_Fade_2_;uniform float _Gaze_Intensity_;uniform float _Gaze_Focus_;uniform sampler2D _Blob_Texture_;uniform float _Selection_Fuzz_;uniform float _Selected_;uniform float _Selection_Fade_;uniform float _Selection_Fade_Size_;uniform float _Selected_Distance_;uniform float _Selected_Fade_Length_;uniform float _Proximity_Max_Intensity_;uniform float _Proximity_Far_Distance_;uniform float _Proximity_Near_Radius_;uniform float _Proximity_Anisotropy_;uniform bool _Use_Global_Left_Index_;uniform bool _Use_Global_Right_Index_;uniform vec4 Global_Left_Index_Tip_Position;uniform vec4 Global_Right_Index_Tip_Position;varying vec3 vNormal;varying vec2 vUV;varying vec3 vTangent;varying vec4 vExtra1;varying vec4 vExtra2;varying vec4 vExtra3;void Blob_Vertex_B40(
vec3 Position,
vec3 Normal,
vec3 Tangent,
vec3 Bitangent,
vec3 Blob_Position,
float Intensity,
float Blob_Near_Size,
float Blob_Far_Size,
float Blob_Near_Distance,
float Blob_Far_Distance,
vec4 Vx_Color,
vec2 UV,
vec3 Face_Center,
vec2 Face_Size,
vec2 In_UV,
float Blob_Fade_Length,
float Selection_Fade,
float Selection_Fade_Size,
float Inner_Fade,
float Blob_Pulse,
float Blob_Fade,
float Blob_Enabled,
float DistanceOffset,
out vec3 Out_Position,
out vec2 Out_UV,
out vec3 Blob_Info,
out vec2 Blob_Relative_UV)
{float blobSize,fadeIn;vec3 Hit_Position;Blob_Info=vec3(0.0,0.0,0.0);float Hit_Distance=dot(Blob_Position-Face_Center,Normal)+DistanceOffset*Blob_Far_Distance;Hit_Position=Blob_Position-Hit_Distance*Normal;float absD=abs(Hit_Distance);float lerpVal=clamp((absD-Blob_Near_Distance)/(Blob_Far_Distance-Blob_Near_Distance),0.0,1.0);fadeIn=1.0-clamp((absD-Blob_Far_Distance)/Blob_Fade_Length,0.0,1.0);float innerFade=1.0-clamp(-Hit_Distance/Inner_Fade,0.0,1.0);float farClip=clamp(1.0-step(Blob_Far_Distance+Blob_Fade_Length,absD),0.0,1.0);float size=mix(Blob_Near_Size,Blob_Far_Size,lerpVal)*farClip;blobSize=mix(size,Selection_Fade_Size,Selection_Fade)*innerFade*Blob_Enabled;Blob_Info.x=lerpVal*0.5+0.5;Blob_Info.y=fadeIn*Intensity*(1.0-Selection_Fade)*Blob_Fade;Blob_Info.x*=(1.0-Blob_Pulse);vec3 delta=Hit_Position-Face_Center;vec2 blobCenterXY=vec2(dot(delta,Tangent),dot(delta,Bitangent));vec2 quadUVin=2.0*UV-1.0; 
vec2 blobXY=blobCenterXY+quadUVin*blobSize;vec2 blobClipped=clamp(blobXY,-Face_Size*0.5,Face_Size*0.5);vec2 blobUV=(blobClipped-blobCenterXY)/max(blobSize,0.0001)*2.0;vec3 blobCorner=Face_Center+blobClipped.x*Tangent+blobClipped.y*Bitangent;Out_Position=mix(Position,blobCorner,Vx_Color.rrr);Out_UV=mix(In_UV,blobUV,Vx_Color.rr);Blob_Relative_UV=blobClipped/Face_Size.y;}
void Round_Rect_Vertex_B36(
vec2 UV,
vec3 Tangent,
vec3 Binormal,
float Radius,
float Anisotropy,
vec2 Blob_Center_UV,
out vec2 Rect_UV,
out vec2 Scale_XY,
out vec4 Rect_Parms)
{Scale_XY=vec2(Anisotropy,1.0);Rect_UV=(UV-vec2(0.5,0.5))*Scale_XY;Rect_Parms.xy=Scale_XY*0.5-vec2(Radius,Radius);Rect_Parms.zw=Blob_Center_UV;}
vec2 ProjectProximity(
vec3 blobPosition,
vec3 position,
vec3 center,
vec3 dir,
vec3 xdir,
vec3 ydir,
out float vdistance
)
{vec3 delta=blobPosition-position;vec2 xy=vec2(dot(delta,xdir),dot(delta,ydir));vdistance=abs(dot(delta,dir));return xy;}
void Proximity_Vertex_B33(
vec3 Blob_Position,
vec3 Blob_Position_2,
vec3 Face_Center,
vec3 Position,
float Proximity_Far_Distance,
float Relative_Scale,
float Proximity_Anisotropy,
vec3 Normal,
vec3 Tangent,
vec3 Binormal,
out vec4 Extra,
out float Distance_To_Face,
out float Distance_Fade1,
out float Distance_Fade2)
{float distz1,distz2;Extra.xy=ProjectProximity(Blob_Position,Position,Face_Center,Normal,Tangent*Proximity_Anisotropy,Binormal,distz1)/Relative_Scale;Extra.zw=ProjectProximity(Blob_Position_2,Position,Face_Center,Normal,Tangent*Proximity_Anisotropy,Binormal,distz2)/Relative_Scale;Distance_To_Face=dot(Normal,Position-Face_Center);Distance_Fade1=1.0-clamp(distz1/Proximity_Far_Distance,0.0,1.0);Distance_Fade2=1.0-clamp(distz2/Proximity_Far_Distance,0.0,1.0);}
void Object_To_World_Pos_B12(
vec3 Pos_Object,
out vec3 Pos_World)
{Pos_World=(world*vec4(Pos_Object,1.0)).xyz;}
void Choose_Blob_B27(
vec4 Vx_Color,
vec3 Position1,
vec3 Position2,
bool Blob_Enable_1,
bool Blob_Enable_2,
float Near_Size_1,
float Near_Size_2,
float Blob_Inner_Fade_1,
float Blob_Inner_Fade_2,
float Blob_Pulse_1,
float Blob_Pulse_2,
float Blob_Fade_1,
float Blob_Fade_2,
out vec3 Position,
out float Near_Size,
out float Inner_Fade,
out float Blob_Enable,
out float Fade,
out float Pulse)
{Position=Position1*(1.0-Vx_Color.g)+Vx_Color.g*Position2;float b1=Blob_Enable_1 ? 1.0 : 0.0;float b2=Blob_Enable_2 ? 1.0 : 0.0;Blob_Enable=b1+(b2-b1)*Vx_Color.g;Pulse=Blob_Pulse_1*(1.0-Vx_Color.g)+Vx_Color.g*Blob_Pulse_2;Fade=Blob_Fade_1*(1.0-Vx_Color.g)+Vx_Color.g*Blob_Fade_2;Near_Size=Near_Size_1*(1.0-Vx_Color.g)+Vx_Color.g*Near_Size_2;Inner_Fade=Blob_Inner_Fade_1*(1.0-Vx_Color.g)+Vx_Color.g*Blob_Inner_Fade_2;}
void Move_Verts_B32(
vec2 UV,
float Radius,
float Anisotropy,
float Line_Width,
float Visible,
out vec3 New_P,
out vec2 New_UV)
{vec2 xy=2.0*UV-vec2(0.5,0.5);vec2 center=clamp(xy,0.0,1.0);vec2 delta=2.0*(xy-center);float deltaLength=length(delta);vec2 aniso=vec2(1.0/Anisotropy,1.0);center=(center-vec2(0.5,0.5))*(1.0-2.0*Radius*aniso);New_UV=vec2((2.0-2.0*deltaLength)*Visible,0.0);float deltaRadius= (Radius-Line_Width*New_UV.x);New_P.xy=(center+deltaRadius/deltaLength *aniso*delta);New_P.z=0.0;}
void Object_To_World_Dir_B14(
vec3 Dir_Object,
out vec3 Binormal_World)
{Binormal_World=(world*vec4(Dir_Object,0.0)).xyz;}
void Proximity_Visibility_B55(
float Selection,
vec3 Proximity_Center,
vec3 Proximity_Center_2,
float Proximity_Far_Distance,
float Proximity_Radius,
vec3 Face_Center,
vec3 Normal,
vec2 Face_Size,
float Gaze,
out float Width)
{float boxMaxSize=length(Face_Size)*0.5;float d1=dot(Proximity_Center-Face_Center,Normal);vec3 blob1=Proximity_Center-d1*Normal;float d2=dot(Proximity_Center_2-Face_Center,Normal);vec3 blob2=Proximity_Center_2-d2*Normal;vec3 delta1=blob1-Face_Center;vec3 delta2=blob2-Face_Center;float dist1=dot(delta1,delta1);float dist2=dot(delta2,delta2);float nearestProxDist=sqrt(min(dist1,dist2));Width=(1.0-step(boxMaxSize+Proximity_Radius,nearestProxDist))*(1.0-step(Proximity_Far_Distance,min(d1,d2))*(1.0-step(0.0001,Selection)));Width=max(Gaze,Width);}
vec2 ramp2(vec2 start,vec2 end,vec2 x)
{return clamp((x-start)/(end-start),vec2(0.0,0.0),vec2(1.0,1.0));}
float computeSelection(
vec3 blobPosition,
vec3 normal,
vec3 tangent,
vec3 bitangent,
vec3 faceCenter,
vec2 faceSize,
float selectionFuzz,
float farDistance,
float fadeLength
)
{vec3 delta=blobPosition-faceCenter;float absD=abs(dot(delta,normal));float fadeIn=1.0-clamp((absD-farDistance)/fadeLength,0.0,1.0);vec2 blobCenterXY=vec2(dot(delta,tangent),dot(delta,bitangent));vec2 innerFace=faceSize*(1.0-selectionFuzz)*0.5;vec2 selectPulse=ramp2(-faceSize*0.5,-innerFace,blobCenterXY)-ramp2(innerFace,faceSize*0.5,blobCenterXY);return selectPulse.x*selectPulse.y*fadeIn;}
void Selection_Vertex_B31(
vec3 Blob_Position,
vec3 Blob_Position_2,
vec3 Face_Center,
vec2 Face_Size,
vec3 Normal,
vec3 Tangent,
vec3 Bitangent,
float Selection_Fuzz,
float Selected,
float Far_Distance,
float Fade_Length,
vec3 Active_Face_Dir,
out float Show_Selection)
{float select1=computeSelection(Blob_Position,Normal,Tangent,Bitangent,Face_Center,Face_Size,Selection_Fuzz,Far_Distance,Fade_Length);float select2=computeSelection(Blob_Position_2,Normal,Tangent,Bitangent,Face_Center,Face_Size,Selection_Fuzz,Far_Distance,Fade_Length);Show_Selection=mix(max(select1,select2),1.0,Selected);}
void main()
{vec3 Vec3_Q29=vec3(vec2(0,0).x,vec2(0,0).y,color.r);vec3 Nrm_World_Q24;Nrm_World_Q24=normalize((world*vec4(normal,0.0)).xyz);vec3 Face_Center_Q30;Face_Center_Q30=(world*vec4(vec3(0,0,0),1.0)).xyz;vec3 Tangent_World_Q13;Tangent_World_Q13=(world*vec4(tangent,0.0)).xyz;vec3 Result_Q42;Result_Q42=_Use_Global_Left_Index_ ? Global_Left_Index_Tip_Position.xyz : _Blob_Position_;vec3 Result_Q43;Result_Q43=_Use_Global_Right_Index_ ? Global_Right_Index_Tip_Position.xyz : _Blob_Position_2_;float Value_At_T_Q58=mix(_Blob_Near_Size_,_Blob_Pulse_Max_Size_,_Blob_Pulse_);float Value_At_T_Q59=mix(_Blob_Near_Size_2_,_Blob_Pulse_Max_Size_,_Blob_Pulse_2_);vec3 Cross_Q70=cross(normal,tangent);float Product_Q45=_Gaze_Intensity_*_Gaze_Focus_;float Step_Q46=step(0.0001,Product_Q45);vec3 Tangent_World_N_Q15=normalize(Tangent_World_Q13);vec3 Position_Q27;float Near_Size_Q27;float Inner_Fade_Q27;float Blob_Enable_Q27;float Fade_Q27;float Pulse_Q27;Choose_Blob_B27(color,Result_Q42,Result_Q43,_Blob_Enable_,_Blob_Enable_2_,Value_At_T_Q58,Value_At_T_Q59,_Blob_Inner_Fade_,_Blob_Inner_Fade_2_,_Blob_Pulse_,_Blob_Pulse_2_,_Blob_Fade_,_Blob_Fade_2_,Position_Q27,Near_Size_Q27,Inner_Fade_Q27,Blob_Enable_Q27,Fade_Q27,Pulse_Q27);vec3 Binormal_World_Q14;Object_To_World_Dir_B14(Cross_Q70,Binormal_World_Q14);float Anisotropy_Q21=length(Tangent_World_Q13)/length(Binormal_World_Q14);vec3 Binormal_World_N_Q16=normalize(Binormal_World_Q14);vec2 Face_Size_Q35;float ScaleY_Q35;Face_Size_Q35=vec2(length(Tangent_World_Q13),length(Binormal_World_Q14));ScaleY_Q35=Face_Size_Q35.y;float Out_Radius_Q38;float Out_Line_Width_Q38;Out_Radius_Q38=_Relative_To_Height_ ? _Radius_ : _Radius_/ScaleY_Q35;Out_Line_Width_Q38=_Relative_To_Height_ ? _Line_Width_ : _Line_Width_/ScaleY_Q35;float Show_Selection_Q31;Selection_Vertex_B31(Result_Q42,Result_Q43,Face_Center_Q30,Face_Size_Q35,Nrm_World_Q24,Tangent_World_N_Q15,Binormal_World_N_Q16,_Selection_Fuzz_,_Selected_,_Selected_Distance_,_Selected_Fade_Length_,vec3(0,0,-1),Show_Selection_Q31);float MaxAB_Q41=max(Show_Selection_Q31,Product_Q45);float Width_Q55;Proximity_Visibility_B55(Show_Selection_Q31,Result_Q42,Result_Q43,_Proximity_Far_Distance_,_Proximity_Near_Radius_,Face_Center_Q30,Nrm_World_Q24,Face_Size_Q35,Step_Q46,Width_Q55);vec3 New_P_Q32;vec2 New_UV_Q32;Move_Verts_B32(uv,Out_Radius_Q38,Anisotropy_Q21,Out_Line_Width_Q38,Width_Q55,New_P_Q32,New_UV_Q32);vec3 Pos_World_Q12;Object_To_World_Pos_B12(New_P_Q32,Pos_World_Q12);vec3 Out_Position_Q40;vec2 Out_UV_Q40;vec3 Blob_Info_Q40;vec2 Blob_Relative_UV_Q40;Blob_Vertex_B40(Pos_World_Q12,Nrm_World_Q24,Tangent_World_N_Q15,Binormal_World_N_Q16,Position_Q27,_Blob_Intensity_,Near_Size_Q27,_Blob_Far_Size_,_Blob_Near_Distance_,_Blob_Far_Distance_,color,uv,Face_Center_Q30,Face_Size_Q35,New_UV_Q32,_Blob_Fade_Length_,_Selection_Fade_,_Selection_Fade_Size_,Inner_Fade_Q27,Pulse_Q27,Fade_Q27,Blob_Enable_Q27,0.0,Out_Position_Q40,Out_UV_Q40,Blob_Info_Q40,Blob_Relative_UV_Q40);vec2 Rect_UV_Q36;vec2 Scale_XY_Q36;vec4 Rect_Parms_Q36;Round_Rect_Vertex_B36(New_UV_Q32,Tangent_World_Q13,Binormal_World_Q14,Out_Radius_Q38,Anisotropy_Q21,Blob_Relative_UV_Q40,Rect_UV_Q36,Scale_XY_Q36,Rect_Parms_Q36);vec4 Extra_Q33;float Distance_To_Face_Q33;float Distance_Fade1_Q33;float Distance_Fade2_Q33;Proximity_Vertex_B33(Result_Q42,Result_Q43,Face_Center_Q30,Pos_World_Q12,_Proximity_Far_Distance_,1.0,_Proximity_Anisotropy_,Nrm_World_Q24,Tangent_World_N_Q15,Binormal_World_N_Q16,Extra_Q33,Distance_To_Face_Q33,Distance_Fade1_Q33,Distance_Fade2_Q33);vec4 Vec4_Q37=vec4(MaxAB_Q41,Distance_Fade1_Q33,Distance_Fade2_Q33,Out_Radius_Q38);vec3 Position=Out_Position_Q40;vec3 Normal=Vec3_Q29;vec2 UV=Out_UV_Q40;vec3 Tangent=Blob_Info_Q40;vec3 Binormal=vec3(0,0,0);vec4 Color=vec4(1,1,1,1);vec4 Extra1=Rect_Parms_Q36;vec4 Extra2=Extra_Q33;vec4 Extra3=Vec4_Q37;gl_Position=viewProjection*vec4(Position,1);vNormal=Normal;vUV=UV;vTangent=Tangent;vExtra1=Extra1;vExtra2=Extra2;vExtra3=Extra3;}`;
if (!ShaderStore.ShadersStore[name19]) {
  ShaderStore.ShadersStore[name19] = shader18;
}

// node_modules/@babylonjs/gui/3D/materials/mrdl/mrdlFrontplateMaterial.js
var MRDLFrontplateMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.SMOOTH_EDGES = true;
    this._needNormals = true;
    this._needUVs = true;
    this.rebuild();
  }
};
var MRDLFrontplateMaterial = class _MRDLFrontplateMaterial extends PushMaterial {
  constructor(name22, scene) {
    super(name22, scene);
    this.radius = 0.12;
    this.lineWidth = 0.01;
    this.relativeToHeight = false;
    this._filterWidth = 1;
    this.edgeColor = new Color4(0.53, 0.53, 0.53, 1);
    this.blobEnable = true;
    this.blobPosition = new Vector3(100, 100, 100);
    this.blobIntensity = 0.5;
    this.blobNearSize = 0.032;
    this.blobFarSize = 0.048;
    this.blobNearDistance = 8e-3;
    this.blobFarDistance = 0.064;
    this.blobFadeLength = 0.04;
    this.blobInnerFade = 0.01;
    this.blobPulse = 0;
    this.blobFade = 1;
    this.blobPulseMaxSize = 0.05;
    this.blobEnable2 = true;
    this.blobPosition2 = new Vector3(10, 10.1, -0.6);
    this.blobNearSize2 = 8e-3;
    this.blobInnerFade2 = 0.1;
    this.blobPulse2 = 0;
    this.blobFade2 = 1;
    this.gazeIntensity = 0.8;
    this.gazeFocus = 0;
    this.selectionFuzz = 0.5;
    this.selected = 1;
    this.selectionFade = 0.2;
    this.selectionFadeSize = 0;
    this.selectedDistance = 0.08;
    this.selectedFadeLength = 0.08;
    this.proximityMaxIntensity = 0.45;
    this.proximityFarDistance = 0.16;
    this.proximityNearRadius = 0.016;
    this.proximityAnisotropy = 1;
    this.useGlobalLeftIndex = true;
    this.useGlobalRightIndex = true;
    this.fadeOut = 1;
    this.alphaMode = Constants.ALPHA_ADD;
    this.disableDepthWrite = true;
    this.backFaceCulling = false;
    this._blobTexture = new Texture(_MRDLFrontplateMaterial.BLOB_TEXTURE_URL, scene, true, false, Texture.NEAREST_SAMPLINGMODE);
  }
  needAlphaBlending() {
    return true;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new MRDLFrontplateMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    PrepareDefinesForAttributes(mesh, defines, false, false);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks);
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      if (defines.TANGENT) {
        attribs.push(VertexBuffer.TangentKind);
      }
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "mrdlFrontplate";
      const join = defines.toString();
      const uniforms = [
        "world",
        "worldView",
        "worldViewProjection",
        "view",
        "projection",
        "viewProjection",
        "cameraPosition",
        "_Radius_",
        "_Line_Width_",
        "_Relative_To_Height_",
        "_Filter_Width_",
        "_Edge_Color_",
        "_Fade_Out_",
        "_Smooth_Edges_",
        "_Blob_Enable_",
        "_Blob_Position_",
        "_Blob_Intensity_",
        "_Blob_Near_Size_",
        "_Blob_Far_Size_",
        "_Blob_Near_Distance_",
        "_Blob_Far_Distance_",
        "_Blob_Fade_Length_",
        "_Blob_Inner_Fade_",
        "_Blob_Pulse_",
        "_Blob_Fade_",
        "_Blob_Pulse_Max_Size_",
        "_Blob_Enable_2_",
        "_Blob_Position_2_",
        "_Blob_Near_Size_2_",
        "_Blob_Inner_Fade_2_",
        "_Blob_Pulse_2_",
        "_Blob_Fade_2_",
        "_Gaze_Intensity_",
        "_Gaze_Focus_",
        "_Blob_Texture_",
        "_Selection_Fuzz_",
        "_Selected_",
        "_Selection_Fade_",
        "_Selection_Fade_Size_",
        "_Selected_Distance_",
        "_Selected_Fade_Length_",
        "_Proximity_Max_Intensity_",
        "_Proximity_Far_Distance_",
        "_Proximity_Near_Radius_",
        "_Proximity_Anisotropy_",
        "Global_Left_Index_Tip_Position",
        "Global_Right_Index_Tip_Position",
        "_Use_Global_Left_Index_",
        "_Use_Global_Right_Index_"
      ];
      const samplers = [];
      const uniformBuffers = [];
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 4
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 4 }
      }, engine), defines);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    this._activeEffect.setVector3("cameraPosition", scene.activeCamera.position);
    this._activeEffect.setFloat("_Radius_", this.radius);
    this._activeEffect.setFloat("_Line_Width_", this.lineWidth);
    this._activeEffect.setFloat("_Relative_To_Height_", this.relativeToHeight ? 1 : 0);
    this._activeEffect.setFloat("_Filter_Width_", this._filterWidth);
    this._activeEffect.setDirectColor4("_Edge_Color_", this.edgeColor);
    this._activeEffect.setFloat("_Fade_Out_", this.fadeOut);
    this._activeEffect.setFloat("_Blob_Enable_", this.blobEnable ? 1 : 0);
    this._activeEffect.setVector3("_Blob_Position_", this.blobPosition);
    this._activeEffect.setFloat("_Blob_Intensity_", this.blobIntensity);
    this._activeEffect.setFloat("_Blob_Near_Size_", this.blobNearSize);
    this._activeEffect.setFloat("_Blob_Far_Size_", this.blobFarSize);
    this._activeEffect.setFloat("_Blob_Near_Distance_", this.blobNearDistance);
    this._activeEffect.setFloat("_Blob_Far_Distance_", this.blobFarDistance);
    this._activeEffect.setFloat("_Blob_Fade_Length_", this.blobFadeLength);
    this._activeEffect.setFloat("_Blob_Inner_Fade_", this.blobInnerFade);
    this._activeEffect.setFloat("_Blob_Pulse_", this.blobPulse);
    this._activeEffect.setFloat("_Blob_Fade_", this.blobFade);
    this._activeEffect.setFloat("_Blob_Pulse_Max_Size_", this.blobPulseMaxSize);
    this._activeEffect.setFloat("_Blob_Enable_2_", this.blobEnable2 ? 1 : 0);
    this._activeEffect.setVector3("_Blob_Position_2_", this.blobPosition2);
    this._activeEffect.setFloat("_Blob_Near_Size_2_", this.blobNearSize2);
    this._activeEffect.setFloat("_Blob_Inner_Fade_2_", this.blobInnerFade2);
    this._activeEffect.setFloat("_Blob_Pulse_2_", this.blobPulse2);
    this._activeEffect.setFloat("_Blob_Fade_2_", this.blobFade2);
    this._activeEffect.setFloat("_Gaze_Intensity_", this.gazeIntensity);
    this._activeEffect.setFloat("_Gaze_Focus_", this.gazeFocus);
    this._activeEffect.setTexture("_Blob_Texture_", this._blobTexture);
    this._activeEffect.setFloat("_Selection_Fuzz_", this.selectionFuzz);
    this._activeEffect.setFloat("_Selected_", this.selected);
    this._activeEffect.setFloat("_Selection_Fade_", this.selectionFade);
    this._activeEffect.setFloat("_Selection_Fade_Size_", this.selectionFadeSize);
    this._activeEffect.setFloat("_Selected_Distance_", this.selectedDistance);
    this._activeEffect.setFloat("_Selected_Fade_Length_", this.selectedFadeLength);
    this._activeEffect.setFloat("_Proximity_Max_Intensity_", this.proximityMaxIntensity);
    this._activeEffect.setFloat("_Proximity_Far_Distance_", this.proximityFarDistance);
    this._activeEffect.setFloat("_Proximity_Near_Radius_", this.proximityNearRadius);
    this._activeEffect.setFloat("_Proximity_Anisotropy_", this.proximityAnisotropy);
    this._activeEffect.setFloat("_Use_Global_Left_Index_", this.useGlobalLeftIndex ? 1 : 0);
    this._activeEffect.setFloat("_Use_Global_Right_Index_", this.useGlobalRightIndex ? 1 : 0);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  /**
   * Get the list of animatables in the material.
   * @returns the list of animatables object used in the material
   */
  getAnimatables() {
    return [];
  }
  dispose(forceDisposeEffect) {
    super.dispose(forceDisposeEffect);
  }
  clone(name22) {
    return SerializationHelper.Clone(() => new _MRDLFrontplateMaterial(name22, this.getScene()), this);
  }
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "BABYLON.MRDLFrontplateMaterial";
    return serializationObject;
  }
  getClassName() {
    return "MRDLFrontplateMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _MRDLFrontplateMaterial(source.name, scene), source, scene, rootUrl);
  }
};
MRDLFrontplateMaterial.BLOB_TEXTURE_URL = "";
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "radius", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "lineWidth", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "relativeToHeight", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "edgeColor", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobEnable", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobPosition", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobIntensity", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobNearSize", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobFarSize", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobNearDistance", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobFarDistance", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobFadeLength", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobInnerFade", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobPulse", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobFade", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobPulseMaxSize", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobEnable2", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobPosition2", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobNearSize2", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobInnerFade2", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobPulse2", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "blobFade2", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "gazeIntensity", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "gazeFocus", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "selectionFuzz", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "selected", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "selectionFade", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "selectionFadeSize", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "selectedDistance", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "selectedFadeLength", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "proximityMaxIntensity", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "proximityFarDistance", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "proximityNearRadius", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "proximityAnisotropy", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "useGlobalLeftIndex", void 0);
__decorate([
  serialize()
], MRDLFrontplateMaterial.prototype, "useGlobalRightIndex", void 0);
RegisterClass("BABYLON.GUI.MRDLFrontplateMaterial", MRDLFrontplateMaterial);

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlInnerquad.fragment.js
var name20 = "mrdlInnerquadPixelShader";
var shader19 = `uniform vec3 cameraPosition;varying vec2 vUV;varying vec3 vTangent;uniform vec4 _Color_;uniform float _Radius_;uniform bool _Fixed_Radius_;uniform float _Filter_Width_;uniform float _Glow_Fraction_;uniform float _Glow_Max_;uniform float _Glow_Falloff_;float FilterStep_Bid194(float edge,float x,float filterWidth)
{float dx=max(1.0E-5,fwidth(x)*filterWidth);return max((x+dx*0.5-max(edge,x-dx*0.5))/dx,0.0);}
void Round_Rect_B194(
float Size_X,
float Size_Y,
float Radius,
vec4 Rect_Color,
float Filter_Width,
vec2 UV,
float Glow_Fraction,
float Glow_Max,
float Glow_Falloff,
out vec4 Color)
{vec2 halfSize=vec2(Size_X,Size_Y)*0.5;vec2 r=max(min(vec2(Radius,Radius),halfSize),vec2(0.01,0.01));vec2 v=abs(UV);vec2 nearestp=min(v,halfSize-r);vec2 delta=(v-nearestp)/max(vec2(0.01,0.01),r);float Distance=length(delta);float insideRect=1.0-FilterStep_Bid194(1.0-Glow_Fraction,Distance,Filter_Width);float glow=clamp((1.0-Distance)/Glow_Fraction,0.0,1.0);glow=pow(glow,Glow_Falloff);Color=Rect_Color*max(insideRect,glow*Glow_Max);}
void main()
{float X_Q192;float Y_Q192;float Z_Q192;X_Q192=vTangent.x;Y_Q192=vTangent.y;Z_Q192=vTangent.z;vec4 Color_Q194;Round_Rect_B194(X_Q192,1.0,Y_Q192,_Color_,_Filter_Width_,vUV,_Glow_Fraction_,_Glow_Max_,_Glow_Falloff_,Color_Q194);vec4 Out_Color=Color_Q194;float Clip_Threshold=0.0;gl_FragColor=Out_Color;}
`;
if (!ShaderStore.ShadersStore[name20]) {
  ShaderStore.ShadersStore[name20] = shader19;
}

// node_modules/@babylonjs/gui/3D/materials/mrdl/shaders/mrdlInnerquad.vertex.js
var name21 = "mrdlInnerquadVertexShader";
var shader20 = `uniform mat4 world;uniform mat4 viewProjection;uniform vec3 cameraPosition;attribute vec3 position;attribute vec3 normal;attribute vec2 uv;attribute vec3 tangent;attribute vec4 color;uniform vec4 _Color_;uniform float _Radius_;uniform bool _Fixed_Radius_;uniform float _Filter_Width_;uniform float _Glow_Fraction_;uniform float _Glow_Max_;uniform float _Glow_Falloff_;varying vec2 vUV;varying vec3 vTangent;void main()
{vec3 Pos_World_Q189;Pos_World_Q189=(world*vec4(position,1.0)).xyz;vec3 Dir_World_Q190;Dir_World_Q190=(world*vec4(tangent,0.0)).xyz;vec3 Dir_World_Q191;Dir_World_Q191=(world*vec4((cross(normal,tangent)),0.0)).xyz;float Length_Q180=length(Dir_World_Q190);float Length_Q181=length(Dir_World_Q191);float Quotient_Q184=Length_Q180/Length_Q181;float Quotient_Q195=_Radius_/Length_Q181;vec2 Result_Q193;Result_Q193=vec2((uv.x-0.5)*Length_Q180/Length_Q181,(uv.y-0.5));float Result_Q198=_Fixed_Radius_ ? Quotient_Q195 : _Radius_;vec3 Vec3_Q183=vec3(Quotient_Q184,Result_Q198,0);vec3 Position=Pos_World_Q189;vec3 Normal=vec3(0,0,0);vec2 UV=Result_Q193;vec3 Tangent=Vec3_Q183;vec3 Binormal=vec3(0,0,0);vec4 Color=color;gl_Position=viewProjection*vec4(Position,1);vUV=UV;vTangent=Tangent;}
`;
if (!ShaderStore.ShadersStore[name21]) {
  ShaderStore.ShadersStore[name21] = shader20;
}

// node_modules/@babylonjs/gui/3D/materials/mrdl/mrdlInnerquadMaterial.js
var MRDLInnerquadMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this._needNormals = true;
    this._needUVs = true;
    this.rebuild();
  }
};
var MRDLInnerquadMaterial = class _MRDLInnerquadMaterial extends PushMaterial {
  constructor(name22, scene) {
    super(name22, scene);
    this.color = new Color4(1, 1, 1, 0.05);
    this.radius = 0.12;
    this.fixedRadius = true;
    this._filterWidth = 1;
    this.glowFraction = 0;
    this.glowMax = 0.5;
    this.glowFalloff = 2;
    this.alphaMode = Constants.ALPHA_COMBINE;
    this.backFaceCulling = false;
  }
  needAlphaBlending() {
    return true;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new MRDLInnerquadMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    PrepareDefinesForAttributes(mesh, defines, true, false);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks);
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      if (defines.TANGENT) {
        attribs.push(VertexBuffer.TangentKind);
      }
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "mrdlInnerquad";
      const join = defines.toString();
      const uniforms = [
        "world",
        "worldView",
        "worldViewProjection",
        "view",
        "projection",
        "viewProjection",
        "cameraPosition",
        "_Color_",
        "_Radius_",
        "_Fixed_Radius_",
        "_Filter_Width_",
        "_Glow_Fraction_",
        "_Glow_Max_",
        "_Glow_Falloff_"
      ];
      const samplers = [];
      const uniformBuffers = [];
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 4
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 4 }
      }, engine), defines);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    this._activeEffect.setVector3("cameraPosition", scene.activeCamera.position);
    this._activeEffect.setDirectColor4("_Color_", this.color);
    this._activeEffect.setFloat("_Radius_", this.radius);
    this._activeEffect.setFloat("_Fixed_Radius_", this.fixedRadius ? 1 : 0);
    this._activeEffect.setFloat("_Filter_Width_", this._filterWidth);
    this._activeEffect.setFloat("_Glow_Fraction_", this.glowFraction);
    this._activeEffect.setFloat("_Glow_Max_", this.glowMax);
    this._activeEffect.setFloat("_Glow_Falloff_", this.glowFalloff);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  /**
   * Get the list of animatables in the material.
   * @returns the list of animatables object used in the material
   */
  getAnimatables() {
    return [];
  }
  dispose(forceDisposeEffect) {
    super.dispose(forceDisposeEffect);
  }
  clone(name22) {
    return SerializationHelper.Clone(() => new _MRDLInnerquadMaterial(name22, this.getScene()), this);
  }
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "BABYLON.MRDLInnerquadMaterial";
    return serializationObject;
  }
  getClassName() {
    return "MRDLInnerquadMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _MRDLInnerquadMaterial(source.name, scene), source, scene, rootUrl);
  }
};
__decorate([
  serialize()
], MRDLInnerquadMaterial.prototype, "color", void 0);
__decorate([
  serialize()
], MRDLInnerquadMaterial.prototype, "radius", void 0);
__decorate([
  serialize()
], MRDLInnerquadMaterial.prototype, "fixedRadius", void 0);
__decorate([
  serialize()
], MRDLInnerquadMaterial.prototype, "glowFraction", void 0);
__decorate([
  serialize()
], MRDLInnerquadMaterial.prototype, "glowMax", void 0);
__decorate([
  serialize()
], MRDLInnerquadMaterial.prototype, "glowFalloff", void 0);
RegisterClass("BABYLON.GUI.MRDLInnerquadMaterial", MRDLInnerquadMaterial);

// node_modules/@babylonjs/gui/3D/controls/MRTK3/touchHolographicButton.js
var TouchHolographicButton2 = class _TouchHolographicButton extends TouchButton3D {
  _disposeTooltip() {
    this._tooltipFade = null;
    if (this._tooltipTextBlock) {
      this._tooltipTextBlock.dispose();
    }
    if (this._tooltipTexture) {
      this._tooltipTexture.dispose();
    }
    if (this._tooltipMesh) {
      this._tooltipMesh.dispose();
    }
    this.onPointerEnterObservable.remove(this._tooltipHoverObserver);
    this.onPointerOutObservable.remove(this._tooltipOutObserver);
  }
  /**
   * Rendering ground id of all the mesh in the button
   */
  set renderingGroupId(id) {
    this._backPlate.renderingGroupId = id;
    this._textPlate.renderingGroupId = id;
    this._frontPlate.renderingGroupId = id;
    this._backGlow.renderingGroupId = id;
    this._innerQuad.renderingGroupId = id;
    if (this._tooltipMesh) {
      this._tooltipMesh.renderingGroupId = id;
    }
  }
  get renderingGroupId() {
    return this._backPlate.renderingGroupId;
  }
  /**
   * Gets the mesh used to render this control
   */
  get mesh() {
    return this._backPlate;
  }
  /**
   * Text to be displayed on the tooltip shown when hovering on the button. When set to null tooltip is disabled. (Default: null)
   * Set this property after adding the button to the GUI3DManager
   */
  set tooltipText(text) {
    if (!text) {
      this._disposeTooltip();
      return;
    }
    if (!this._tooltipFade) {
      const rightHandedScene = this._backPlate._scene.useRightHandedSystem;
      this._tooltipMesh = CreatePlane("", { size: 1 }, this._backPlate._scene);
      this._tooltipMesh.position = Vector3.Down().scale(0.7).add(Vector3.Forward(rightHandedScene).scale(-0.15));
      this._tooltipMesh.isPickable = false;
      this._tooltipMesh.parent = this._frontPlateCollisionMesh;
      this._tooltipTexture = AdvancedDynamicTexture.CreateForMesh(this._tooltipMesh);
      const tooltipBackground = new Rectangle();
      tooltipBackground.height = 0.25;
      tooltipBackground.width = 0.8;
      tooltipBackground.cornerRadius = 25;
      tooltipBackground.color = "#ffffff";
      tooltipBackground.thickness = 20;
      tooltipBackground.background = "#060668";
      this._tooltipTexture.addControl(tooltipBackground);
      this._tooltipTextBlock = new TextBlock();
      this._tooltipTextBlock.color = "white";
      this._tooltipTextBlock.fontSize = 100;
      this._tooltipTexture.addControl(this._tooltipTextBlock);
      this._tooltipFade = new FadeInOutBehavior();
      this._tooltipFade.delay = 500;
      this._tooltipMesh.addBehavior(this._tooltipFade);
      this._tooltipHoverObserver = this.onPointerEnterObservable.add(() => {
        if (this._tooltipFade) {
          this._tooltipFade.fadeIn(true);
        }
      });
      this._tooltipOutObserver = this.onPointerOutObservable.add(() => {
        if (this._tooltipFade) {
          this._tooltipFade.fadeIn(false);
        }
      });
    }
    if (this._tooltipTextBlock) {
      this._tooltipTextBlock.text = text;
    }
  }
  get tooltipText() {
    var _a;
    return ((_a = this._tooltipTextBlock) == null ? void 0 : _a.text) || null;
  }
  /**
   * Gets or sets text for the button
   */
  get text() {
    return this._text;
  }
  set text(value) {
    if (this._text === value) {
      return;
    }
    this._text = value;
    this._rebuildContent();
  }
  /**
   * Gets or sets subtext for a button with larger width
   */
  get subtext() {
    return this._subtext;
  }
  set subtext(value) {
    if (this._subtext === value) {
      return;
    }
    this._subtext = value;
    this._rebuildContent();
  }
  /**
   * Gets or sets the image url for the button
   */
  get imageUrl() {
    return this._imageUrl;
  }
  set imageUrl(value) {
    if (this._imageUrl === value) {
      return;
    }
    this._imageUrl = value;
    this._rebuildContent();
  }
  /**
   * Gets the back material used by this button
   */
  get backMaterial() {
    return this._backMaterial;
  }
  /**
   * Gets the front material used by this button
   */
  get frontMaterial() {
    return this._frontMaterial;
  }
  /**
   * Gets the back glow material used by this button
   */
  get backGlowMaterial() {
    return this._backGlowMaterial;
  }
  /**
   * Gets the inner quad material used by this button
   */
  get innerQuadMaterial() {
    return this._innerQuadMaterial;
  }
  /**
   * Gets the plate material used by this button
   */
  get plateMaterial() {
    return this._plateMaterial;
  }
  /**
   * Gets a boolean indicating if this button shares its material with other V3 Buttons
   */
  get shareMaterials() {
    return this._shareMaterials;
  }
  /**
   * Sets whether the backplate is visible or hidden. Hiding the backplate is not recommended without some sort of replacement
   */
  set isBackplateVisible(isVisible) {
    if (this.mesh && this._backMaterial) {
      if (isVisible && !this._isBackplateVisible) {
        this._backPlate.visibility = 1;
      } else if (!isVisible && this._isBackplateVisible) {
        this._backPlate.visibility = 0;
      }
    }
    this._isBackplateVisible = isVisible;
  }
  /**
   * Creates a new button
   * @param name defines the control name
   * @param shareMaterials
   */
  constructor(name22, shareMaterials = true) {
    super(name22);
    this.width = 1;
    this.height = 1;
    this.radius = 0.14;
    this.textSizeInPixels = 18;
    this.imageSizeInPixels = 40;
    this.plateMaterialColor = new Color3(0.4, 0.4, 0.4);
    this.frontPlateDepth = 0.2;
    this.backPlateDepth = 0.04;
    this.backGlowOffset = 0.1;
    this.flatPlaneDepth = 1e-3;
    this.innerQuadRadius = this.radius - 0.04;
    this.innerQuadColor = new Color4(0, 0, 0, 0);
    this.innerQuadToggledColor = new Color4(0.5197843, 0.6485234, 0.9607843, 0.6);
    this.innerQuadHoverColor = new Color4(1, 1, 1, 0.05);
    this.innerQuadToggledHoverColor = new Color4(0.5197843, 0.6485234, 0.9607843, 1);
    this._isBackplateVisible = true;
    this._shareMaterials = true;
    this._shareMaterials = shareMaterials;
    this.pointerEnterAnimation = () => {
      if (this._frontPlate && this._textPlate && !this.isToggleButton) {
        this._performEnterExitAnimation(1);
      }
      if (this.isToggleButton && this._innerQuadMaterial) {
        if (this.isToggled) {
          this._innerQuadMaterial.color = this.innerQuadToggledHoverColor;
        } else {
          this._innerQuadMaterial.color = this.innerQuadHoverColor;
        }
      }
    };
    this.pointerOutAnimation = () => {
      if (this._frontPlate && this._textPlate && !this.isToggleButton) {
        this._performEnterExitAnimation(-0.8);
      }
      if (this.isToggleButton && this._innerQuadMaterial) {
        this._onToggle(this.isToggled);
      }
    };
    this.pointerDownAnimation = () => {
    };
    this.pointerUpAnimation = () => {
    };
    this._pointerClickObserver = this.onPointerClickObservable.add(() => {
      if (this._frontPlate && this._backGlow && !this.isActiveNearInteraction) {
        this._performClickAnimation();
      }
      if (this.isToggleButton && this._innerQuadMaterial) {
        this._onToggle(this.isToggled);
      }
    });
    this._pointerEnterObserver = this.onPointerEnterObservable.add(() => {
      this.pointerEnterAnimation();
    });
    this._pointerOutObserver = this.onPointerOutObservable.add(() => {
      this.pointerOutAnimation();
    });
    this._toggleObserver = this.onToggleObservable.add((isToggled) => {
      if (isToggled) {
        this._innerQuadMaterial.color = this.innerQuadToggledColor;
      } else {
        this._innerQuadMaterial.color = this.innerQuadColor;
      }
    });
  }
  _getTypeName() {
    return "TouchHolographicButton";
  }
  _rebuildContent() {
    let content;
    if (this._getAspectRatio() <= 1) {
      content = this._alignContentVertically();
    } else {
      content = this._alignContentHorizontally();
    }
    this.content = content;
  }
  _getAspectRatio() {
    return this.width / this.height;
  }
  _alignContentVertically() {
    const panel = new StackPanel();
    panel.isVertical = true;
    if (IsDocumentAvailable() && !!document.createElement) {
      if (this._imageUrl) {
        const image = new Image();
        image.source = this._imageUrl;
        image.heightInPixels = 180;
        image.widthInPixels = 100;
        image.paddingTopInPixels = 40;
        image.paddingBottomInPixels = 40;
        panel.addControl(image);
      }
    }
    if (this._text) {
      const text = new TextBlock();
      text.text = this._text;
      text.color = "white";
      text.heightInPixels = 30;
      text.fontSize = 24;
      panel.addControl(text);
    }
    return panel;
  }
  _alignContentHorizontally() {
    let totalPanelWidthInPixels = 240;
    const padding = 15;
    const contentContainer = new Rectangle();
    contentContainer.widthInPixels = totalPanelWidthInPixels;
    contentContainer.heightInPixels = totalPanelWidthInPixels;
    contentContainer.color = "transparent";
    contentContainer.setPaddingInPixels(padding, padding, padding, padding);
    totalPanelWidthInPixels -= padding * 2;
    const panel = new StackPanel();
    panel.isVertical = false;
    panel.scaleY = this._getAspectRatio();
    if (IsDocumentAvailable() && !!document.createElement) {
      if (this._imageUrl) {
        const imageContainer = new Rectangle(`${this.name}_image`);
        imageContainer.widthInPixels = this.imageSizeInPixels;
        imageContainer.heightInPixels = this.imageSizeInPixels;
        imageContainer.color = "transparent";
        totalPanelWidthInPixels -= this.imageSizeInPixels;
        const image = new Image();
        image.source = this._imageUrl;
        imageContainer.addControl(image);
        panel.addControl(imageContainer);
      }
    }
    if (this._text) {
      const text = new TextBlock(`${this.name}_text`);
      text.text = this._text;
      text.color = "white";
      text.fontSize = this.textSizeInPixels;
      text.widthInPixels = totalPanelWidthInPixels;
      if (this._imageUrl) {
        text.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
        text.paddingLeftInPixels = padding;
      }
      if (this._subtext) {
        const textContainer = new Grid();
        textContainer.addColumnDefinition(1);
        textContainer.addRowDefinition(0.5);
        textContainer.addRowDefinition(0.5);
        textContainer.widthInPixels = totalPanelWidthInPixels;
        textContainer.heightInPixels = 45;
        const subtext = new TextBlock(`${this.name}_subtext`);
        subtext.text = this._subtext;
        subtext.color = "#EEEEEEAB";
        subtext.fontSize = this.textSizeInPixels * 0.75;
        subtext.fontWeight = "600";
        if (this._imageUrl) {
          subtext.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;
          subtext.paddingLeftInPixels = padding;
        }
        textContainer.addControl(text, 0);
        textContainer.addControl(subtext, 1);
        panel.addControl(textContainer);
      } else {
        panel.addControl(text);
      }
    }
    contentContainer.addControl(panel);
    return contentContainer;
  }
  // Mesh association
  _createNode(scene) {
    this.name = this.name ?? "TouchHolographicButton";
    const backPlateMesh = this._createBackPlate(scene);
    const collisionMesh = this._createFrontPlate(scene);
    const innerQuadMesh = this._createInnerQuad(scene);
    const backGlowMesh = this._createBackGlow(scene);
    this._frontPlateCollisionMesh = collisionMesh;
    this._textPlate = super._createNode(scene);
    this._textPlate.name = `${this.name}_textPlate`;
    this._textPlate.isPickable = false;
    this._textPlate.scaling.x = this.width;
    this._textPlate.parent = collisionMesh;
    this._backPlate = backPlateMesh;
    this._backPlate.position = Vector3.Forward(scene.useRightHandedSystem).scale(this.backPlateDepth / 2);
    this._backPlate.isPickable = false;
    this._backPlate.addChild(collisionMesh);
    this._backPlate.addChild(innerQuadMesh);
    if (backGlowMesh) {
      this._backPlate.addChild(backGlowMesh);
    }
    const tn = new TransformNode(`${this.name}_root`, scene);
    this._backPlate.setParent(tn);
    this.collisionMesh = collisionMesh;
    this.collidableFrontDirection = this._backPlate.forward.negate();
    return tn;
  }
  _createBackPlate(scene) {
    const backPlateMesh = CreateBox(`${this.name}_backPlate`, {}, scene);
    backPlateMesh.isPickable = false;
    backPlateMesh.visibility = 0;
    backPlateMesh.scaling.z = 0.2;
    const baseUrl = Tools.GetAssetUrl(_TouchHolographicButton.MRTK_ASSET_BASE_URL);
    SceneLoader.ImportMeshAsync(void 0, baseUrl, _TouchHolographicButton.BACKPLATE_MODEL_FILENAME, scene).then((result) => {
      const backPlateModel = result.meshes[1];
      backPlateModel.visibility = 0;
      if (this._isBackplateVisible) {
        backPlateModel.visibility = 1;
        backPlateModel.name = `${this.name}_backPlate`;
        backPlateModel.isPickable = false;
        backPlateModel.scaling.x = this.width;
        backPlateModel.scaling.y = this.height;
        backPlateModel.parent = backPlateMesh;
      }
      if (this._backMaterial) {
        backPlateModel.material = this._backMaterial;
      }
      this._backPlate = backPlateModel;
    });
    return backPlateMesh;
  }
  _createFrontPlate(scene) {
    const collisionMesh = CreateBox(`${this.name}_frontPlate`, {
      width: this.width,
      height: this.height,
      depth: this.frontPlateDepth
    }, scene);
    collisionMesh.isPickable = true;
    collisionMesh.isNearPickable = true;
    collisionMesh.visibility = 0;
    collisionMesh.position = Vector3.Forward(scene.useRightHandedSystem).scale((this.backPlateDepth - this.frontPlateDepth) / 2);
    const baseUrl = Tools.GetAssetUrl(_TouchHolographicButton.MRTK_ASSET_BASE_URL);
    SceneLoader.ImportMeshAsync(void 0, baseUrl, _TouchHolographicButton.FRONTPLATE_MODEL_FILENAME, scene).then((result) => {
      const collisionPlate = CreateBox(`${this.name}_collisionPlate`, {
        width: this.width,
        height: this.height
      }, scene);
      collisionPlate.isPickable = false;
      collisionPlate.scaling.z = this.frontPlateDepth;
      collisionPlate.visibility = 0;
      collisionPlate.parent = collisionMesh;
      this._collisionPlate = collisionPlate;
      const frontPlateModel = result.meshes[1];
      frontPlateModel.name = `${this.name}_frontPlate`;
      frontPlateModel.isPickable = false;
      frontPlateModel.scaling.x = this.width - this.backGlowOffset;
      frontPlateModel.scaling.y = this.height - this.backGlowOffset;
      frontPlateModel.position = Vector3.Forward(scene.useRightHandedSystem).scale(-0.5);
      frontPlateModel.parent = collisionPlate;
      if (this.isToggleButton) {
        frontPlateModel.visibility = 0;
      }
      if (this._frontMaterial) {
        frontPlateModel.material = this._frontMaterial;
      }
      this._textPlate.scaling.x = 1;
      this._textPlate.parent = frontPlateModel;
      this._frontPlate = frontPlateModel;
    });
    return collisionMesh;
  }
  _createInnerQuad(scene) {
    const innerQuadMesh = CreateBox(`${this.name}_innerQuad`, {}, scene);
    innerQuadMesh.isPickable = false;
    innerQuadMesh.visibility = 0;
    innerQuadMesh.scaling.z = this.flatPlaneDepth;
    innerQuadMesh.position.z += this.backPlateDepth / 2 - this.flatPlaneDepth;
    const baseUrl = Tools.GetAssetUrl(_TouchHolographicButton.MRTK_ASSET_BASE_URL);
    SceneLoader.ImportMeshAsync(void 0, baseUrl, _TouchHolographicButton.INNERQUAD_MODEL_FILENAME, scene).then((result) => {
      const innerQuadModel = result.meshes[1];
      innerQuadModel.name = `${this.name}_innerQuad`;
      innerQuadModel.isPickable = false;
      innerQuadModel.scaling.x = this.width - this.backGlowOffset;
      innerQuadModel.scaling.y = this.height - this.backGlowOffset;
      innerQuadModel.parent = innerQuadMesh;
      if (this._innerQuadMaterial) {
        innerQuadModel.material = this._innerQuadMaterial;
      }
      this._innerQuad = innerQuadModel;
    });
    return innerQuadMesh;
  }
  _createBackGlow(scene) {
    if (this.isToggleButton) {
      return;
    }
    const backGlowMesh = CreateBox(`${this.name}_backGlow`, {}, scene);
    backGlowMesh.isPickable = false;
    backGlowMesh.visibility = 0;
    backGlowMesh.scaling.z = this.flatPlaneDepth;
    backGlowMesh.position.z += this.backPlateDepth / 2 - this.flatPlaneDepth * 2;
    const baseUrl = Tools.GetAssetUrl(_TouchHolographicButton.MRTK_ASSET_BASE_URL);
    SceneLoader.ImportMeshAsync(void 0, baseUrl, _TouchHolographicButton.BACKGLOW_MODEL_FILENAME, scene).then((result) => {
      const backGlowModel = result.meshes[1];
      backGlowModel.name = `${this.name}_backGlow`;
      backGlowModel.isPickable = false;
      backGlowModel.scaling.x = this.width - this.backGlowOffset;
      backGlowModel.scaling.y = this.height - this.backGlowOffset;
      backGlowModel.parent = backGlowMesh;
      if (this._backGlowMaterial) {
        backGlowModel.material = this._backGlowMaterial;
      }
      this._backGlow = backGlowModel;
    });
    return backGlowMesh;
  }
  _applyFacade(facadeTexture) {
    this._plateMaterial.emissiveTexture = facadeTexture;
    this._plateMaterial.opacityTexture = facadeTexture;
    this._plateMaterial.diffuseColor = this.plateMaterialColor;
  }
  _performClickAnimation() {
    const frameRate = 60;
    const animationGroup = new AnimationGroup("Click Animation Group");
    const animations = [
      {
        name: "backGlowMotion",
        mesh: this._backGlow,
        property: "material.motion",
        keys: [
          {
            frame: 0,
            values: [0, 0, 0]
          },
          {
            frame: 20,
            values: [1, 0.0144, 0.0144]
          },
          {
            frame: 40,
            values: [0.0027713229489760476, 0, 0]
          },
          {
            frame: 45,
            values: [0.0027713229489760476]
          }
        ]
      },
      {
        name: "_collisionPlateZSlide",
        mesh: this._collisionPlate,
        property: "position.z",
        keys: [
          {
            frame: 0,
            values: [0, 0, 0]
          },
          {
            frame: 20,
            values: [Vector3.Forward(this._collisionPlate._scene.useRightHandedSystem).scale(this.frontPlateDepth / 2).z, 0, 0]
          },
          {
            frame: 40,
            values: [0, 0.005403332496794331]
          },
          {
            frame: 45,
            values: [0]
          }
        ]
      },
      {
        name: "_collisionPlateZScale",
        mesh: this._collisionPlate,
        property: "scaling.z",
        keys: [
          {
            frame: 0,
            values: [this.frontPlateDepth, 0, 0]
          },
          {
            frame: 20,
            values: [this.backPlateDepth, 0, 0]
          },
          {
            frame: 40,
            values: [this.frontPlateDepth, 54e-4]
          },
          {
            frame: 45,
            values: [this.frontPlateDepth]
          }
        ]
      }
    ];
    for (const animation of animations) {
      const anim = new Animation(animation.name, animation.property, frameRate, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);
      const animkeyFrames = [];
      for (const key of animation.keys) {
        animkeyFrames.push({
          frame: key.frame,
          value: key.values[0],
          inTangent: key.values[1],
          outTangent: key.values[2],
          interpolation: key.values[3]
        });
      }
      anim.setKeys(animkeyFrames);
      if (!animation.mesh) {
        continue;
      }
      animationGroup.addTargetedAnimation(anim, animation.mesh);
    }
    animationGroup.normalize(0, 45);
    animationGroup.speedRatio = 1;
    animationGroup.play();
  }
  _performEnterExitAnimation(speedRatio) {
    const frameRate = 60;
    const animationGroup = new AnimationGroup("Enter Exit Animation Group");
    const animations = [
      {
        name: "frontPlateFadeOut",
        mesh: this._frontPlate,
        property: "material.fadeOut",
        keys: [
          {
            frame: 0,
            values: [0, 0, 0.025045314830017686, 0]
          },
          {
            frame: 40,
            values: [1.00205599570012, 0.025045314830017686, 0, 0]
          }
        ]
      },
      {
        name: "textPlateZSlide",
        mesh: this._textPlate,
        property: "position.z",
        keys: [
          {
            frame: 0,
            values: [0, 0, 0]
          },
          {
            frame: 40,
            values: [Vector3.Forward(this._textPlate._scene.useRightHandedSystem).scale(-0.15).z, 0, 0]
          }
        ]
      }
    ];
    for (const animation of animations) {
      const anim = new Animation(animation.name, animation.property, frameRate, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);
      const animkeyFrames = [];
      for (const key of animation.keys) {
        animkeyFrames.push({
          frame: key.frame,
          value: key.values[0],
          inTangent: key.values[1],
          outTangent: key.values[2],
          interpolation: key.values[3]
        });
      }
      anim.setKeys(animkeyFrames);
      if (!animation.mesh) {
        continue;
      }
      animationGroup.addTargetedAnimation(anim, animation.mesh);
    }
    animationGroup.normalize(0, 45);
    animationGroup.speedRatio = speedRatio;
    animationGroup.play();
  }
  _createBackMaterial(mesh) {
    this._backMaterial = this._backMaterial ?? new MRDLBackplateMaterial(this.name + "backPlateMaterial", mesh.getScene());
    this._backMaterial.absoluteSizes = true;
    this._backMaterial.radius = this.radius;
    this._backMaterial.lineWidth = 0.02;
  }
  _createFrontMaterial(mesh) {
    this._frontMaterial = this._frontMaterial ?? new MRDLFrontplateMaterial(this.name + "Front Material", mesh.getScene());
    this.frontMaterial.radius = this.innerQuadRadius;
    this.frontMaterial.fadeOut = 0;
  }
  _createBackGlowMaterial(mesh) {
    const glowRadius = this.radius + 0.04;
    this._backGlowMaterial = this._backGlowMaterial ?? new MRDLBackglowMaterial(this.name + "Back Glow Material", mesh.getScene());
    this._backGlowMaterial.bevelRadius = glowRadius;
    this._backGlowMaterial.lineWidth = glowRadius;
    this._backGlowMaterial.motion = 0;
  }
  _createInnerQuadMaterial(mesh) {
    this._innerQuadMaterial = this._innerQuadMaterial ?? new MRDLInnerquadMaterial("inner_quad", mesh.getScene());
    this._innerQuadMaterial.radius = this.innerQuadRadius;
    if (this.isToggleButton) {
      this._innerQuadMaterial.color = this.innerQuadColor;
    }
  }
  _createPlateMaterial(mesh) {
    this._plateMaterial = this._plateMaterial ?? new StandardMaterial(this.name + "Plate Material", mesh.getScene());
    this._plateMaterial.specularColor = Color3.Black();
  }
  _onToggle(newState) {
    super._onToggle(newState);
  }
  _affectMaterial(mesh) {
    if (this._shareMaterials) {
      if (!this._host._touchSharedMaterials["mrdlBackplateMaterial"]) {
        this._createBackMaterial(mesh);
        this._host._touchSharedMaterials["mrdlBackplateMaterial"] = this._backMaterial;
      } else {
        this._backMaterial = this._host._touchSharedMaterials["mrdlBackplateMaterial"];
      }
      if (!this._host._touchSharedMaterials["mrdlFrontplateMaterial"]) {
        this._createFrontMaterial(mesh);
        this._host._touchSharedMaterials["mrdlFrontplateMaterial"] = this._frontMaterial;
      } else {
        this._frontMaterial = this._host._touchSharedMaterials["mrdlFrontplateMaterial"];
      }
      if (!this._host._touchSharedMaterials["mrdlBackglowMaterial"]) {
        this._createBackGlowMaterial(mesh);
        this._host._touchSharedMaterials["mrdlBackglowMaterial"] = this._backGlowMaterial;
      } else {
        this._backGlowMaterial = this._host._touchSharedMaterials["mrdlBackglowMaterial"];
      }
      if (!this._host._touchSharedMaterials["mrdlInnerQuadMaterial"]) {
        this._createInnerQuadMaterial(mesh);
        this._host._touchSharedMaterials["mrdlInnerQuadMaterial"] = this._innerQuadMaterial;
      } else {
        this._innerQuadMaterial = this._host._touchSharedMaterials["mrdlInnerQuadMaterial"];
      }
    } else {
      this._createBackMaterial(mesh);
      this._createFrontMaterial(mesh);
      this._createBackGlowMaterial(mesh);
      this._createInnerQuadMaterial(mesh);
    }
    this._createPlateMaterial(mesh);
    this._backPlate.material = this._backMaterial;
    this._textPlate.material = this._plateMaterial;
    if (!this._isBackplateVisible) {
      this._backPlate.visibility = 0;
    }
    if (this._frontPlate) {
      this._frontPlate.material = this._frontMaterial;
    }
    if (this._backGlow) {
      this._backGlow.material = this._backGlowMaterial;
    }
    if (this._innerQuad) {
      this._innerQuad.material = this._innerQuadMaterial;
    }
    this._rebuildContent();
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    super.dispose();
    this._disposeTooltip();
    this.onPointerClickObservable.remove(this._pointerClickObserver);
    this.onPointerEnterObservable.remove(this._pointerEnterObserver);
    this.onPointerOutObservable.remove(this._pointerOutObserver);
    this.onToggleObservable.remove(this._toggleObserver);
    if (!this.shareMaterials) {
      this._backMaterial.dispose();
      this._frontMaterial.dispose();
      this._plateMaterial.dispose();
      this._backGlowMaterial.dispose();
      this._innerQuadMaterial.dispose();
      if (this._pickedPointObserver) {
        this._host.onPickedPointChangedObservable.remove(this._pickedPointObserver);
        this._pickedPointObserver = null;
      }
    }
  }
};
TouchHolographicButton2.MRTK_ASSET_BASE_URL = "https://assets.babylonjs.com/core/MRTK/";
TouchHolographicButton2.FRONTPLATE_MODEL_FILENAME = "mrtk-fluent-frontplate.glb";
TouchHolographicButton2.BACKPLATE_MODEL_FILENAME = "mrtk-fluent-backplate.glb";
TouchHolographicButton2.BACKGLOW_MODEL_FILENAME = "mrtk-fluent-button.glb";
TouchHolographicButton2.INNERQUAD_MODEL_FILENAME = "SlateProximity.glb";

// node_modules/@babylonjs/gui/3D/gui3DManager.js
var GUI3DManager = class _GUI3DManager {
  /** Gets the hosting scene */
  get scene() {
    return this._scene;
  }
  /** Gets associated utility layer */
  get utilityLayer() {
    return this._utilityLayer;
  }
  /** Gets the scaling for all UI elements owned by this manager */
  get controlScaling() {
    return this._customControlScaling;
  }
  /** Sets the scaling adjustment for all UI elements owned by this manager */
  set controlScaling(newScale) {
    if (this._customControlScaling !== newScale && newScale > 0) {
      const scaleRatio = newScale / this._customControlScaling;
      this._customControlScaling = newScale;
      this._rootContainer.children.forEach((control) => {
        control.scaling.scaleInPlace(scaleRatio);
        if (newScale !== 1) {
          control._isScaledByManager = true;
        }
      });
    }
  }
  /** Gets if controls attached to this manager are realistically sized, based on the fact that 1 unit length is 1 meter */
  get useRealisticScaling() {
    return this.controlScaling === _GUI3DManager.MRTK_REALISTIC_SCALING;
  }
  /** Sets if controls attached to this manager are realistically sized, based on the fact that 1 unit length is 1 meter */
  set useRealisticScaling(newValue) {
    this.controlScaling = newValue ? _GUI3DManager.MRTK_REALISTIC_SCALING : 1;
  }
  /**
   * Creates a new GUI3DManager
   * @param scene
   */
  constructor(scene) {
    this._customControlScaling = 1;
    this._lastControlOver = {};
    this._lastControlDown = {};
    this.onPickedPointChangedObservable = new Observable();
    this.onPickingObservable = new Observable();
    this._sharedMaterials = {};
    this._touchSharedMaterials = {};
    this._scene = scene || EngineStore.LastCreatedScene;
    this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => {
      this._sceneDisposeObserver = null;
      this._utilityLayer = null;
      this.dispose();
    });
    this._utilityLayer = UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(this._scene);
    this._utilityLayer.onlyCheckPointerDownEvents = false;
    this._utilityLayer.pickUtilitySceneFirst = false;
    this._utilityLayer.mainSceneTrackerPredicate = (mesh) => {
      var _a, _b, _c;
      return mesh && ((_c = (_b = (_a = mesh.reservedDataStore) == null ? void 0 : _a.GUI3D) == null ? void 0 : _b.control) == null ? void 0 : _c._node);
    };
    this._rootContainer = new Container3D("RootContainer");
    this._rootContainer._host = this;
    const utilityLayerScene = this._utilityLayer.utilityLayerScene;
    this._pointerOutObserver = this._utilityLayer.onPointerOutObservable.add((pointerId) => {
      this._handlePointerOut(pointerId, true);
    });
    this._pointerObserver = utilityLayerScene.onPointerObservable.add((pi) => {
      this._doPicking(pi);
    });
    this._utilityLayer.utilityLayerScene.autoClear = false;
    this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;
    new HemisphericLight("hemi", Vector3.Up(), this._utilityLayer.utilityLayerScene);
  }
  _handlePointerOut(pointerId, isPointerUp) {
    const previousControlOver = this._lastControlOver[pointerId];
    if (previousControlOver) {
      previousControlOver._onPointerOut(previousControlOver);
      delete this._lastControlOver[pointerId];
    }
    if (isPointerUp) {
      if (this._lastControlDown[pointerId]) {
        this._lastControlDown[pointerId].forcePointerUp();
        delete this._lastControlDown[pointerId];
      }
    }
    this.onPickedPointChangedObservable.notifyObservers(null);
  }
  _doPicking(pi) {
    var _a, _b, _c;
    if (!this._utilityLayer || !this._utilityLayer.shouldRender || !this._utilityLayer.utilityLayerScene.activeCamera) {
      return false;
    }
    const pointerEvent = pi.event;
    const pointerId = pointerEvent.pointerId || 0;
    const buttonIndex = pointerEvent.button;
    const pickingInfo = pi.pickInfo;
    if (pickingInfo) {
      this.onPickingObservable.notifyObservers(pickingInfo.pickedMesh);
    }
    if (!pickingInfo || !pickingInfo.hit) {
      this._handlePointerOut(pointerId, pi.type === PointerEventTypes.POINTERUP);
      return false;
    }
    if (pickingInfo.pickedPoint) {
      this.onPickedPointChangedObservable.notifyObservers(pickingInfo.pickedPoint);
    }
    const control = (_b = (_a = pickingInfo.pickedMesh.reservedDataStore) == null ? void 0 : _a.GUI3D) == null ? void 0 : _b.control;
    if (!!control && !control._processObservables(pi.type, pickingInfo.pickedPoint, ((_c = pickingInfo.originMesh) == null ? void 0 : _c.position) || null, pointerId, buttonIndex)) {
      if (pi.type === PointerEventTypes.POINTERMOVE) {
        if (this._lastControlOver[pointerId]) {
          this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId]);
        }
        delete this._lastControlOver[pointerId];
      }
    }
    if (pi.type === PointerEventTypes.POINTERUP) {
      if (this._lastControlDown[pointerEvent.pointerId]) {
        this._lastControlDown[pointerEvent.pointerId].forcePointerUp();
        delete this._lastControlDown[pointerEvent.pointerId];
      }
      if (pointerEvent.pointerType === "touch" || pointerEvent.pointerType === "xr" && this._scene.getEngine().hostInformation.isMobile) {
        this._handlePointerOut(pointerId, false);
      }
    }
    return true;
  }
  /**
   * Gets the root container
   */
  get rootContainer() {
    return this._rootContainer;
  }
  /**
   * Gets a boolean indicating if the given control is in the root child list
   * @param control defines the control to check
   * @returns true if the control is in the root child list
   */
  containsControl(control) {
    return this._rootContainer.containsControl(control);
  }
  /**
   * Adds a control to the root child list
   * @param control defines the control to add
   * @returns the current manager
   */
  addControl(control) {
    this._rootContainer.addControl(control);
    if (this._customControlScaling !== 1) {
      control.scaling.scaleInPlace(this._customControlScaling);
      control._isScaledByManager = true;
    }
    return this;
  }
  /**
   * Removes a control from the root child list
   * @param control defines the control to remove
   * @returns the current container
   */
  removeControl(control) {
    this._rootContainer.removeControl(control);
    if (control._isScaledByManager) {
      control.scaling.scaleInPlace(1 / this._customControlScaling);
      control._isScaledByManager = false;
    }
    return this;
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    this._rootContainer.dispose();
    for (const materialName in this._sharedMaterials) {
      if (!Object.prototype.hasOwnProperty.call(this._sharedMaterials, materialName)) {
        continue;
      }
      this._sharedMaterials[materialName].dispose();
    }
    this._sharedMaterials = {};
    for (const materialName in this._touchSharedMaterials) {
      if (!Object.prototype.hasOwnProperty.call(this._touchSharedMaterials, materialName)) {
        continue;
      }
      this._touchSharedMaterials[materialName].dispose();
    }
    this._touchSharedMaterials = {};
    if (this._pointerOutObserver && this._utilityLayer) {
      this._utilityLayer.onPointerOutObservable.remove(this._pointerOutObserver);
      this._pointerOutObserver = null;
    }
    this.onPickedPointChangedObservable.clear();
    this.onPickingObservable.clear();
    const utilityLayerScene = this._utilityLayer ? this._utilityLayer.utilityLayerScene : null;
    if (utilityLayerScene) {
      if (this._pointerObserver) {
        utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
        this._pointerObserver = null;
      }
    }
    if (this._scene) {
      if (this._sceneDisposeObserver) {
        this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);
        this._sceneDisposeObserver = null;
      }
    }
    if (this._utilityLayer) {
      this._utilityLayer.dispose();
    }
  }
};
GUI3DManager.MRTK_REALISTIC_SCALING = 0.032;
export {
  AbstractButton3D,
  AdvancedDynamicTexture,
  AdvancedDynamicTextureInstrumentation,
  BaseGradient,
  BaseSlider,
  Button,
  Button3D,
  Checkbox,
  CheckboxGroup,
  ColorPicker,
  Container,
  Container3D,
  Control,
  Control3D,
  CornerHandle,
  CylinderPanel,
  DisplayGrid,
  Ellipse,
  FluentBackplateMaterial,
  FluentButtonMaterial,
  FluentMaterial,
  FluentMaterialDefines,
  FocusableButton,
  FrameGraphGUITask,
  GUI3DManager,
  GizmoHandle,
  Grid,
  HandMenu,
  HandleMaterial,
  HandleState,
  HolographicBackplate,
  HolographicButton,
  HolographicSlate,
  Image,
  ImageBasedSlider,
  ImageScrollBar,
  InputPassword,
  InputText,
  InputTextArea,
  KeyPropertySet,
  Line,
  LinearGradient,
  MRDLBackplateMaterial,
  MRDLSliderBarMaterial,
  MRDLSliderThumbMaterial,
  MathTools,
  Matrix2D,
  Measure,
  MeshButton3D,
  MultiLine,
  MultiLinePoint,
  NearMenu,
  NodeRenderGraphGUIBlock,
  PlanePanel,
  RadialGradient,
  RadioButton,
  RadioGroup,
  Rectangle,
  ScatterPanel,
  ScrollBar,
  ScrollViewer,
  SelectionPanel,
  SelectorGroup,
  SideHandle,
  SlateGizmo,
  Slider,
  Slider3D,
  SliderGroup,
  SpherePanel,
  StackPanel,
  StackPanel3D,
  Style,
  TextBlock,
  TextWrapper,
  TextWrapping,
  ToggleButton,
  TouchButton3D,
  TouchHolographicButton,
  TouchHolographicButton2 as TouchHolographicButtonV3,
  TouchHolographicMenu,
  TouchMeshButton3D,
  ValueAndUnit,
  Vector2WithInfo,
  Vector3WithInfo,
  VirtualKeyboard,
  VolumeBasedPanel,
  XmlLoader,
  name
};
//# sourceMappingURL=@babylonjs_gui.js.map
