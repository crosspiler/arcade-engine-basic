import {
  Action,
  DoNothingAction
} from "./chunk-PF6TECPM.js";
import {
  AbstractActionManager
} from "./chunk-F7GYARAY.js";
import {
  DeepCopier
} from "./chunk-QPP7FIQR.js";
import {
  Logger
} from "./chunk-OJJXGLTO.js";
import {
  Color3,
  Color4
} from "./chunk-U2XMHILU.js";
import {
  Vector3,
  Vector4
} from "./chunk-4FZTLWAK.js";
import {
  EngineStore
} from "./chunk-AYMFJBP3.js";
import {
  GetClass,
  RegisterClass
} from "./chunk-LMH7SWDS.js";

// node_modules/@babylonjs/core/Actions/condition.js
var Condition = class {
  /**
   * Creates a new Condition
   * @param actionManager the manager of the action the condition is applied to
   */
  constructor(actionManager) {
    this._actionManager = actionManager;
  }
  /**
   * Check if the current condition is valid
   * @returns a boolean
   */
  isValid() {
    return true;
  }
  /**
   * @internal
   */
  _getProperty(propertyPath) {
    return this._actionManager._getProperty(propertyPath);
  }
  /**
   * @internal
   */
  _getEffectiveTarget(target, propertyPath) {
    return this._actionManager._getEffectiveTarget(target, propertyPath);
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Serialize placeholder for child classes
   * @returns the serialized object
   */
  serialize() {
  }
  /**
   * @internal
   */
  _serialize(serializedCondition) {
    return {
      type: 2,
      // Condition
      children: [],
      name: serializedCondition.name,
      properties: serializedCondition.properties
    };
  }
};
var ValueCondition = class _ValueCondition extends Condition {
  /**
   * returns the number for IsEqual
   */
  static get IsEqual() {
    return _ValueCondition._IsEqual;
  }
  /**
   * Returns the number for IsDifferent
   */
  static get IsDifferent() {
    return _ValueCondition._IsDifferent;
  }
  /**
   * Returns the number for IsGreater
   */
  static get IsGreater() {
    return _ValueCondition._IsGreater;
  }
  /**
   * Returns the number for IsLesser
   */
  static get IsLesser() {
    return _ValueCondition._IsLesser;
  }
  /**
   * Creates a new ValueCondition
   * @param actionManager manager for the action the condition applies to
   * @param target for the action
   * @param propertyPath path to specify the property of the target the conditional operator uses
   * @param value the value compared by the conditional operator against the current value of the property
   * @param operator the conditional operator, default ValueCondition.IsEqual
   */
  constructor(actionManager, target, propertyPath, value, operator = _ValueCondition.IsEqual) {
    super(actionManager);
    this.propertyPath = propertyPath;
    this.value = value;
    this.operator = operator;
    this._target = target;
    this._effectiveTarget = this._getEffectiveTarget(target, this.propertyPath);
    this._property = this._getProperty(this.propertyPath);
  }
  /**
   * Compares the given value with the property value for the specified conditional operator
   * @returns the result of the comparison
   */
  isValid() {
    switch (this.operator) {
      case _ValueCondition.IsGreater:
        return this._effectiveTarget[this._property] > this.value;
      case _ValueCondition.IsLesser:
        return this._effectiveTarget[this._property] < this.value;
      case _ValueCondition.IsEqual:
      case _ValueCondition.IsDifferent: {
        let check;
        if (this.value.equals) {
          check = this.value.equals(this._effectiveTarget[this._property]);
        } else {
          check = this.value === this._effectiveTarget[this._property];
        }
        return this.operator === _ValueCondition.IsEqual ? check : !check;
      }
    }
    return false;
  }
  /**
   * Serialize the ValueCondition into a JSON compatible object
   * @returns serialization object
   */
  serialize() {
    return this._serialize({
      name: "ValueCondition",
      properties: [
        Action._GetTargetProperty(this._target),
        { name: "propertyPath", value: this.propertyPath },
        { name: "value", value: Action._SerializeValueAsString(this.value) },
        { name: "operator", value: _ValueCondition.GetOperatorName(this.operator) }
      ]
    });
  }
  /**
   * Gets the name of the conditional operator for the ValueCondition
   * @param operator the conditional operator
   * @returns the name
   */
  static GetOperatorName(operator) {
    switch (operator) {
      case _ValueCondition._IsEqual:
        return "IsEqual";
      case _ValueCondition._IsDifferent:
        return "IsDifferent";
      case _ValueCondition._IsGreater:
        return "IsGreater";
      case _ValueCondition._IsLesser:
        return "IsLesser";
      default:
        return "";
    }
  }
};
ValueCondition._IsEqual = 0;
ValueCondition._IsDifferent = 1;
ValueCondition._IsGreater = 2;
ValueCondition._IsLesser = 3;
var PredicateCondition = class extends Condition {
  /**
   * Creates a new PredicateCondition
   * @param actionManager manager for the action the condition applies to
   * @param predicate defines the predicate function used to validate the condition
   */
  constructor(actionManager, predicate) {
    super(actionManager);
    this.predicate = predicate;
  }
  /**
   * @returns the validity of the predicate condition
   */
  isValid() {
    return this.predicate();
  }
};
var StateCondition = class extends Condition {
  /**
   * Creates a new StateCondition
   * @param actionManager manager for the action the condition applies to
   * @param target of the condition
   * @param value to compare with target state
   */
  constructor(actionManager, target, value) {
    super(actionManager);
    this.value = value;
    this._target = target;
  }
  /**
   * Gets a boolean indicating if the current condition is met
   * @returns the validity of the state
   */
  isValid() {
    return this._target.state === this.value;
  }
  /**
   * Serialize the StateCondition into a JSON compatible object
   * @returns serialization object
   */
  serialize() {
    return this._serialize({
      name: "StateCondition",
      properties: [Action._GetTargetProperty(this._target), { name: "value", value: this.value }]
    });
  }
};
RegisterClass("BABYLON.ValueCondition", ValueCondition);
RegisterClass("BABYLON.PredicateCondition", PredicateCondition);
RegisterClass("BABYLON.StateCondition", StateCondition);

// node_modules/@babylonjs/core/Actions/actionManager.js
var ActionManager = class _ActionManager extends AbstractActionManager {
  /**
   * Creates a new action manager
   * @param scene defines the hosting scene
   */
  constructor(scene) {
    super();
    scene = scene || EngineStore.LastCreatedScene;
    if (!scene) {
      return;
    }
    this._scene = scene;
    scene.actionManagers.push(this);
  }
  // Methods
  /**
   * Releases all associated resources
   */
  dispose() {
    const sceneIndex = this._scene.actionManagers.indexOf(this);
    for (let i = 0; i < this.actions.length; i++) {
      const action = this.actions[i];
      _ActionManager.Triggers[action.trigger]--;
      if (_ActionManager.Triggers[action.trigger] === 0) {
        delete _ActionManager.Triggers[action.trigger];
      }
    }
    this.actions.length = 0;
    if (sceneIndex > -1) {
      this._scene.actionManagers.splice(sceneIndex, 1);
    }
    const ownerMeshes = this._scene.meshes.filter((m) => m.actionManager === this);
    for (const ownerMesh of ownerMeshes) {
      ownerMesh.actionManager = null;
    }
  }
  /**
   * Gets hosting scene
   * @returns the hosting scene
   */
  getScene() {
    return this._scene;
  }
  /**
   * Does this action manager handles actions of any of the given triggers
   * @param triggers defines the triggers to be tested
   * @returns a boolean indicating whether one (or more) of the triggers is handled
   */
  hasSpecificTriggers(triggers) {
    for (let index = 0; index < this.actions.length; index++) {
      const action = this.actions[index];
      if (triggers.indexOf(action.trigger) > -1) {
        return true;
      }
    }
    return false;
  }
  /**
   * Does this action manager handles actions of any of the given triggers. This function takes two arguments for
   * speed.
   * @param triggerA defines the trigger to be tested
   * @param triggerB defines the trigger to be tested
   * @returns a boolean indicating whether one (or more) of the triggers is handled
   */
  hasSpecificTriggers2(triggerA, triggerB) {
    for (let index = 0; index < this.actions.length; index++) {
      const action = this.actions[index];
      if (triggerA == action.trigger || triggerB == action.trigger) {
        return true;
      }
    }
    return false;
  }
  /**
   * Does this action manager handles actions of a given trigger
   * @param trigger defines the trigger to be tested
   * @param parameterPredicate defines an optional predicate to filter triggers by parameter
   * @returns whether the trigger is handled
   */
  hasSpecificTrigger(trigger, parameterPredicate) {
    for (let index = 0; index < this.actions.length; index++) {
      const action = this.actions[index];
      if (action.trigger === trigger) {
        if (parameterPredicate) {
          if (parameterPredicate(action.getTriggerParameter())) {
            return true;
          }
        } else {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Does this action manager has pointer triggers
   */
  get hasPointerTriggers() {
    for (let index = 0; index < this.actions.length; index++) {
      const action = this.actions[index];
      if (action.trigger >= _ActionManager.OnPickTrigger && action.trigger <= _ActionManager.OnPointerOutTrigger) {
        return true;
      }
    }
    return false;
  }
  /**
   * Does this action manager has pick triggers
   */
  get hasPickTriggers() {
    for (let index = 0; index < this.actions.length; index++) {
      const action = this.actions[index];
      if (action.trigger >= _ActionManager.OnPickTrigger && action.trigger <= _ActionManager.OnPickUpTrigger) {
        return true;
      }
    }
    return false;
  }
  /**
   * Registers an action to this action manager
   * @param action defines the action to be registered
   * @returns the action amended (prepared) after registration
   */
  registerAction(action) {
    if (action.trigger === _ActionManager.OnEveryFrameTrigger) {
      if (this.getScene().actionManager !== this) {
        Logger.Warn("OnEveryFrameTrigger can only be used with scene.actionManager");
        return null;
      }
    }
    this.actions.push(action);
    this.getScene()._registeredActions++;
    if (_ActionManager.Triggers[action.trigger]) {
      _ActionManager.Triggers[action.trigger]++;
    } else {
      _ActionManager.Triggers[action.trigger] = 1;
    }
    action._actionManager = this;
    action._prepare();
    return action;
  }
  /**
   * Unregisters an action to this action manager
   * @param action defines the action to be unregistered
   * @returns a boolean indicating whether the action has been unregistered
   */
  unregisterAction(action) {
    const index = this.actions.indexOf(action);
    if (index !== -1) {
      this.actions.splice(index, 1);
      _ActionManager.Triggers[action.trigger] -= 1;
      if (_ActionManager.Triggers[action.trigger] === 0) {
        delete _ActionManager.Triggers[action.trigger];
      }
      action._actionManager = null;
      this.getScene()._registeredActions--;
      return true;
    }
    return false;
  }
  /**
   * Process a specific trigger
   * @param trigger defines the trigger to process
   * @param evt defines the event details to be processed
   */
  processTrigger(trigger, evt) {
    for (let index = 0; index < this.actions.length; index++) {
      const action = this.actions[index];
      if (action.trigger === trigger) {
        if (evt) {
          if (trigger === _ActionManager.OnKeyUpTrigger || trigger === _ActionManager.OnKeyDownTrigger) {
            const parameter = action.getTriggerParameter();
            if (typeof parameter === "function") {
              if (!parameter(evt)) {
                continue;
              }
            } else if (parameter && parameter !== evt.sourceEvent.keyCode) {
              if (!parameter.toLowerCase) {
                continue;
              }
              const lowerCase = parameter.toLowerCase();
              if (lowerCase !== evt.sourceEvent.key) {
                const unicode = evt.sourceEvent.charCode ? evt.sourceEvent.charCode : evt.sourceEvent.keyCode;
                const actualkey = String.fromCharCode(unicode).toLowerCase();
                if (actualkey !== lowerCase) {
                  continue;
                }
              }
            }
          }
        }
        action._executeCurrent(evt);
      }
    }
  }
  /**
   * @internal
   */
  _getEffectiveTarget(target, propertyPath) {
    const properties = propertyPath.split(".");
    for (let index = 0; index < properties.length - 1; index++) {
      target = target[properties[index]];
    }
    return target;
  }
  /**
   * @internal
   */
  _getProperty(propertyPath) {
    const properties = propertyPath.split(".");
    return properties[properties.length - 1];
  }
  /**
   * Serialize this manager to a JSON object
   * @param name defines the property name to store this manager
   * @returns a JSON representation of this manager
   */
  serialize(name) {
    const root = {
      children: new Array(),
      name,
      type: 3,
      // Root node
      properties: new Array()
      // Empty for root but required
    };
    for (let i = 0; i < this.actions.length; i++) {
      const triggerObject = {
        type: 0,
        // Trigger
        children: new Array(),
        name: _ActionManager.GetTriggerName(this.actions[i].trigger),
        properties: new Array()
      };
      const triggerOptions = this.actions[i].triggerOptions;
      if (triggerOptions && typeof triggerOptions !== "number") {
        if (triggerOptions.parameter instanceof Node) {
          triggerObject.properties.push(Action._GetTargetProperty(triggerOptions.parameter));
        } else if (typeof triggerOptions.parameter === "object") {
          const parameter = {};
          DeepCopier.DeepCopy(triggerOptions.parameter, parameter, ["mesh"]);
          if (triggerOptions.parameter && triggerOptions.parameter.mesh) {
            parameter._meshId = triggerOptions.parameter.mesh.id;
          }
          triggerObject.properties.push({ name: "parameter", targetType: null, value: parameter });
        } else {
          triggerObject.properties.push({ name: "parameter", targetType: null, value: triggerOptions.parameter });
        }
      }
      this.actions[i].serialize(triggerObject);
      root.children.push(triggerObject);
    }
    return root;
  }
  /**
   * Creates a new ActionManager from a JSON data
   * @param parsedActions defines the JSON data to read from
   * @param object defines the hosting mesh
   * @param scene defines the hosting scene
   */
  static Parse(parsedActions, object, scene) {
    const actionManager = new _ActionManager(scene);
    if (object === null) {
      scene.actionManager = actionManager;
    } else {
      object.actionManager = actionManager;
    }
    const instantiate = (name, params) => {
      const internalClassType = GetClass("BABYLON." + name);
      return internalClassType && new internalClassType(...params);
    };
    const parseParameter = (name, value, target, propertyPath) => {
      if (propertyPath === null) {
        const floatValue = parseFloat(value);
        if (value === "true" || value === "false") {
          return value === "true";
        } else {
          return isNaN(floatValue) ? value : floatValue;
        }
      }
      const effectiveTarget = propertyPath.split(".");
      const values = value.split(",");
      for (let i = 0; i < effectiveTarget.length; i++) {
        target = target[effectiveTarget[i]];
      }
      if (typeof target === "boolean") {
        return values[0] === "true";
      }
      if (typeof target === "string") {
        return values[0];
      }
      const split = [];
      for (let i = 0; i < values.length; i++) {
        split.push(parseFloat(values[i]));
      }
      if (target instanceof Vector3) {
        return Vector3.FromArray(split);
      }
      if (target instanceof Vector4) {
        return Vector4.FromArray(split);
      }
      if (target instanceof Color3) {
        return Color3.FromArray(split);
      }
      if (target instanceof Color4) {
        return Color4.FromArray(split);
      }
      return parseFloat(values[0]);
    };
    const traverse = (parsedAction, trigger, condition, action, combineArray = null) => {
      if (parsedAction.detached) {
        return;
      }
      const parameters = [];
      let target = null;
      let propertyPath = null;
      const combine = parsedAction.combine && parsedAction.combine.length > 0;
      if (parsedAction.type === 2) {
        parameters.push(actionManager);
      } else {
        parameters.push(trigger);
      }
      if (combine) {
        const actions = [];
        for (let j = 0; j < parsedAction.combine.length; j++) {
          traverse(parsedAction.combine[j], _ActionManager.NothingTrigger, condition, action, actions);
        }
        parameters.push(actions);
      } else {
        for (let i = 0; i < parsedAction.properties.length; i++) {
          let value = parsedAction.properties[i].value;
          const name = parsedAction.properties[i].name;
          const targetType = parsedAction.properties[i].targetType;
          if (name === "target") {
            if (targetType === "SceneProperties") {
              value = target = scene;
            } else if (targetType === "MaterialProperties") {
              value = target = scene.getMaterialByName(value);
            } else {
              value = target = scene.getNodeByName(value);
            }
          } else if (name === "parent") {
            value = scene.getNodeByName(value);
          } else if (name === "sound") {
            if (scene.getSoundByName) {
              value = scene.getSoundByName(value);
            }
          } else if (name !== "propertyPath") {
            if (parsedAction.type === 2 && name === "operator") {
              value = ValueCondition[value];
            } else {
              value = parseParameter(name, value, target, name === "value" ? propertyPath : null);
            }
          } else {
            propertyPath = value;
          }
          parameters.push(value);
        }
      }
      if (combineArray === null) {
        parameters.push(condition);
      } else {
        parameters.push(null);
      }
      if (parsedAction.name === "InterpolateValueAction") {
        const param = parameters[parameters.length - 2];
        parameters[parameters.length - 1] = param;
        parameters[parameters.length - 2] = condition;
      }
      let newAction = instantiate(parsedAction.name, parameters);
      if (newAction instanceof Condition && condition !== null) {
        const nothing = new DoNothingAction(trigger, condition);
        if (action) {
          action.then(nothing);
        } else {
          actionManager.registerAction(nothing);
        }
        action = nothing;
      }
      if (combineArray === null) {
        if (newAction instanceof Condition) {
          condition = newAction;
          newAction = action;
        } else {
          condition = null;
          if (action) {
            action.then(newAction);
          } else {
            actionManager.registerAction(newAction);
          }
        }
      } else {
        combineArray.push(newAction);
      }
      for (let i = 0; i < parsedAction.children.length; i++) {
        traverse(parsedAction.children[i], trigger, condition, newAction, null);
      }
    };
    for (let i = 0; i < parsedActions.children.length; i++) {
      let triggerParams;
      const trigger = parsedActions.children[i];
      if (trigger.properties.length > 0) {
        const param = trigger.properties[0].value;
        const value = trigger.properties[0].targetType === null ? param : scene.getMeshByName(param);
        if (value._meshId) {
          value.mesh = scene.getMeshById(value._meshId);
        }
        triggerParams = { trigger: _ActionManager[trigger.name], parameter: value };
      } else {
        triggerParams = _ActionManager[trigger.name];
      }
      for (let j = 0; j < trigger.children.length; j++) {
        if (!trigger.detached) {
          traverse(trigger.children[j], triggerParams, null, null);
        }
      }
    }
  }
  /**
   * Get a trigger name by index
   * @param trigger defines the trigger index
   * @returns a trigger name
   */
  static GetTriggerName(trigger) {
    switch (trigger) {
      case 0:
        return "NothingTrigger";
      case 1:
        return "OnPickTrigger";
      case 2:
        return "OnLeftPickTrigger";
      case 3:
        return "OnRightPickTrigger";
      case 4:
        return "OnCenterPickTrigger";
      case 5:
        return "OnPickDownTrigger";
      case 6:
        return "OnDoublePickTrigger";
      case 7:
        return "OnPickUpTrigger";
      case 8:
        return "OnLongPressTrigger";
      case 9:
        return "OnPointerOverTrigger";
      case 10:
        return "OnPointerOutTrigger";
      case 11:
        return "OnEveryFrameTrigger";
      case 12:
        return "OnIntersectionEnterTrigger";
      case 13:
        return "OnIntersectionExitTrigger";
      case 14:
        return "OnKeyDownTrigger";
      case 15:
        return "OnKeyUpTrigger";
      case 16:
        return "OnPickOutTrigger";
      default:
        return "";
    }
  }
};
ActionManager.NothingTrigger = 0;
ActionManager.OnPickTrigger = 1;
ActionManager.OnLeftPickTrigger = 2;
ActionManager.OnRightPickTrigger = 3;
ActionManager.OnCenterPickTrigger = 4;
ActionManager.OnPickDownTrigger = 5;
ActionManager.OnDoublePickTrigger = 6;
ActionManager.OnPickUpTrigger = 7;
ActionManager.OnPickOutTrigger = 16;
ActionManager.OnLongPressTrigger = 8;
ActionManager.OnPointerOverTrigger = 9;
ActionManager.OnPointerOutTrigger = 10;
ActionManager.OnEveryFrameTrigger = 11;
ActionManager.OnIntersectionEnterTrigger = 12;
ActionManager.OnIntersectionExitTrigger = 13;
ActionManager.OnKeyDownTrigger = 14;
ActionManager.OnKeyUpTrigger = 15;

export {
  Condition,
  ValueCondition,
  PredicateCondition,
  StateCondition,
  ActionManager
};
//# sourceMappingURL=chunk-EBRIRNSB.js.map
